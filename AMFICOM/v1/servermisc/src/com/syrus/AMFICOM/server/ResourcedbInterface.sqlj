/*
 * $Id: ResourcedbInterface.sqlj,v 1.3 2004/06/07 15:36:09 bass Exp $
 *
 * Copyright © 2004 Syrus Systems.
 * Научно-технический центр.
 * Проект: АМФИКОМ.
 */

package com.syrus.AMFICOM.server;

import com.syrus.AMFICOM.CORBA.Constants;
import com.syrus.AMFICOM.CORBA.General.octetSeqHolder;
import com.syrus.AMFICOM.CORBA.Resource.*;
import com.syrus.util.database.ByteArrayDatabase;
import java.sql.*;
import java.util.Vector;
import oracle.jdbc.driver.OracleResultSet;
import oracle.sql.BLOB;
import sqlj.runtime.ConnectionContext;
import sqlj.runtime.ref.DefaultContext;

/**
 * @version $Revision: 1.3 $, $Date: 2004/06/07 15:36:09 $
 * @module servermisc
 */
public class ResourcedbInterface
{
	static final String descids[] =
	{
		"accessport", "ACCESSPORTS", "",
		"accessporttype", "ACCESSPORTTYPES", "",
		"agent", "AGENTS", "",
		"alarm", "ALARMS", " where STATUS != 4",
		"analysis", "ANALYSIS", "",
		"analysistype", "ANALYSISTYPES", "",
		"cablelink", "CABLELINKS", "",
		"cablelinktype", "CABLETYPES", "",
		"cableport", "CABLEPORTS", "",
		"cableporttype", "CABLEPORTTYPES", "",
		"characteristictype", "CHARACTERISTICTYPES", "",
		"client", "CLIENTS", "",
		"criteriaset", "CRITERIASETS", "",
		"criteriatype", "CRITERIATYPES", "",
		"domain", "DOMAINS", "",
		"elementattributetype", "ELEMENTATTRIBUTETYPES", "",
		"equipment", "EQUIPMENTS", " where IS_KIS = 0",
		"equipmenttype", "EQUIPMENTTYPES", "",
		"evaluation", "EVALUATIONS", "",
		"evaluationtype", "EVALUATIONTYPES", "",
		"globalparametertype", "PARAMETERTYPES", "",
		"imageresource", "IMAGERESOURCES", " where source_string != 'scheme'",
		"ismmapcontext", "ISMMAPCONTEXTS", "",
		"kis", "EQUIPMENTS", " where IS_KIS = 1",
		"link", "LINKS", "",
		"linktype", "LINKTYPES", "",
		"mapcontext", "MAPCONTEXTS", "",
		"maplinkproto", "MAPLINKPROTOELEMENTS", "",
		"mappathproto", "MAPPATHPROTOELEMENTS", "",
		"mapprotogroup", "MAPPROTOGROUPS", "",
		"mapprotoelement", "MAPPROTOELEMENTS", "",
		"modeling", "MODELING", "",
		"modelingtype", "MODELINGTYPES", "",
		"monitoredelement", "MONITOREDELEMENTS", "",
		"operatorcategory", "CATEGORIES", "",
		"operatorgroup", "GROUPS", "",
		"operatorprofile", "OPERATORPROFILES", "",
		"path", "TRANSMISSIONPATHS", "",
		"pathtype", "PATHTYPES", "",
		"port", "PORTS", "",
		"porttype", "PORTTYPES", "",
		"proto", "SCHEMEPROTOELEMENTS", " where IS_TOP_LEVEL = 1",
		"reporttemplate", "REPORTTEMPLATES", "",
		"resultset", "RESULTSETS", "",
		"scheme", "SCHEMES", "",
		"server", "SERVERS", "",
		"test", "TESTS", " where DELETED is null",
		"testonetime", "TESTS", " where DELETED is null and TEMPORAL_TYPE = 0",
		"testsetup", "TESTSETUPS", "",
		"testtype", "TESTTYPES", ""
	};

	static final String seqids[] =
	{
		"accessport", "accprt", "ACCPRT_SEQ",
		"actionargument", "acarg", "AARG_SEQ",
		"actionparameter", "acpar", "APAR_SEQ",
		"agent", "agent", "ADMIN_SEQ",
		"alarm", "alrm", "ALRM_SEQ",
		"alarmrule", "alrm", "ALRM_SEQ",
		"alerting", "alrt", "ALRM_SEQ",
		"alertingmessage", "am", "ALRM_SEQ",
		"alertingmessageuser", "amu", "ALRM_SEQ",
		"analysis", "ani", "ANI_SEQ",
		"analysiscriteria", "ancri", "ATARG_SEQ",
		"analysistype", "anityp", "ANITYP_SEQ",
		"analysistypeargument", "atparg", "ATARG_SEQ",
		"analysistypecriteria", "atpcri", "ATARG_SEQ",
		"analysistypeparameter", "atppar", "ATARG_SEQ",
		"attribute", "attr", "ATTRIB_SEQ",
		"attributerule", "attrrul", "ATTRIB_SEQ",
		"cablelink", "clnk", "CABLE_SEQ",
		"cablelinkthread", "cth", "CABLE_SEQ",
		"cablelinktype", "clt", "LT_SEQ",
		"cablethread", "cth", "CABLE_SEQ",
		"cableport", "cprt", "CABLE_SEQ",
		"cableporttype", "CPRTT", "PRTT_SEQ",
		"characteristic", "char", "CHAR_SEQ",
		"client", "client", "ADMIN_SEQ",
		"comm_perm_attrib", "comattr", "COMATTR_SEQ",
		"criteria", "cri", "CRI_SEQ",
		"criteriaset", "criset", "CRISET_SEQ",
		"criteriasetmelink", "csmelnk", "CSMELNK_SEQ",
		"criteriatype", "crityp", "CRITYP_SEQ",
		"deviceport", "sdprt", "SCHPRO_SEQ",
		"domain", "domain", "DOMAIN_SEQ",
		"elementattribute", "eattr", "EATTRIB_SEQ",
		"elementcharacteristic", "echar", "ECHAR_SEQ",
		"equipment", "eq", "EQ_SEQ",
		"equipmenttype", "eqt", "EQT_SEQ",
		"etalon", "eta", "ETA_SEQ",
		"etalontypeparameter", "etatp", "ETATP_SEQ",
		"etalonparameter", "etap", "ETATP_SEQ",
		"evaluation", "eval", "EVAL_SEQ",
		"evaluationargument", "evarg", "ARG_SEQ",
		"evaluationtypeargument", "etparg", "ETARG_SEQ",
		"evaluationtypeparameter", "etppar", "ETARG_SEQ",
		"evaluationtypethreshold", "etpth", "ETARG_SEQ",
		"event", "sysev", "SYSEV_SEQ",
		"eventsource", "esrc", "SYSEVSRC_SEQ",
		"fieldreport", "fldrpt", "RPT_SEQ",
		"imageresource", "img", "IMG_SEQ",
		"ismmapcontext", "ismap", "ISMMAP_SEQ",
		"kis", "kis", "KIS_SEQ",
		"link", "link", "LINK_SEQ",
		"linktype", "lt", "LT_SEQ",
		"loggeduser", "sess", "LUSR_SEQ",
		"mapconnectionpointelement", "mapcp", "MAPCPE_SEQ",
		"mapcontext", "map", "MAP_SEQ",
		"mapelementlink", "mel", "MEL_SEQ",
		"mapequipmentelement", "mapeq", "MAPEQE_SEQ",
		"maplinkelement", "maplink", "MAPLE_SEQ",
		"mapkiselement", "mapkis", "MAPKISE_SEQ",
		"mapmarkelement", "mapmark", "MAPNODE_SEQ",
		"mapnodeelement", "mapnode", "MAPNODE_SEQ",
		"mapnodelinkelement", "mapnl", "MAPNLE_SEQ",
		"mappathelement", "mappath", "MAPPE_SEQ",
		"mappathlink", "mpl", "MPLINK_SEQ",
		"mapprotogroup", "mappg", "MAPPRO_SEQ",
		"mapprotoelement", "mappro", "MAPPRO_SEQ",
		"modeling", "mod", "ANI_SEQ",
		"monitoredelement", "mone", "MONE_SEQ",
		"monitoredelementattachment", "monea", "MONEA_SEQ",
		"operatorcategorylink", "opclink", "OPCLNK_SEQ",
		"operatorgroup", "grp", "GRP_SEQ",
		"operatorgrouplink", "opglink", "OPGLNK_SEQ",
		"operatorprofile", "oprf", "OPRF_SEQ",
		"parameter", "param", "PARAM_SEQ",
		"path", "path", "PATH_SEQ",
		"pathlink", "pathlnk", "PLNK_SEQ",
		"port", "port", "PORT_SEQ",
		"porttype", "prtt", "PRTT_SEQ",
		"proto", "sproto", "SCHPRO_SEQ",
		"reporttemplate", "rpt", "RPT_SEQ",
		"reporttemplatebox", "rptbox", "RPT_SEQ",
		"reporttemplatefield", "rptfld", "RPT_SEQ",
		"resourcequery", "resqry", "RESQRY_SEQ",
		"result", "result", "RES_SEQ",
		"resultparameter", "rpar", "RESPAR_SEQ",
		"resultset", "rset", "RSET_SEQ",
		"scheme", "sch", "SCHEME_SEQ",
		"schemecablelink", "schclnk", "SCHPRO_SEQ",
		"schemecableport", "schcprt", "SCHPRO_SEQ",
		"schemecablethread", "schcth", "SCHPRO_SEQ",
		"schemedevice", "schdev", "SCHPRO_SEQ",
		"schemeelement", "schel", "SCHEL_SEQ",
		"schemeelementlink", "schell", "SCHEL_SEQ",
		"schemelink", "schlnk", "SCHPRO_SEQ",
		"optimized_scheme_info", "soi", "SCHEME_SEQ",
		"schemepath", "schpath",  "SCHEL_SEQ",
		"schemepathlink", "spl",  "SCHEL_SEQ",
		"schemeport", "schprt", "SCHPRO_SEQ",
		"server", "server", "ADMIN_SEQ",
		"sm_solution", "sol", "SCHEME_SEQ",
/** @deprecated */		"SM_solution", "sol", "SCHEME_SEQ",
		"systemevent", "sysev", "SYSEV_SEQ",
		"systemeventsource", "esrc", "SYSEVSRC_SEQ",
		"sourceeventtyperule", "setrul", "SETRUL_SEQ",
		"test", "test", "TEST_SEQ",
		"testargument", "targ", "ARG_SEQ",
		"testargumentset", "tas", "ARG_SEQ",
		"testrequest", "treq", "TREQ_SEQ",
		"testport", "tstprt", "TSTPRT_SEQ",
		"testsetup", "tsetup", "TSETUP_SEQ",
		"testtimestamp", "ttmst", "TTMST_SEQ",
		"threshold", "thr", "THR_SEQ",
		"thresholdset", "thrset", "THRSET_SEQ",
		"user", "user", "USER_SEQ"
	};

	private ResourcedbInterface()
	{
	}

	public static String getUId(String type)
	{
		String id_s = "";
		String id_v = "";
		int id_i = 0;

		String seq_name = null;

		for (int i = 0; i < seqids.length; i += 3)
			if (seqids[i].equals(type))
			{
				id_s = seqids[i + 1];
				seq_name = seqids[i + 2];
				break;
			}

		if (seq_name == null)
		{
			System.out.println("unknown type: " + type);
			return type + System.currentTimeMillis();
//			throw new AMFICOMError("cannot generate UId");
		}

		String query = "select AMFICOM." + seq_name +
				".NEXTVAL from SYS.DUAL";

		try
		{
			ConnectionContext connCtx = DefaultContext.getDefaultContext();

			Statement statement = null;
			try
			{
				statement = connCtx.getConnection().createStatement();
			}
			catch (SQLException sqle)
			{
				System.out.println("Лажа: " + sqle.getMessage());
			}

			OracleResultSet resultset = null;
			try
			{
				resultset = (OracleResultSet )statement.executeQuery(query);
				if (resultset.next())
					id_i = resultset.getInt("NEXTVAL");
				else
				{
					System.out.println("did not succeed! :( nextval for " + seq_name);
					return type + System.currentTimeMillis();
//					throw new Exception("cannot generate UId");
				}
			}
			catch (SQLException sqle)
			{
				System.out.println("error generating unique ID for type: " + type + " - " + sqle.getMessage());
				sqle.printStackTrace();
				return type + System.currentTimeMillis();
//				throw new Exception("error generating UId");
			}
			finally
			{
				try
				{
					if (resultset != null)
						resultset.close();
					resultset = null;
					if (statement != null)
						statement.close();
					statement = null;
				}
				catch (SQLException sqle)
				{
					;
				}
			}
		}
		catch (Exception e)
		{
			System.out.println("tryndez! " + e.getMessage());
			e.printStackTrace();
			return type + System.currentTimeMillis();
//			throw new AMFICOMError("error generating UId");
		}

		id_v = id_s + String.valueOf(id_i);
		System.out.println("generate ID: " + id_v);
		return id_v;
	}

	public static Vector getDomainResourceDescriptors(String type, String domain_id)
	{
		Vector vec = new Vector();

		String id_s = null;
		String where_s = null;

		String It_id = "";
		long It_modified = 0;
		ResourceDescriptorIterator rdIt = null;

		for (int i = 0; i < descids.length; i += 3)
			if (descids[i].equals(type))
			{
				id_s = descids[i + 1];
				where_s = descids[i + 2];
				break;
			}

		if (id_s == null)
		{
			System.out.println("DESC: unknown type - " + type);
			return vec;
		}

		String query = "select ID, MODIFIED from AMFICOM." + id_s + where_s;

		if (where_s.indexOf("where") == -1)
			query += " where DOMAIN_ID = '" + domain_id + "'";
		else
			query += " and DOMAIN_ID = '" + domain_id + "'";

//		System.out.println("Execute " + query + ";");

		try
		{
			#sql
			{
				BEGIN
					open :OUT rdIt for :query;
				END;
			};
			while (rdIt.next())
			{
				It_id = rdIt.id();
				try
				{
					It_modified = rdIt.modified().getTime();
				}
				catch (Exception e)
				{
					System.out.println("CHECK! error fetchig MODIFIED for " + It_id + " from " + id_s);
					It_modified = System.currentTimeMillis();
//					e.printStackTrace();
				}
				vec.add(new ResourceDescriptor_Transferable(It_id, It_modified));
			}
			rdIt.close();
		}
		catch (Exception e)
		{
			if (rdIt != null)
				try
				{
					rdIt.close();
				}
				catch (SQLException sqle)
				{
					;
				}
				System.out.println("getDomainResourceDescriptors: " + e.getMessage());
				System.out.println("                          at: " + query);
				return new Vector();
		}
//		System.out.println("found " + vec.size() + " resource descriptors");
		return vec;
	}

	public static Vector getResourceDescriptors(String type)
	{
		Vector vec = new Vector();

		String id_s = null;
		String where_s = null;

		String It_id = "";
		long It_modified = 0;
		ResourceDescriptorIterator rdIt = null;

		for (int i = 0; i < descids.length; i += 3)
			if (descids[i].equals(type))
			{
				id_s = descids[i + 1];
				where_s = descids[i + 2];
				break;
			}

		if (id_s == null)
		{
			System.out.println("DESC: unknown type - " + type);
			return vec;
		}

		String query = "select ID, MODIFIED from AMFICOM." + id_s + where_s;

//		System.out.println("Execute " + query + ";");

		try
		{
			#sql
			{
				BEGIN
					open :OUT rdIt for :query;
				END;
			};
			while (rdIt.next())
			{
				It_id = rdIt.id();
				try
				{
					It_modified = rdIt.modified().getTime();
				}
				catch (Exception e)
				{
					System.out.println("CHECK! error fetchig MODIFIED for " + It_id + " from " + id_s);
					It_modified = System.currentTimeMillis();
//					e.printStackTrace();
				}
				vec.add(new ResourceDescriptor_Transferable(It_id, It_modified));
			}
			rdIt.close();
		}
		catch (Exception e)
		{
			if (rdIt != null)
				try
				{
					rdIt.close();
				}
				catch (SQLException sqle)
				{
					;
				}
			System.out.println("getResourceDescriptors: " + e.getMessage());
			System.out.println("                    at: " + query);
//			e.printStackTrace();
			return new Vector();
		}
		return vec;
	}

	public static ResourceDescriptor_Transferable getResourceDescriptor(String type, String id)
	{
		String id_s = null;
		String where_s = null;

		String It_id = "";
		long It_modified = 0;
		ResourceDescriptorIterator rdIt = null;

		for (int i = 0; i < descids.length; i += 3)
			if (descids[i].equals(type))
			{
				id_s = descids[i + 1];
				where_s = descids[i + 2];
				break;
			}

		if (id_s == null)
		{
			System.out.println("DESC: unknown type - " + type);
			if (type.equals("result"))
			{
				ResultDescriptorIterator rIt = null;
				String query = "select ID, ELEMENTARY_START_TIME from AMFICOM.RESULTS where ID = '" + id + "'";
				try
				{
					#sql
					{
						BEGIN
							open :OUT rIt for :query;
						END;
					};
					if (rIt.next())
					{
						It_id = rIt.id();
						try
						{
							It_modified = rIt.elementary_start_time().getTime();
						}
						catch (Exception e)
						{
							System.out.println("CHECK! error fetchig elementary_start_time for " + It_id + " from " + id_s);
							It_modified = System.currentTimeMillis();
						}
						rIt.close();
						return new ResourceDescriptor_Transferable(It_id, It_modified);
					}
					else
						rIt.close();
				}
				catch (Exception e)
				{
					if (rIt != null)
						try
						{
							rIt.close();
						}
						catch (SQLException sqle)
						{
							;
						}
					System.out.println("getResourceDescriptor: " + e.getMessage());
					System.out.println("                    at: " + query);
					return null;
				}
			}
			return null;
		}

		String query = "select ID, MODIFIED from AMFICOM." + id_s + where_s;
		if (query.indexOf("where") != -1)
			query += " and ID = '" + id + "'";
		else
			query += " where ID = '" + id + "'";

//		System.out.println("Execute " + query + ";");

		try
		{
			#sql
			{
				BEGIN
					open :OUT rdIt for :query;
				END;
			};
			if (rdIt.next())
			{
				It_id = rdIt.id();
				try
				{
					It_modified = rdIt.modified().getTime();
				}
				catch (Exception e)
				{
					System.out.println("CHECK! error fetchig MODIFIED for " + It_id + " from " + id_s);
					It_modified = System.currentTimeMillis();
//					e.printStackTrace();
				}
				rdIt.close();
				return new ResourceDescriptor_Transferable(It_id, It_modified);
			}
			else
				rdIt.close();
		}
		catch (Exception e)
		{
			if (rdIt != null)
				try
				{
					rdIt.close();
				}
				catch (SQLException sqle)
				{
					;
				}
			System.out.println("getResourceDescriptor: " + e.getMessage());
			System.out.println("                    at: " + query);
//			e.printStackTrace();
			return null;
		}
		return null;
	}

	public static int updateImage(String im_id, byte bytes[])
	{
		System.out.println("update image: " + im_id);
		try
		{
			ConnectionContext connCtx2 = DefaultContext.getDefaultContext();
			(new ByteArrayDatabase(bytes)).saveAsBlob(
				connCtx2.getConnection(),
				"AMFICOM.IMAGERESOURCES",
				"IMG",
				"id = '" + im_id + "'");
/*
			#sql { select IMG into :blob from AMFICOM.IMAGERESOURCES
			where ID = :im_id for update };
			putBlob(blob, bytes);
			#sql { update AMFICOM.IMAGERESOURCES set IMG = :blob where ID = :im_id };
*/
			#sql { commit };
		}
		catch (Exception e)
		{
			System.out.println("error saving image: " + e.getMessage());
			e.printStackTrace();
			return Constants.ERROR_SAVING;
		}
		return Constants.ERROR_NO_ERROR;
	}

	public static String saveImage(byte bytes[])
	{
		String im_id = getUId("imageresource");
		System.out.println("new image: " + im_id);
		try
		{
			#sql {
				insert into AMFICOM.IMAGERESOURCES
					(ID, NAME, CODENAME, FILENAME, SOURCE_STRING, IMG)
					values (
						:im_id,
						'bytes',
						'bytes',
						'',
						'bytes',
						empty_blob() ) };
		}
		catch (SQLException sqle)
		{
			System.out.println("could not insert image: " + sqle.getMessage());
			sqle.printStackTrace();
			return null;
		}
		try
		{
			System.out.println("blob save for " + im_id + " size " + bytes.length);

			ConnectionContext connCtx2 = DefaultContext.getDefaultContext();
			(new ByteArrayDatabase(bytes)).saveAsBlob(
				connCtx2.getConnection(),
				"AMFICOM.IMAGERESOURCES",
				"IMG",
				"id = '" + im_id + "'");
/*
			#sql { select IMG into :blob from AMFICOM.IMAGERESOURCES
			where ID = :im_id for update };
			putBlob(blob, bytes);
			#sql { update AMFICOM.IMAGERESOURCES set IMG = :blob where ID = :im_id };
*/
			#sql { commit };
		}
		catch (Exception e)
		{
			System.out.println("error saVing image: " + e.getMessage());
			e.printStackTrace();
			return null;
		}
		return im_id;
	}

	public static int saveImage(ImageResource_Transferable img)
	{
		try
		{
			#sql {
				select ID from AMFICOM.IMAGERESOURCES
					where ID = :(img.id)
			};
			System.out.println("update image: " + img.id);
		}
		catch (SQLException sqle1)
		{
			System.out.println("new image: " + img.id);
			try
			{
				#sql {
					insert into AMFICOM.IMAGERESOURCES
						(ID, NAME, CODENAME, FILENAME, SOURCE_STRING, IMG)
						values (
							:(img.id),
							:(img.source_string),
							:(img.source_string),
							:(img.filename),
							:(img.source_string),
							empty_blob() ) };
			}
			catch (SQLException sqle2)
			{
				System.out.println("could not insert image: " + sqle2.getMessage());
				sqle2.printStackTrace();
			}
		}
		if (img.source_string.equals("bytes"))
		{
			try
			{
				System.out.println("blob save for " + img.id);

				ConnectionContext connCtx2 = DefaultContext.getDefaultContext();
				(new ByteArrayDatabase(img.image)).saveAsBlob(
					connCtx2.getConnection(),
					"AMFICOM.IMAGERESOURCES",
					"IMG",
					"id = '" + img.id + "'");
/*
				#sql { select IMG into :blob from AMFICOM.IMAGERESOURCES
					where ID = :(img.id) for update };
				putBlob(blob, img.image);
				#sql { update AMFICOM.IMAGERESOURCES set IMG = :blob where ID = :(img.id) };
*/
				#sql { commit };
			}
			catch (Exception e)
			{
				System.out.println("error saving images: " + e.getMessage());
				e.printStackTrace();
			}
		}
		return Constants.ERROR_NO_ERROR;
	}

	public static int saveImages(ImageResource_Transferable imageSeq[])
	{
		for (int i = 0; i < imageSeq.length; i++)
			saveImage(imageSeq[i]);
		return Constants.ERROR_NO_ERROR;
	}

	public static ImageResource_Transferable loadImage(String image_id)
	{
		try
		{
			String id;
			String name;
			String codename;
			String filename;
			String source_string;
			BLOB blob;
			octetSeqHolder osh = new octetSeqHolder();
			#sql {
				select ID, NAME, CODENAME, FILENAME, SOURCE_STRING, IMG
					into :id, :name, :codename, :filename, :source_string, :blob
					from AMFICOM.IMAGERESOURCES
					where ID = :image_id
			};
			ImageResource_Transferable im_r = new ImageResource_Transferable(id, codename, source_string, filename, new byte[0]);
			if (source_string.equals("file"))
				return im_r;
			else if ((source_string.equals("bytes") || (source_string.equals("scheme")))
				&& (getBlob(blob, osh) == 0))
			{
				im_r.image = osh.value;
				return im_r;
			}
		}
		catch (Exception e)
		{
			System.out.println("error loading image ID: " + image_id + " - " + e.getMessage());
//			e.printStackTrace();
		}
		return null;
	}

	public static int loadImages(
			ImageResourceSeq_TransferableHolder imageseq,
			Vector image_ids)
	{
		int i;
		int len;
		ImageResource_Transferable im_r;
		Vector vector = new Vector();
		Vector loaded_vector = new Vector();
		ImageResource_Transferable ir_t[];

		len = image_ids.size();
		for (i = 0; i < len; i++)
		{
			String im_id = (String )image_ids.get(i);
			if (!loaded_vector.contains(im_id))
			{
				im_r = loadImage(im_id);

				if (im_r != null)
					vector.add(im_r);
				loaded_vector.add(im_id);
			}
		}
		ir_t = new ImageResource_Transferable[vector.size()];
		vector.copyInto(ir_t);
		imageseq.value = ir_t;
		return Constants.ERROR_NO_ERROR;
	}

	/**
	 * @deprecated Use {@link getBlob(BLOB, octetSeqHolder)} instead.
	 */
	public static int GetBlob(BLOB blob, octetSeqHolder octetSeqHolder)
	{
		return getBlob(blob, octetSeqHolder);
	}

	/**
	 * Прочитать битовый поток изображения из переменной типа blob в буфер
	 *
	 * Ограничения:
	 *
	 * Возвращаемое значение - результат работы функции:
	 *	0 - изображение прочитано
	 *	1 - была ошибка - изображение не прочитано
	 *
	 * Сделать: все
	 *	приоритеты
	 */
	public static int getBlob(BLOB blob, octetSeqHolder octetSeq)
	{
		try
		{
			int length;
			long nread;
			int bufsize = 10 * 1024;
			byte mybytes[];
			byte buf[];
			int offs = 1;
			int i;

//			length = blob.length();

			#sql length = { VALUES(dbms_lob.getlength(:blob)) };

			mybytes = new byte[length];
			buf = new byte[bufsize];

			while (offs <= length)
			{
				nread = ((length - (offs - 1) > bufsize)
					? bufsize
					: (length - (offs - 1)));
//				blob.getBytes()
				#sql { call dbms_lob.read(:blob, :inout nread, :offs, :out buf) };
				for (i = 0; i < nread; i++)
					mybytes[offs - 1 + i] = buf[i];
				offs += nread;
			}
			octetSeq.value = mybytes;
			return 0;
		}
		catch (SQLException sqle)
		{
			return 1;
		}
	}

	/**
	 * @deprecated Use {@link putBlob(BLOB, byte[])} instead.
	 */
	public static int PutBlob(BLOB blob, byte octetSeq[])
	{
		return putBlob(blob, octetSeq);
	}

	/**
	 * Прочитать битовый поток изображения из переменной типа blob в буфер
	 *
	 * Ограничения:
	 *
	 * Возвращаемое значение - результат работы функции:
	 *	0 - изображение прочитано
	 *	1 - была ошибка - изображение не прочитано
	 *
	 * Сделать: все
	 *	приоритеты
	 */
	public static int putBlob(BLOB blob, byte octetSeq[]) 
	{
		try
		{
			if (blob != null)
			{
				int len = octetSeq.length;
				int nread;
				int offs = 1;
				int bufsize = 10 * 1024;
				int i;

				byte buf[] = new byte[bufsize];

//				OutputStream out = blob.getBinaryOutputStream();

				while (offs <= len)
				{
					nread = ((len - (offs - 1) > bufsize)
						? bufsize
						: (len - (offs - 1)));
					for (i = 0; i < nread; i++)
						buf[i] = octetSeq[offs - 1 + i];
					#sql { call dbms_lob.write(:INOUT blob, :nread, :offs, :buf) };
//					out.write(buf, offs, nread);
					offs += nread;
				}
			}
			return 0;
		}
		catch (SQLException sqle)
		{
			System.out.println("I/O error: " + sqle.getMessage());
			return 1;
//			throw new AMFICOMError(e.getMessage());
		}
	}

/*
	public static void checkResultSet(String domain_id)
	{
		try
		{
			Timestamp active_end_time;
			String active_id = "";
			long active_period = 2592000000L;// default 2592000000 == 30 days

			#sql { select ID, END_TIME, PERIOD
				into :active_id, :active_end_time, :active_period
				from RESULTSETS
				where ACTIVE = 1 and DOMAIN_ID = :domain_id
			};
			if (active_end_time.getTime() < System.currentTimeMillis())
			{
				String id = getUId("resultset");
				long l1 = active_end_time.getTime() + active_period;
				if (l1 < System.currentTimeMillis())
					l1 = System.currentTimeMillis() + active_period;
				Timestamp new_end_time = new Timestamp(l1);
				String name = id;
				#sql { insert into resultsets(
						ID,
						NAME,
						COMMENTS,
						DOMAIN_ID,
						ACTIVE,
						ACTIVE_PERIOD,
						CREATED,
						MODIFIED,
						START_TIME,
						END_TIME)
					values(
						:id,
						:name,
						'',
						:domain_id,
						1,
						:active_period,
						SYSDATE,
						SYSDATE,
						:active_end_time,
						:new_end_time)
				};
				#sql { update resultsets set active = 0 where id = :active_id };
				#sql { commit };
			}
		}
		catch (Exception ex)
		{
			System.out.println("error creating new active result set for domain " + domain_id + " : " + ex.getMessage());
			ex.printStackTrace();
		}

	}
*/

	#sql public static iterator ImageResourceIterator(
		String id,
		String name,
		String codename,
		String filename,
		String source_string,
		BLOB img);

	#sql public static iterator ResourceDescriptorIterator(
		String id,
		Timestamp modified);

	#sql public static iterator ResultDescriptorIterator(
		String id,
		Timestamp elementary_start_time);
}
