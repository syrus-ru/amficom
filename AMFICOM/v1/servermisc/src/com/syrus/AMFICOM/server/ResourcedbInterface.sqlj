/*
 * $Id: ResourcedbInterface.sqlj,v 1.1.1.1 2004/05/27 11:17:16 bass Exp $
 *
 * Copyright © 2004 Syrus Systems.
 * Научно-технический центр.
 * Проект: АМФИКОМ.
 */

package com.syrus.AMFICOM.server;

import com.syrus.AMFICOM.CORBA.Constants;
import com.syrus.AMFICOM.CORBA.General.OctetSequenceHolder;
import com.syrus.AMFICOM.CORBA.Resource.*;
import com.syrus.util.database.ByteArrayDatabase;
import java.sql.*;
import java.util.Vector;
import oracle.jdbc.driver.OracleResultSet;
import oracle.sql.BLOB;
import sqlj.runtime.ConnectionContext;
import sqlj.runtime.ref.DefaultContext;

/**
 * @version $Revision: 1.1.1.1 $, $Date: 2004/05/27 11:17:16 $
 * @module serveradd
 */
public class ResourcedbInterface
{
	static String[] descids = new String[] {
		"accessport", "ACCESSPORTS", "",
		"accessporttype", "ACCESSPORTTYPES", "",
		"agent", "AGENTS", "",
		"alarm", "ALARMS", " where STATUS != 4",
		"analysis", "ANALYSIS", "",
		"analysistype", "ANALYSISTYPES", "",
		"cablelink", "CABLELINKS", "",
		"cablelinktype", "CABLETYPES", "",
		"cableport", "CABLEPORTS", "",
		"cableporttype", "CABLEPORTTYPES", "",
		"characteristictype", "CHARACTERISTICTYPES", "",
		"client", "CLIENTS", "",
		"criteriaset", "CRITERIASETS", "",
		"criteriatype", "CRITERIATYPES", "",
		"domain", "DOMAINS", "",
		"elementattributetype", "ELEMENTATTRIBUTETYPES", "",
		"equipment", "EQUIPMENTS", " where IS_KIS = 0",
		"equipmenttype", "EQUIPMENTTYPES", "",
		"evaluation", "EVALUATIONS", "",
		"evaluationtype", "EVALUATIONTYPES", "",
		"globalparametertype", "PARAMETERTYPES", "",
		"imageresource", "IMAGERESOURCES", " where source_string != 'scheme'",
		"ismmapcontext", "ISMMAPCONTEXTS", "",
		"kis", "EQUIPMENTS", " where IS_KIS = 1",
		"link", "LINKS", "",
		"linktype", "LINKTYPES", "",
		"mapcontext", "MAPCONTEXTS", "",
		"maplinkproto", "MAPLINKPROTOELEMENTS", "",
		"mappathproto", "MAPPATHPROTOELEMENTS", "",
		"mapprotogroup", "MAPPROTOGROUPS", "",
		"mapprotoelement", "MAPPROTOELEMENTS", "",
		"modeling", "MODELING", "",
		"modelingtype", "MODELINGTYPES", "",
		"monitoredelement", "MONITOREDELEMENTS", "",
		"operatorcategory", "CATEGORIES", "",
		"operatorgroup", "GROUPS", "",
		"operatorprofile", "OPERATORPROFILES", "",
		"path", "TRANSMISSIONPATHS", "",
		"pathtype", "PATHTYPES", "",
		"port", "PORTS", "",
		"porttype", "PORTTYPES", "",
		"proto", "SCHEMEPROTOELEMENTS", " where IS_TOP_LEVEL = 1",
		"reporttemplate", "REPORTTEMPLATES", "",
		"resultset", "RESULTSETS", "",
		"scheme", "SCHEMES", "",
		"server", "SERVERS", "",
		"test", "TESTS", " where DELETED is null",
		"testonetime", "TESTS", " where DELETED is null and TEMPORAL_TYPE = 0",
		"testsetup", "TESTSETUPS", "",
		"testtype", "TESTTYPES", ""
	};

	static String[] seqids = new String[] {
		"accessport", "accprt", "ACCPRT_SEQ",
		"actionargument", "acarg", "AARG_SEQ",
		"actionparameter", "acpar", "APAR_SEQ",
		"agent", "agent", "ADMIN_SEQ",
		"alarm", "alrm", "ALRM_SEQ",
		"alarmrule", "alrm", "ALRM_SEQ",
		"alerting", "alrt", "ALRM_SEQ",
		"alertingmessage", "am", "ALRM_SEQ",
		"alertingmessageuser", "amu", "ALRM_SEQ",
		"analysis", "ani", "ANI_SEQ",
		"analysiscriteria", "ancri", "ATARG_SEQ",
		"analysistype", "anityp", "ANITYP_SEQ",
		"analysistypeargument", "atparg", "ATARG_SEQ",
		"analysistypecriteria", "atpcri", "ATARG_SEQ",
		"analysistypeparameter", "atppar", "ATARG_SEQ",
		"attribute", "attr", "ATTRIB_SEQ",
		"attributerule", "attrrul", "ATTRIB_SEQ",
		"cablelink", "clnk", "CABLE_SEQ",
		"cablelinkthread", "cth", "CABLE_SEQ",
		"cablelinktype", "clt", "LT_SEQ",
		"cablethread", "cth", "CABLE_SEQ",
		"cableport", "cprt", "CABLE_SEQ",
		"cableporttype", "CPRTT", "PRTT_SEQ",
		"characteristic", "char", "CHAR_SEQ",
		"client", "client", "ADMIN_SEQ",
		"comm_perm_attrib", "comattr", "COMATTR_SEQ",
		"criteria", "cri", "CRI_SEQ",
		"criteriaset", "criset", "CRISET_SEQ",
		"criteriasetmelink", "csmelnk", "CSMELNK_SEQ",
		"criteriatype", "crityp", "CRITYP_SEQ",
		"deviceport", "sdprt", "SCHPRO_SEQ",
		"domain", "domain", "DOMAIN_SEQ",
		"elementattribute", "eattr", "EATTRIB_SEQ",
		"elementcharacteristic", "echar", "ECHAR_SEQ",
		"equipment", "eq", "EQ_SEQ",
		"equipmenttype", "eqt", "EQT_SEQ",
		"etalon", "eta", "ETA_SEQ",
		"etalontypeparameter", "etatp", "ETATP_SEQ",
		"etalonparameter", "etap", "ETATP_SEQ",
		"evaluation", "eval", "EVAL_SEQ",
		"evaluationargument", "evarg", "ARG_SEQ",
		"evaluationtypeargument", "etparg", "ETARG_SEQ",
		"evaluationtypeparameter", "etppar", "ETARG_SEQ",
		"evaluationtypethreshold", "etpth", "ETARG_SEQ",
		"event", "sysev", "SYSEV_SEQ",
		"eventsource", "esrc", "SYSEVSRC_SEQ",
		"fieldreport", "fldrpt", "RPT_SEQ",
		"imageresource", "img", "IMG_SEQ",
		"ismmapcontext", "ismap", "ISMMAP_SEQ",
		"kis", "kis", "KIS_SEQ",
		"link", "link", "LINK_SEQ",
		"linktype", "lt", "LT_SEQ",
		"loggeduser", "sess", "LUSR_SEQ",
		"mapconnectionpointelement", "mapcp", "MAPCPE_SEQ",
		"mapcontext", "map", "MAP_SEQ",
		"mapelementlink", "mel", "MEL_SEQ",
		"mapequipmentelement", "mapeq", "MAPEQE_SEQ",
		"maplinkelement", "maplink", "MAPLE_SEQ",
		"mapkiselement", "mapkis", "MAPKISE_SEQ",
		"mapmarkelement", "mapmark", "MAPNODE_SEQ",
		"mapnodeelement", "mapnode", "MAPNODE_SEQ",
		"mapnodelinkelement", "mapnl", "MAPNLE_SEQ",
		"mappathelement", "mappath", "MAPPE_SEQ",
		"mappathlink", "mpl", "MPLINK_SEQ",
		"mapprotogroup", "mappg", "MAPPRO_SEQ",
		"mapprotoelement", "mappro", "MAPPRO_SEQ",
		"modeling", "mod", "ANI_SEQ",
		"monitoredelement", "mone", "MONE_SEQ",
		"monitoredelementattachment", "monea", "MONEA_SEQ",
		"operatorcategorylink", "opclink", "OPCLNK_SEQ",
		"operatorgroup", "grp", "GRP_SEQ",
		"operatorgrouplink", "opglink", "OPGLNK_SEQ",
		"operatorprofile", "oprf", "OPRF_SEQ",
		"parameter", "param", "PARAM_SEQ",
		"path", "path", "PATH_SEQ",
		"pathlink", "pathlnk", "PLNK_SEQ",
		"port", "port", "PORT_SEQ",
		"porttype", "prtt", "PRTT_SEQ",
		"proto", "sproto", "SCHPRO_SEQ",
		"reporttemplate", "rpt", "RPT_SEQ",
		"reporttemplatebox", "rptbox", "RPT_SEQ",
		"reporttemplatefield", "rptfld", "RPT_SEQ",
		"resourcequery", "resqry", "RESQRY_SEQ",
		"result", "result", "RES_SEQ",
		"resultparameter", "rpar", "RESPAR_SEQ",
		"resultset", "rset", "RSET_SEQ",
		"scheme", "sch", "SCHEME_SEQ",
		"schemecablelink", "schclnk", "SCHPRO_SEQ",
		"schemecableport", "schcprt", "SCHPRO_SEQ",
		"schemecablethread", "schcth", "SCHPRO_SEQ",
		"schemedevice", "schdev", "SCHPRO_SEQ",
		"schemeelement", "schel", "SCHEL_SEQ",
		"schemeelementlink", "schell", "SCHEL_SEQ",
		"schemelink", "schlnk", "SCHPRO_SEQ",
		"optimized_scheme_info", "soi", "SCHEME_SEQ",
		"schemepath", "schpath",  "SCHEL_SEQ",
		"schemepathlink", "spl",  "SCHEL_SEQ",
		"schemeport", "schprt", "SCHPRO_SEQ",
		"server", "server", "ADMIN_SEQ",
		"sm_solution", "sol", "SCHEME_SEQ",
/** @deprecated */		"SM_solution", "sol", "SCHEME_SEQ",
		"systemevent", "sysev", "SYSEV_SEQ",
		"systemeventsource", "esrc", "SYSEVSRC_SEQ",
		"sourceeventtyperule", "setrul", "SETRUL_SEQ",
		"test", "test", "TEST_SEQ",
		"testargument", "targ", "ARG_SEQ",
		"testargumentset", "tas", "ARG_SEQ",
		"testrequest", "treq", "TREQ_SEQ",
		"testport", "tstprt", "TSTPRT_SEQ",
		"testsetup", "tsetup", "TSETUP_SEQ",
		"testtimestamp", "ttmst", "TTMST_SEQ",
		"threshold", "thr", "THR_SEQ",
		"thresholdset", "thrset", "THRSET_SEQ",
		"user", "user", "USER_SEQ"
	};

	public ResourcedbInterface()
	{
	}

	static public String getUId(String type)
	{
		String id_s = "";
		String id_v = "";
		int id_i = 0;

		String id_pre = null;
		String seq_name = null;

		for(int i = 0; i < seqids.length; i+=3)
		{
			if(seqids[i].equals(type))
			{
				id_s = seqids[i + 1];
				seq_name = seqids[i + 2];
				break;
			}
		}

		if(seq_name == null)
		{
			System.out.println("unknown type: " + type);
			return new String(type + String.valueOf(System.currentTimeMillis()));
//			throw new AMFICOMError("cannot generate UId");
		}

		String query = "select AMFICOM." + seq_name +
				".NEXTVAL from SYS.DUAL";

		try
		{
			ConnectionContext connCtx = DefaultContext.getDefaultContext();

			Statement statement = null;
			try
			{
				statement = connCtx.getConnection().createStatement();
			}
			catch(SQLException sqlexception)
			{
				System.out.println("Лажа" + ": " + sqlexception.getMessage());
			}

			OracleResultSet resultset = null;
			try
			{
				resultset = (OracleResultSet )statement.executeQuery(query);
				if(resultset.next())
				{
					id_i = resultset.getInt("NEXTVAL");
				}
				else
				{
					System.out.println("did not succeed! :( nextval for " + seq_name);
					return new String(type + String.valueOf(System.currentTimeMillis()));
//					throw new Exception("cannot generate UId");
				}
			}
			catch(SQLException e)
			{
				System.out.println("error generating unique ID for type: " + type + " - " + e.getMessage());
				e.printStackTrace();
				return new String(type + String.valueOf(System.currentTimeMillis()));
//				throw new Exception("error generating UId");
			}
			finally
			{
				try
				{
					if(resultset != null)
						resultset.close();
					resultset = null;
					if(statement != null)
						statement.close();
					statement = null;
				}
				catch(SQLException _ex) { }
			}

		}
		catch(Exception e)
		{
			System.out.println("tryndez! " + e.getMessage());
			e.printStackTrace();
			return new String(type + String.valueOf(System.currentTimeMillis()));
//			throw new AMFICOMError("error generating UId");
		}

		id_v = id_s + String.valueOf(id_i);
		System.out.println("generate ID: " + id_v);
		return id_v;
	}

	static public Vector getDomainResourceDescriptors(String type, String domain_id)
	{
		Vector vec = new Vector();

		String id_s = null;
		String where_s = null;

		String It_id = "";
		long It_modified = 0;
		ResourceDescriptorIterator rdIt = null;

		for(int i = 0; i < descids.length; i += 3)
		{
			if(descids[i].equals(type))
			{
				id_s = descids[i + 1];
				where_s = descids[i + 2];
				break;
			}
		}

		if(id_s == null)
		{
			System.out.println("DESC: unknown type - " + type);
			return vec;
		}

		String query = "select ID, MODIFIED from AMFICOM." + id_s + where_s;

		if(where_s.indexOf("where") == -1)
			query += " where DOMAIN_ID = '" + domain_id + "'";
		else
			query += " and DOMAIN_ID = '" + domain_id + "'";

//		System.out.println("Execute " + query + ";");

		try
		{
			#sql
			{
				BEGIN
					open :OUT rdIt for :query;
				END;
			};
			while(rdIt.next())
			{
				It_id = rdIt.id();
				try{
				It_modified = rdIt.modified().getTime();
				}catch(Exception ex)
				{
					System.out.println("CHECK! error fetchig MODIFIED for " + It_id + " from " + id_s);
					It_modified = System.currentTimeMillis();
//					e.printStackTrace();
				}
				vec.add(new ResourceDescriptor_Transferable(It_id, It_modified));
			}
			rdIt.close();
		}
		catch(Exception e)
		{
			if(rdIt != null) try {
			rdIt.close();
			}catch(Exception exe) {}
			System.out.println("getDomainResourceDescriptors: " + e.getMessage());
			System.out.println("                          at: " + query);
			return new Vector();
		}
//		System.out.println("found " + vec.size() + " resource descriptors");

		return vec;
	}

	static public Vector getResourceDescriptors(String type)
	{
		Vector vec = new Vector();

		String id_s = null;
		String where_s = null;

		String It_id = "";
		long It_modified = 0;
		ResourceDescriptorIterator rdIt = null;

		for(int i = 0; i < descids.length; i += 3)
		{
			if(descids[i].equals(type))
			{
				id_s = descids[i + 1];
				where_s = descids[i + 2];
				break;
			}
		}

		if(id_s == null)
		{
			System.out.println("DESC: unknown type - " + type);
			return vec;
		}

		String query = "select ID, MODIFIED from AMFICOM." + id_s + where_s;

//		System.out.println("Execute " + query + ";");

		try
		{
			#sql
			{
				BEGIN
					open :OUT rdIt for :query;
				END;
			};
			while(rdIt.next())
			{
				It_id = rdIt.id();
				try{
				It_modified = rdIt.modified().getTime();
				}catch(Exception ex)
				{
					System.out.println("CHECK! error fetchig MODIFIED for " + It_id + " from " + id_s);
					It_modified = System.currentTimeMillis();
//					e.printStackTrace();
				}
				vec.add(new ResourceDescriptor_Transferable(It_id, It_modified));
			}
			rdIt.close();
		}
		catch(Exception e)
		{
			if(rdIt != null) try {
			rdIt.close();
			}catch(Exception exe) {}
			System.out.println("getResourceDescriptors: " + e.getMessage());
			System.out.println("                    at: " + query);
//			e.printStackTrace();
			return new Vector();
		}

		return vec;
	}

	static public ResourceDescriptor_Transferable getResourceDescriptor(String type, String id)
	{
		String id_s = null;
		String where_s = null;

		String It_id = "";
		long It_modified = 0;
		ResourceDescriptorIterator rdIt = null;

		for(int i = 0; i < descids.length; i += 3)
		{
			if(descids[i].equals(type))
			{
				id_s = descids[i + 1];
				where_s = descids[i + 2];
				break;
			}
		}

		if(id_s == null)
		{
			System.out.println("DESC: unknown type - " + type);
			if(type.equals("result"))
			{
				ResultDescriptorIterator rIt = null;
				String query = "select ID, ELEMENTARY_START_TIME from AMFICOM.RESULTS where ID = '" + id + "'";
				try
				{
					#sql
					{
						BEGIN
							open :OUT rIt for :query;
						END;
					};
					if(rIt.next())
					{
						It_id = rIt.id();
						try{
						It_modified = rIt.elementary_start_time().getTime();
						}catch(Exception ex)
						{
							System.out.println("CHECK! error fetchig elementary_start_time for " + It_id + " from " + id_s);
							It_modified = System.currentTimeMillis();
						}
						rIt.close();
						return new ResourceDescriptor_Transferable(It_id, It_modified);
					}
					else
						rIt.close();
				}
				catch(Exception e)
				{
					if(rIt != null) try {
					rIt.close();
					}catch(Exception exe) {}
					System.out.println("getResourceDescriptor: " + e.getMessage());
					System.out.println("                    at: " + query);
					return null;
				}
			}
			return null;
		}

		String query = "select ID, MODIFIED from AMFICOM." + id_s + where_s;
		if(query.indexOf("where") != -1)
			query += " and ID = '" + id + "'";
		else
			query += " where ID = '" + id + "'";

//		System.out.println("Execute " + query + ";");

		try
		{
			#sql
			{
				BEGIN
					open :OUT rdIt for :query;
				END;
			};
			if(rdIt.next())
			{
				It_id = rdIt.id();
				try{
				It_modified = rdIt.modified().getTime();
				}catch(Exception ex)
				{
					System.out.println("CHECK! error fetchig MODIFIED for " + It_id + " from " + id_s);
					It_modified = System.currentTimeMillis();
//					e.printStackTrace();
				}
				rdIt.close();
				return new ResourceDescriptor_Transferable(It_id, It_modified);
			}
			else
				rdIt.close();
		}
		catch(Exception e)
		{
			if(rdIt != null) try {
			rdIt.close();
			}catch(Exception exe) {}
			System.out.println("getResourceDescriptor: " + e.getMessage());
			System.out.println("                    at: " + query);
//			e.printStackTrace();
			return null;
		}

		return null;
	}

	static public int updateImage(String im_id, byte[] bytes)
	{
		int i;
		int j;

		BLOB blob;

		System.out.println("update image: " + im_id);
		try
		{
				ConnectionContext connCtx2 = DefaultContext.getDefaultContext();
				ByteArrayDatabase bArr = new ByteArrayDatabase(bytes);
				bArr.saveAsBlob(
						connCtx2.getConnection(),
						"AMFICOM.IMAGERESOURCES",
						"IMG",
						"id = '" + im_id + "'");
/*
			#sql { select IMG into :blob from AMFICOM.IMAGERESOURCES
			where ID = :im_id for update };
			PutBlob(blob, bytes);
			#sql { update AMFICOM.IMAGERESOURCES set IMG = :blob where ID = :im_id };
*/
			#sql { commit };
		}
		catch(Exception e)
		{
			System.out.println("error saVing image: " + e.getMessage());
			e.printStackTrace();
			return Constants.ERROR_SAVING;
		}
		return Constants.ERROR_NO_ERROR;
	}

	static public String saveImage(byte[] bytes)
	{
		int i;
		int j;

		BLOB blob;

		String im_id = getUId("imageresource");
		System.out.println("new image: " + im_id);
		try
		{
			#sql {
				insert into AMFICOM.IMAGERESOURCES
					(ID, NAME, CODENAME, FILENAME, SOURCE_STRING, IMG)
					values (
						:im_id,
						'bytes',
						'bytes',
						'',
						'bytes',
						empty_blob() ) };
		}
		catch(SQLException ex)
		{
			System.out.println("could not insert image: " + ex.getMessage());
			ex.printStackTrace();
			return null;
		}
		try
		{
			System.out.println("blob save for " + im_id + " size " + bytes.length);

				ConnectionContext connCtx2 = DefaultContext.getDefaultContext();
				ByteArrayDatabase bArr = new ByteArrayDatabase(bytes);
				bArr.saveAsBlob(
						connCtx2.getConnection(),
						"AMFICOM.IMAGERESOURCES",
						"IMG",
						"id = '" + im_id + "'");
/*
			#sql { select IMG into :blob from AMFICOM.IMAGERESOURCES
			where ID = :im_id for update };
			PutBlob(blob, bytes);
			#sql { update AMFICOM.IMAGERESOURCES set IMG = :blob where ID = :im_id };
*/
			#sql { commit };
		}
		catch(Exception e)
		{
			System.out.println("error saVing image: " + e.getMessage());
			e.printStackTrace();
			return null;
		}
		return im_id;
	}

	static public int saveImage(ImageResource_Transferable img)
	{
		int i;
		int j;

		BLOB blob;
		try
		{
			#sql {
				select ID from AMFICOM.IMAGERESOURCES
					where ID = :(img.id)
			};
			System.out.println("update image: " + img.id);
		}
		catch(SQLException e)
		{
			System.out.println("new image: " + img.id);
			try
			{
				#sql {
					insert into AMFICOM.IMAGERESOURCES
						(ID, NAME, CODENAME, FILENAME, SOURCE_STRING, IMG)
						values (
							:(img.id),
							:(img.source_string),
							:(img.source_string),
							:(img.filename),
							:(img.source_string),
							empty_blob() ) };
			}
			catch(SQLException ex)
			{
				System.out.println("could not insert image: " + ex.getMessage());
				ex.printStackTrace();
			}
		}
		if(img.source_string.equals("bytes"))
		{
			try
			{
				System.out.println("blob save for " + img.id);

				ConnectionContext connCtx2 = DefaultContext.getDefaultContext();
				ByteArrayDatabase bArr = new ByteArrayDatabase(img.image);
				bArr.saveAsBlob(
						connCtx2.getConnection(),
						"AMFICOM.IMAGERESOURCES",
						"IMG",
						"id = '" + img.id + "'");
/*
				#sql { select IMG into :blob from AMFICOM.IMAGERESOURCES
					where ID = :(img.id) for update };
				PutBlob(blob, img.image);
				#sql { update AMFICOM.IMAGERESOURCES set IMG = :blob where ID = :(img.id) };
*/
				#sql { commit };
			}
			catch(Exception e)
			{
				System.out.println("error saVing images: " + e.getMessage());
				e.printStackTrace();
			}
		}
		return Constants.ERROR_NO_ERROR;
	}

	static public int saveImages(ImageResource_Transferable[] imageseq)
	{
		int i;
		int j;
		int len;

		BLOB blob;
		len = imageseq.length;
		for (i = 0; i < len; i++)
		{
			saveImage(imageseq[i]);
		}
		return Constants.ERROR_NO_ERROR;
	}

	static public ImageResource_Transferable loadImage(String image_id)
	{
		ImageResource_Transferable im_r = null;

		String id;
		String name;
		String codename;
		String filename;
		String source_string;
		BLOB blob;
		OctetSequenceHolder osh;

		osh = new OctetSequenceHolder();
		try
		{
			#sql {
				select ID, NAME, CODENAME, FILENAME, SOURCE_STRING, IMG
					into :id, :name, :codename, :filename, :source_string, :blob
					from AMFICOM.IMAGERESOURCES
					where ID = :image_id
			};
			im_r = new ImageResource_Transferable(id, codename, source_string, filename, new byte[0]);
			if(source_string.equals("file"))
				return im_r;
			else
			if(source_string.equals("bytes"))
			{
				if(GetBlob(blob, osh) == 0)
				{
					im_r.image = osh.value;
					return im_r;
				}
			}
			else
			if(source_string.equals("scheme"))
			{
				if(GetBlob(blob, osh) == 0)
				{
					im_r.image = osh.value;
					return im_r;
				}
			}
		}
		catch(Exception e)
		{
			System.out.println("error loading image ID: " + image_id + " - " + e.getMessage());
//			e.printStackTrace();
		}
		return null;
	}

	static public int loadImages(
			ImageResourceSeq_TransferableHolder imageseq,
			Vector image_ids)
	{
		int i;
		int len;
		ImageResource_Transferable im_r;
		Vector vector = new Vector();
		Vector loaded_vector = new Vector();
		ImageResource_Transferable ir_t[];

		String id;
		String name;
		String codename;
		String filename;
		String source_string;
		BLOB blob;
		OctetSequenceHolder osh;
		len = image_ids.size();
		for(i = 0; i < len; i++)
		{
			String im_id = (String )image_ids.get(i);
			if(!loaded_vector.contains(im_id))
			{
				im_r = loadImage(im_id);

				if(im_r != null)
					vector.add(im_r);
				loaded_vector.add(im_id);
			}
		}
		ir_t = new ImageResource_Transferable[vector.size()];
		vector.copyInto(ir_t);
		imageseq.value = ir_t;
		return Constants.ERROR_NO_ERROR;
	}

// *
// * Прочитать битовый поток изображения из переменной типа blob в буфер
// *
// * Ограничения:
// *
// * Возвращаемое значение - результат работы функции:
// *	0 - изображение прочитано
// *	1 - была ошибка - изображение не прочитано
// *
// * Сделать: все
// *	приоритеты
// *
	static public int GetBlob(BLOB blob, OctetSequenceHolder octseqh)
	{
	try
	{
		int length;
		long nread;
		int bufsize = 10*1024;
		byte[] mybytes;
		byte[] buf;
		int offs = 1;
		int i;

//		length = blob.length();

		#sql length = { VALUES(dbms_lob.getlength(:blob)) };

		mybytes = new byte[length];
		buf = new byte[bufsize];

		while ( offs <= length)
		{
			nread = ((length - (offs - 1) > bufsize)?
				bufsize : (length - (offs - 1)));
//			blob.getBytes()
			#sql { call dbms_lob.read(:blob, :inout nread, :offs, :out buf) };
			for(i = 0; i < nread; i++)
				mybytes[offs - 1 + i] = buf[i];
			offs += nread;
		}
		octseqh.value = mybytes;
		return 0;
	}
	catch(SQLException e)
	{
		return 1;
	}
	}

// *
// * Прочитать битовый поток изображения из переменной типа blob в буфер
// *
// * Ограничения:
// *
// * Возвращаемое значение - результат работы функции:
// *	0 - изображение прочитано
// *	1 - была ошибка - изображение не прочитано
// *
// * Сделать: все
// *	приоритеты
// *
	static public int PutBlob(BLOB blob, byte [] octseq) 
	{
	try
	{
		if (blob != null)
		{
			int len = octseq.length;
			int nread;
			int offs = 1;
			int bufsize = 10*1024;
			int i;

			byte buf[] = new byte[bufsize];

//			OutputStream out = blob.getBinaryOutputStream();

			while ( offs <= len)
			{
				nread = ((len - (offs - 1) > bufsize)?
					bufsize : (len - (offs - 1)));
				for(i = 0; i < nread; i++)
					buf[i] = octseq[offs - 1 + i];
				#sql { call dbms_lob.write(:INOUT blob, :nread, :offs, :buf) };
//				out.write(buf,offs,nread);
				offs += nread;
			}

		}
		return 0;
	}
	catch(SQLException e)
	{
		System.out.println("IO error" + ": " + e.getMessage());
		return 1;
//		throw new AMFICOMError(e.getMessage());
	}
	}
/*
	static public void checkResultSet(String domain_id)
	{
		try
		{
			Timestamp active_end_time;
			String active_id = "";
			long active_period = 2592000000L;// default 2592000000 == 30 days

			#sql { select ID, END_TIME, PERIOD
				into :active_id, :active_end_time, :active_period
				from RESULTSETS
				where ACTIVE = 1 and DOMAIN_ID = :domain_id
			};
			if(active_end_time.getTime() < System.currentTimeMillis())
			{
				String id = getUId("resultset");
				long l1 = active_end_time.getTime() + active_period;
				if(l1 < System.currentTimeMillis())
					l1 = System.currentTimeMillis() + active_period;
				Timestamp new_end_time = new Timestamp(l1);
				String name = id;
				#sql { insert into resultsets(
						ID,
						NAME,
						COMMENTS,
						DOMAIN_ID,
						ACTIVE,
						ACTIVE_PERIOD,
						CREATED,
						MODIFIED,
						START_TIME,
						END_TIME)
					values(
						:id,
						:name,
						'',
						:domain_id,
						1,
						:active_period,
						SYSDATE,
						SYSDATE,
						:active_end_time,
						:new_end_time)
				};
				#sql { update resultsets set active = 0 where id = :active_id };
				#sql { commit };
			}
		}
		catch(Exception ex)
		{
			System.out.println("error creating new active result set for domain " + domain_id + " : " + ex.getMessage());
			ex.printStackTrace();
		}

	}
*/

	#sql public static iterator ImageResourceIterator (
		String id,
		String name,
		String codename,
		String filename,
		String source_string,
		BLOB img
		);

	#sql public static iterator ResourceDescriptorIterator (
		String id,
		Timestamp modified);

	#sql public static iterator ResultDescriptorIterator (
		String id,
		Timestamp elementary_start_time);
}
