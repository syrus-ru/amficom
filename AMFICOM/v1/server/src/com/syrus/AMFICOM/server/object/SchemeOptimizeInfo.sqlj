/*
 * $Id: SchemeOptimizeInfo.sqlj,v 1.1.2.6 2004/10/18 15:31:42 bass Exp $
 *
 * Copyright © 2004 Syrus Systems.
 * Научно-технический центр.
 * Проект: АМФИКОМ.
 */

package com.syrus.AMFICOM.server.object;

import com.syrus.AMFICOM.CORBA.Scheme.SchemeOptimizeInfo_Transferable;
import com.syrus.util.ByteArray;
import com.syrus.util.database.JdbcBlobManager;
import java.io.*;
import java.sql.*;
import java.util.Vector;
import sqlj.runtime.ref.DefaultContext;

/**
 * @version $Revision: 1.1.2.6 $, $Date: 2004/10/18 15:31:42 $
 * @author $Author: bass $
 * @module server_v1
 */
final class SchemeOptimizeInfo {
	private SchemeOptimizeInfo_Transferable soi;

	private String id = "";
	private String scheme_id = "";
	private String solution_compact_id = "";
	private String date = "";

	private int optimize_mode = 0;

	private double iterations = 0.0;
	private double price = 0.0;
	private double wavelength = 0.0;
	private double len_margin = 0.0;
	private double mutation_rate = 0.0;
	private double mutation_degree = 0.0;
	private double rtu_delete_prob = 0.0;
	private double rtu_create_prob = 0.0;
	private double nodes_splice_prob = 0.0;
	private double nodes_cut_prob = 0.0;
	private double survivor_rate = 0.0;

	private double[] refl_prices = new double[0];
	private double[] switchPrices = new double[0];

   	private String[] refl_names = new String[0];
	private String[] switch_names = new String[0];

	private double[] refl_ranges = new double[0];
	private double[] switch_nports = new double[0];

   	private byte[] refl_prices_b = new byte[0];
	private byte[] switch_prices_b = new byte[0];

   	private byte[] refl_names_b = new byte[0];
	private byte[] switch_names_b = new byte[0];

	private byte[] refl_ranges_b = new byte[0];
	private byte[] switch_nports_b = new byte[0];

	SchemeOptimizeInfo(final Connection conn, SchemeOptimizeInfo_Transferable soi) throws SQLException {
		DefaultContext connCtx = new DefaultContext(conn);

		this.soi = soi;
		this.id = soi.id;
		this.scheme_id = soi.schemeId;
		this.solution_compact_id = soi.solutionCompactId;
	    	this.date = soi.date;
		this.optimize_mode = soi.optimizeMode;
		this.iterations = soi.iterations;
		this.price = soi.price;
		this.wavelength = soi.wavelength;
		this.len_margin = soi.lenMargin;
		this.mutation_rate = soi.mutationRate;
		this.mutation_degree = soi.mutationDegree;
		this.rtu_delete_prob = soi.rtuDeleteProb;
		this.rtu_create_prob = soi.rtuCreateProb;
		this.nodes_splice_prob = soi.nodesSpliceProb;
		this.nodes_cut_prob = soi.nodesCutProb;
		this.survivor_rate = soi.survivorRate;
		this.price = soi.price;
		this.iterations = soi.iterations;
		this.refl_prices = new double[soi.reflPrices.length];
		for (int i = 0; i < soi.reflPrices.length; i++)
			this.refl_prices[i] = soi.reflPrices[i];
		this.switchPrices = new double[soi.switchPrices.length];
		for (int i = 0; i < soi.switchPrices.length; i++)
			this.switchPrices[i] = soi.switchPrices[i];
		this.refl_names = new String[soi.reflNames.length];
		for (int i = 0; i < soi.reflNames.length; i++)
			this.refl_names[i] = soi.reflNames[i];
		this.switch_names = new String[soi.switchNames.length];
		for (int i = 0; i < soi.switchNames.length; i++)
			this.switch_names[i] = soi.switchNames[i];
		this.refl_ranges = new double[soi.reflRanges.length];
		for (int i = 0; i < soi.reflRanges.length; i++)
			this.refl_ranges[i] = soi.reflRanges[i];
		this.switch_nports = new double[soi.switchNports.length];
		for (int i = 0; i < soi.switchNports.length; i++)
			this.switch_nports[i] = soi.switchNports[i];
		#sql [connCtx] {
			INSERT INTO amficom.schemeoptimizeinfo (id, scheme_id, solution_compact_id, opt_date, optimize_mode, iterations, price, wavelength, len_margin, mutation_rate, mutation_degree, rtu_delete_prob, rtu_create_prob, nodes_splice_prob, nodes_cut_prob, survivor_rate, refl_prices, refl_names, refl_ranges, switch_prices, switch_nports, switch_names) VALUES (:id, :scheme_id, :solution_compact_id, :date, :optimize_mode, :iterations, :price, :wavelength, :len_margin, :mutation_rate, :mutation_degree, :rtu_delete_prob, :rtu_create_prob, :nodes_splice_prob, :nodes_cut_prob, :survivor_rate, empty_blob(), empty_blob(), empty_blob(), empty_blob(), empty_blob(), empty_blob())
		};
		try {
			refl_prices_b = ByteArray.toByteArray(refl_prices);
			refl_ranges_b = ByteArray.toByteArray(refl_ranges);
			switch_prices_b = ByteArray.toByteArray(switchPrices);
			switch_nports_b = ByteArray.toByteArray(switch_nports);
		} catch (IOException ex) {
			refl_prices_b = new byte[0];
			refl_ranges_b = new byte[0];
			switch_prices_b = new byte[0];
			switch_nports_b = new byte[0];
		}
		try {
			refl_names_b = toByteArray(refl_names);
			switch_names_b = toByteArray(switch_names);
		} catch(Exception ex) {
			refl_names_b = new byte[0];
			switch_names_b = new byte[0];
		}
		JdbcBlobManager.setData(conn, "refl_prices", "amficom.schemeoptimizeinfo", "id = '" + id + '\'', false, refl_prices_b);
		JdbcBlobManager.setData(conn, "refl_names", "amficom.schemeoptimizeinfo", "id = '" + id + '\'', false, refl_names_b);
		JdbcBlobManager.setData(conn, "refl_ranges", "amficom.schemeoptimizeinfo", "id = '" + id + '\'', false, refl_ranges_b);
		JdbcBlobManager.setData(conn, "switchPrices", "amficom.schemeoptimizeinfo", "id = '" + id + '\'', false, switch_prices_b);
		JdbcBlobManager.setData(conn, "switch_nports", "amficom.schemeoptimizeinfo", "id = '" + id + '\'', false, switch_nports_b);
		JdbcBlobManager.setData(conn, "switch_names", "amficom.schemeoptimizeinfo", "id = '" + id + '\'', false, switch_names_b);
		conn.commit();
	}

	SchemeOptimizeInfo(final Connection conn, String soi_id) throws SQLException {
		DefaultContext connCtx = new DefaultContext(conn);

		Blob refl_prices_blob;
		Blob switch_prices_blob;

		Blob refl_ranges_blob;
		Blob switch_nports_blob;

		Blob refl_names_blob;
		Blob switch_names_blob;

		#sql [connCtx] { select
				id,
		    	scheme_id,
				solution_compact_id,
				opt_date,
		optimize_mode,
		iterations,
		price,
		wavelength,
		    	len_margin,
				mutation_rate,
				mutation_degree,
				rtu_delete_prob,
				rtu_create_prob,
				nodes_splice_prob,
				nodes_cut_prob,
				survivor_rate,
		refl_prices,
		refl_names,
		refl_ranges,
		switch_prices,
		switch_nports,
		switch_names
		into
				:id,
		    	:scheme_id,
				:solution_compact_id,
				:date,
		:optimize_mode,
		:iterations,
		:price,
		:wavelength,
		    	:len_margin,
				:mutation_rate,
				:mutation_degree,
				:rtu_delete_prob,
				:rtu_create_prob,
				:nodes_splice_prob,
				:nodes_cut_prob,
				:survivor_rate,
		:refl_prices_blob,
		:refl_names_blob,
		:refl_ranges_blob,
		:switch_prices_blob,
		:switch_nports_blob,
		:switch_names_blob
	    from SCHEMEOPTIMIZEINFO
	    where id = :soi_id
	};

		refl_prices_b = JdbcBlobManager.getData(refl_prices_blob);
		switch_prices_b = JdbcBlobManager.getData(switch_prices_blob);
		
		refl_prices = new ByteArray(refl_prices_b).toDoubleArray();
		switchPrices = new ByteArray(switch_prices_b).toDoubleArray();
		
		refl_ranges_b = JdbcBlobManager.getData(refl_ranges_blob);
		switch_nports_b = JdbcBlobManager.getData(switch_nports_blob);
		
		refl_ranges = new ByteArray(refl_ranges_b).toDoubleArray();
		switch_nports = new ByteArray(switch_nports_b).toDoubleArray();
		
		refl_names_b = JdbcBlobManager.getData(refl_names_blob);
		switch_names_b = JdbcBlobManager.getData(switch_names_blob);
		
		refl_names = toStringArray(refl_names_b);
		switch_names = toStringArray(switch_names_b);
	}

	void delete(final Connection conn) throws SQLException {
		DefaultContext connCtx = new DefaultContext(conn);

		#sql [connCtx] {
			DELETE FROM amficom.schemeoptimizeinfo WHERE id = :id
		};
		conn.commit();
	}

	private byte[] toByteArray(String[] s) {
	    	try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			DataOutputStream oos = new DataOutputStream(baos);
			for (int i = 0; i < s.length; i++)
				oos.writeUTF(s[i]);
			return baos.toByteArray();
		} catch (IOException e) {
			return new byte[0];
		}
	}

	private String[] toStringArray(byte[] bytes) {
		try {
			Vector vec = new Vector();
			ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
			DataInputStream ois = new DataInputStream(bais);
			while(ois.available() > 0)
				vec.add(ois.readUTF());
			return (String[]) vec.toArray(new String[0]);
		} catch(IOException e) {
			return new String[0];
		}
	}

    private SchemeOptimizeInfo_Transferable getTransferable() {
    	soi = new SchemeOptimizeInfo_Transferable(
				id,
		    	scheme_id,
				solution_compact_id,
				date,
		optimize_mode,
		iterations,
		price,
		wavelength,
		    	len_margin,
				mutation_rate,
				mutation_degree,
				rtu_delete_prob,
				rtu_create_prob,
				nodes_splice_prob,
				nodes_cut_prob,
				survivor_rate,
		refl_prices,
		refl_names,
		refl_ranges,
		switchPrices,
		switch_nports,
		switch_names);
		return soi;
	}

	static SchemeOptimizeInfo_Transferable[] getSOIs(final Connection conn) throws SQLException {
		DefaultContext connCtx = new DefaultContext(conn);

		IdIterator idIt = null;
		try {
			#sql [connCtx] idIt = {
				SELECT id FROM schemeoptimizeinfo
			};
			Vector vec = new Vector();
			while (idIt.next())
				vec.add(new SchemeOptimizeInfo(conn, idIt.id()).getTransferable());
			return (SchemeOptimizeInfo_Transferable[]) vec.toArray(new SchemeOptimizeInfo_Transferable[vec.size()]);
		} finally {
			if (idIt != null)
				idIt.close();
		}
	}

	#sql public static iterator IdIterator( String id );
}
