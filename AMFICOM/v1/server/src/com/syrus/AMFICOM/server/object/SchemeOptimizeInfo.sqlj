/*
 * $Id: SchemeOptimizeInfo.sqlj,v 1.1.2.7 2004/12/23 12:06:02 bass Exp $
 *
 * Copyright © 2004 Syrus Systems.
 * Научно-технический центр.
 * Проект: АМФИКОМ.
 */

package com.syrus.AMFICOM.server.object;

import com.syrus.util.ByteArray;
import com.syrus.util.database.JdbcBlobManager;
import java.io.*;
import java.sql.*;
import java.util.Vector;
import sqlj.runtime.ref.DefaultContext;

/**
 * @version $Revision: 1.1.2.7 $, $Date: 2004/12/23 12:06:02 $
 * @author $Author: bass $
 * @module server_v1
 */
final class SchemeOptimizeInfo {
	private String id = "";
	private String scheme_id = "";
	private String solution_compact_id = "";
	private String date = "";

	private int optimize_mode = 0;

	private double iterations = 0.0;
	private double price = 0.0;
	private double wavelength = 0.0;
	private double len_margin = 0.0;
	private double mutation_rate = 0.0;
	private double mutation_degree = 0.0;
	private double rtu_delete_prob = 0.0;
	private double rtu_create_prob = 0.0;
	private double nodes_splice_prob = 0.0;
	private double nodes_cut_prob = 0.0;
	private double survivor_rate = 0.0;

	private double[] refl_prices = new double[0];
	private double[] switchPrices = new double[0];

   	private String[] refl_names = new String[0];
	private String[] switch_names = new String[0];

	private double[] refl_ranges = new double[0];
	private double[] switch_nports = new double[0];

   	private byte[] refl_prices_b = new byte[0];
	private byte[] switch_prices_b = new byte[0];

   	private byte[] refl_names_b = new byte[0];
	private byte[] switch_names_b = new byte[0];

	private byte[] refl_ranges_b = new byte[0];
	private byte[] switch_nports_b = new byte[0];

	SchemeOptimizeInfo(final Connection conn, String soi_id) throws SQLException {
		DefaultContext connCtx = new DefaultContext(conn);

		Blob refl_prices_blob;
		Blob switch_prices_blob;

		Blob refl_ranges_blob;
		Blob switch_nports_blob;

		Blob refl_names_blob;
		Blob switch_names_blob;

		#sql [connCtx] { select
				id,
		    	scheme_id,
				solution_compact_id,
				opt_date,
		optimize_mode,
		iterations,
		price,
		wavelength,
		    	len_margin,
				mutation_rate,
				mutation_degree,
				rtu_delete_prob,
				rtu_create_prob,
				nodes_splice_prob,
				nodes_cut_prob,
				survivor_rate,
		refl_prices,
		refl_names,
		refl_ranges,
		switch_prices,
		switch_nports,
		switch_names
		into
				:id,
		    	:scheme_id,
				:solution_compact_id,
				:date,
		:optimize_mode,
		:iterations,
		:price,
		:wavelength,
		    	:len_margin,
				:mutation_rate,
				:mutation_degree,
				:rtu_delete_prob,
				:rtu_create_prob,
				:nodes_splice_prob,
				:nodes_cut_prob,
				:survivor_rate,
		:refl_prices_blob,
		:refl_names_blob,
		:refl_ranges_blob,
		:switch_prices_blob,
		:switch_nports_blob,
		:switch_names_blob
	    from SCHEMEOPTIMIZEINFO
	    where id = :soi_id
	};

		refl_prices_b = JdbcBlobManager.getData(refl_prices_blob);
		switch_prices_b = JdbcBlobManager.getData(switch_prices_blob);
		
		refl_prices = new ByteArray(refl_prices_b).toDoubleArray();
		switchPrices = new ByteArray(switch_prices_b).toDoubleArray();
		
		refl_ranges_b = JdbcBlobManager.getData(refl_ranges_blob);
		switch_nports_b = JdbcBlobManager.getData(switch_nports_blob);
		
		refl_ranges = new ByteArray(refl_ranges_b).toDoubleArray();
		switch_nports = new ByteArray(switch_nports_b).toDoubleArray();
		
		refl_names_b = JdbcBlobManager.getData(refl_names_blob);
		switch_names_b = JdbcBlobManager.getData(switch_names_blob);
		
		refl_names = toStringArray(refl_names_b);
		switch_names = toStringArray(switch_names_b);
	}

	void delete(final Connection conn) throws SQLException {
		DefaultContext connCtx = new DefaultContext(conn);

		#sql [connCtx] {
			DELETE FROM amficom.schemeoptimizeinfo WHERE id = :id
		};
		conn.commit();
	}

	private byte[] toByteArray(String[] s) {
	    	try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			DataOutputStream oos = new DataOutputStream(baos);
			for (int i = 0; i < s.length; i++)
				oos.writeUTF(s[i]);
			return baos.toByteArray();
		} catch (IOException e) {
			return new byte[0];
		}
	}

	private String[] toStringArray(byte[] bytes) {
		try {
			Vector vec = new Vector();
			ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
			DataInputStream ois = new DataInputStream(bais);
			while(ois.available() > 0)
				vec.add(ois.readUTF());
			return (String[]) vec.toArray(new String[0]);
		} catch(IOException e) {
			return new String[0];
		}
	}
}
