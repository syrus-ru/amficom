/*
 * $Id: AMFICOMdbInterface.sqlj,v 1.1.2.8 2004/12/23 12:06:01 bass Exp $
 *
 * Copyright © 2004 Syrus Systems.
 * Научно-технический центр.
 * Проект: АМФИКОМ.
 */

package com.syrus.AMFICOM.server.object;

import com.syrus.AMFICOM.CORBA.Admin.*;
import com.syrus.AMFICOM.CORBA.Alarm.*;
import com.syrus.AMFICOM.CORBA.Constants;
import com.syrus.AMFICOM.CORBA.General.*;
import com.syrus.AMFICOM.CORBA.Report.*;
import com.syrus.AMFICOM.CORBA.Resource.*;
import com.syrus.AMFICOM.server.*;
import java.sql.*;
import java.util.*;
import sqlj.runtime.ref.DefaultContext;

/**
 * @version $Revision: 1.1.2.8 $, $Date: 2004/12/23 12:06:01 $
 * @author $Author: bass $
 * @module server_v1
 */
final class AMFICOMdbInterface {
	private AMFICOMdbInterface() {
	}

	static void removeMapProtoElements(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] group_ids,
			String[] proto_ids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		MapdbInterfaceProto.removeProtoGroups(conn, group_ids);
		MapdbInterfaceProto.removeProtoElements(conn, proto_ids);
	}

	static void removeSchemeProtoElements(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] element_ids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		SchemedbInterfaceProtoSave.removeProtoElements(conn, element_ids);
	}

	static void removeSchemes(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] scheme_ids,
			String[] scheme_path_ids,
			String[] scheme_cable_link_ids,
			String[] scheme_element_ids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		SchemedbInterfaceSave.removeCableLinks(conn, scheme_cable_link_ids);
		SchemedbInterfaceSave.removeSchemeElements(conn, scheme_element_ids);
		SchemedbInterfaceSave.removeSchemes(conn, scheme_ids);
	}

	static void removeMaps(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] mapseq,
			String[] equipmentseq,
			String[] kisseq,
			String[] markseq,
			String[] nodeseq,
			String[] nodelinkseq,
			String[] linkseq,
			String[] pathseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		MapdbInterfaceRemove.removeMaps(conn, mapseq);
		MapdbInterfaceRemove.removeElements(conn, equipmentseq);
		MapdbInterfaceRemove.removeKISs(conn, kisseq);
		MapdbInterfaceRemove.removeMarks(conn, markseq);
		MapdbInterfaceRemove.removeNodes(conn, nodeseq);
		MapdbInterfaceRemove.removeNodeLinks(conn, nodelinkseq);
		MapdbInterfaceRemove.removeLinks(conn, linkseq);
		MapdbInterfaceRemove.removePaths(conn, pathseq);
	}

	static void getMessages(final Connection conn, AccessIdentity_Transferable accessIdentity, MessageSeq_TransferableHolder messageseq) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		messageseq.value = new Message_Transferable[0];
	}

	static void getAlarmIdsForMonitoredElement(final Connection conn, AccessIdentity_Transferable accessIdentity, String me_id, ResourceDescriptorSeq_TransferableHolder alarmids) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		MaintenancedbInterface.getAlarmIdsForMonitoredElement(conn, me_id, alarmids);
	}

	static void loadMaintenanceData(final Connection conn, AccessIdentity_Transferable accessIdentity, EventSourceTypeSeq_TransferableHolder est, AlertingMessageSeq_TransferableHolder am, AlertingMessageUserSeq_TransferableHolder amu) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		Vector vec = MaintenancedbInterface.getEventSourceTypes(conn);
		est.value = new EventSourceType_Transferable[vec.size()];
		vec.copyInto(est.value);
		vec = MaintenancedbInterface.getAlertingMessages(conn);
		am.value = new AlertingMessage_Transferable[vec.size()];
		vec.copyInto(am.value);
		vec = MaintenancedbInterface.getAlertingMessageUsers(conn);
		amu.value = new AlertingMessageUser_Transferable[vec.size()];
		vec.copyInto(amu.value);
	}

	static void saveMaintenanceData(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			AlertingMessage_Transferable []am,
			AlertingMessageUser_Transferable []amu)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		for (int i = 0; i < am.length; i++)
			MaintenancedbInterface.saveAlertingMessages(conn, am[i]);
		for (int i = 0; i < amu.length; i++)
			MaintenancedbInterface.saveAlertingMessageUsers(conn, amu[i]);
	}

	static void removeMaintenanceData(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String amu_id)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		MaintenancedbInterface.removeAlertingMessageUser(conn, amu_id);
	}

	static void getResourceDescriptors(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String type,
			ResourceDescriptorSeq_TransferableHolder desc)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);

		Vector vec = getResourceDescriptors(conn, type);
		desc.value = new ResourceDescriptor_Transferable[vec.size()];
		vec.copyInto(desc.value);
	}

	private static Vector getResourceDescriptors(final Connection conn, String type) throws SQLException {
		Vector vec = new Vector();

		String id_s = null;
		String where_s = null;

		String itId = "";
		long itModified = 0;
		ResourceIdIterator rdIt = null;

		for (int i = 0; i < ResourcedbInterface.DESC_IDS.length; i += 3)
			if (ResourcedbInterface.DESC_IDS[i].equals(type)) {
				id_s = ResourcedbInterface.DESC_IDS[i + 1];
				where_s = ResourcedbInterface.DESC_IDS[i + 2];
				break;
			}

		if (id_s == null) {
			System.out.println("DESC: unknown type - " + type);
			return vec;
		}

		try {
			#sql [new DefaultContext(conn)] {
				BEGIN OPEN :OUT rdIt FOR :("SELECT id, modified FROM amficom." + id_s + where_s); END;
			};
			while (rdIt.next()) {
				itId = rdIt.id();
				try {
					itModified = rdIt.modified().getTime();
				} catch (Exception e) {
					e.printStackTrace();
					itModified = System.currentTimeMillis();
				}
				vec.add(new ResourceDescriptor_Transferable(itId, itModified));
			}
		} catch (Exception e) {
			e.printStackTrace();
			return new Vector();
		} finally {
			if (rdIt != null)
				rdIt.close();
		}
		return vec;
	}

	static void getResourceDescriptor(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String type,
			String id,
			ResourceDescriptor_TransferableHolder desc)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);

		desc.value = getResourceDescriptor(conn, type, id);
		if (desc.value == null)
			throw new AMFICOMRemoteException(0, "Нельзя загрузить дескриптор ресурса: " + type + " " + id);
	}

	private static ResourceDescriptor_Transferable getResourceDescriptor(final Connection conn, String type, String id) throws SQLException {
		DefaultContext connCtx = new DefaultContext(conn);

		String id_s = null;
		String where_s = null;

		String itId = "";
		long itModified = 0;
		ResourceIdIterator rdIt = null;

		for (int i = 0; i < ResourcedbInterface.DESC_IDS.length; i += 3)
			if (ResourcedbInterface.DESC_IDS[i].equals(type)) {
				id_s = ResourcedbInterface.DESC_IDS[i + 1];
				where_s = ResourcedbInterface.DESC_IDS[i + 2];
				break;
			}

		if (id_s == null) {
			System.out.println("DESC: unknown type - " + type);
			if (type.equals("result")) {
				ResultDescriptorIterator rIt = null;
				try {
					#sql [connCtx] {
						BEGIN OPEN :OUT rIt FOR :("SELECT id, elementary_start_time FROM amficom.results WHERE id = '" + id + "'"); END;
					};
					if (rIt.next()) {
						itId = rIt.id();
						try {
							itModified = rIt.elementary_start_time().getTime();
						} catch (Exception e) {
							e.printStackTrace();
							itModified = System.currentTimeMillis();
						}
						return new ResourceDescriptor_Transferable(itId, itModified);
					}
				} catch (Exception e) {
					e.printStackTrace();
					return null;
				} finally {
					if (rIt != null)
						rIt.close();
				}
			}
			return null;
		}
		try {
			#sql [connCtx] {
				BEGIN OPEN :OUT rdIt FOR :("SELECT id, modified FROM amficom." + id_s + where_s + " " + ((where_s.indexOf("where") != -1) ? "AND" : "WHERE") + " id = '" + id + "'"); END;
			};
			if (rdIt.next()) {
				itId = rdIt.id();
				try {
					itModified = rdIt.modified().getTime();
				} catch (Exception e) {
					e.printStackTrace();
					itModified = System.currentTimeMillis();
				}
				return new ResourceDescriptor_Transferable(itId, itModified);
			}
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		} finally {
			if (rdIt != null)
				rdIt.close();
		}
		return null;
	}

	static void getResourceDescriptorsByIds(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String type,
			String[] ids,
			ResourceDescriptorSeq_TransferableHolder desc)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);

		Vector vec = getResourceDescriptors(conn, type);
		Vector vec3 = new Vector();
		for (int i = 0; i < ids.length; i++)
			vec3.add(ids[i]);
		Vector vec2 = new Vector();
		for (int i = 0; i < vec.size(); i++)
		{
			ResourceDescriptor_Transferable d = (ResourceDescriptor_Transferable )vec.get(i);
			if (vec3.contains(d.resource_id))
				vec2.add(d);
		}
		desc.value = new ResourceDescriptor_Transferable[vec2.size()];
		vec2.copyInto(desc.value);
	}

	static void getDomainResourceDescriptors(final Connection conn, AccessIdentity_Transferable accessIdentity, String type, ResourceDescriptorSeq_TransferableHolder resourceDescriptorSeq) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);

		String id_s = null;
		String where_s = null;

		String itId = "";
		long itModified = 0;
		ResourceIdIterator rdIt = null;

		for (int i = 0; i < ResourcedbInterface.DESC_IDS.length; i += 3)
			if (ResourcedbInterface.DESC_IDS[i].equals(type)) {
				id_s = ResourcedbInterface.DESC_IDS[i + 1];
				where_s = ResourcedbInterface.DESC_IDS[i + 2];
				break;
			}

		Collection resourceDescriptors = new LinkedList();
		if (id_s != null) {
			try {
				#sql [new DefaultContext(conn)] {
					BEGIN OPEN :OUT rdIt FOR :("SELECT id, modified FROM amficom." + id_s + where_s + " " + ((where_s.indexOf("where") == -1) ? "WHERE" : "AND") + " domain_id = '" + accessIdentity.domain_id + "'"); END;
				};
				while (rdIt.next()) {
					itId = rdIt.id();
					try {
						itModified = rdIt.modified().getTime();
					} catch (Exception e) {
						e.printStackTrace();
						itModified = System.currentTimeMillis();
					}
					resourceDescriptors.add(new ResourceDescriptor_Transferable(itId, itModified));
				}
			} catch (Exception e) {
				e.printStackTrace();
				resourceDescriptors.clear();
			} finally {
				if (rdIt != null)
					rdIt.close();
			}
		}
		resourceDescriptorSeq.value = (ResourceDescriptor_Transferable[]) (resourceDescriptors.toArray(new ResourceDescriptor_Transferable[resourceDescriptors.size()]));
	}

	static void getTestIdsForMonitoredElement(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String me_id,
			ResourceDescriptorSeq_TransferableHolder testids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		SurveydbInterfaceLoad.getTestIdsForMonitoredElement(conn, me_id, testids);
	}

	static void getAnalysisIdsForMonitoredElement(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String me_id,
			ResourceDescriptorSeq_TransferableHolder analysisids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		analysisids.value = new ResourceDescriptor_Transferable[0];

		Vector vec = new Vector();

		ResourceIdIterator idIt = null;

		try
		{
			#sql [new DefaultContext(conn)] idIt = {
				select ID, MODIFIED from AMFICOM.ANALYSIS
				where MONITORED_ELEMENT_ID = :me_id
				and DELETED IS NULL
				and USER_ID IS NOT NULL
			};
			while(idIt.next())
				vec.add(new ResourceDescriptor_Transferable(idIt.id(), idIt.modified().getTime()));
			analysisids.value = new ResourceDescriptor_Transferable[vec.size()];
			vec.copyInto(analysisids.value);
		}
		catch (Exception e) {
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить анализ: " + e.toString());
		} finally {
			if (idIt != null)
				idIt.close();
		}
	}

	static void getModelingIdsForSchemePath(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String scheme_path_id,
			ResourceDescriptorSeq_TransferableHolder modelingids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		modelingids.value = new ResourceDescriptor_Transferable[0];

		Vector vec = new Vector();

		ResourceIdIterator idIt = null;
		try
		{

			#sql [new DefaultContext(conn)] idIt = {
				select ID, MODIFIED from AMFICOM.MODELING
				where SCHEME_PATH_ID = :scheme_path_id
				and DELETED IS NULL
				and USER_ID IS NOT NULL
			};
			while(idIt.next())
				vec.add(new ResourceDescriptor_Transferable(idIt.id(), idIt.modified().getTime()));
			modelingids.value = new ResourceDescriptor_Transferable[vec.size()];
			vec.copyInto(modelingids.value);
		} catch (Exception e) {
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить модели: " + e.toString());
		} finally {
			if (idIt != null)
				idIt.close();
		}
	}

	static void getEvaluationIdsForMonitoredElement(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String me_id,
			ResourceDescriptorSeq_TransferableHolder evaluationids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		evaluationids.value = new ResourceDescriptor_Transferable[0];

		Vector vec = new Vector();

		ResourceIdIterator idIt = null;
		try
		{

			#sql [new DefaultContext(conn)] idIt = {
				select ID, MODIFIED from AMFICOM.EVALUATIONS
				where MONITORED_ELEMENT_ID = :me_id
				and DELETED IS NULL
				and USER_ID IS NOT NULL
			};
			while(idIt.next())
				vec.add(new ResourceDescriptor_Transferable(idIt.id(), idIt.modified().getTime()));

			evaluationids.value = new ResourceDescriptor_Transferable[vec.size()];
			vec.copyInto(evaluationids.value);
		} catch (Exception e) {
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить оценку: " + e.toString());
		} finally {
			if (idIt != null)
				idIt.close();
		}
	}

	static void queryResource(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String parameter_id,
			String kis_id,
			String parameter_type_id)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		try {
			#sql [new DefaultContext(conn)] {
				insert into RESOURCEQUERIES(
					ID,
					PARAMETER_ID,
					KIS_ID,
					PARAMETER_TYPE_ID)
				values(
					:(ResourcedbInterface.getUid(conn, "resourcequery")),
					:parameter_id,
					:kis_id,
					:parameter_type_id)
			};
		} catch (SQLException sqle) {
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, sqle.toString());
		}
	}

	static void getResultSetResultIds(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String result_set_id,
			ResourceDescriptorSeq_TransferableHolder result_ids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		result_ids.value = new ResourceDescriptor_Transferable[0];

		ResultSetdbInterface.getResultIds(conn, result_set_id, result_ids);
	}

	static void getResultSetResultMEIds(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String result_set_id,
			String me_id,
			ResourceDescriptorSeq_TransferableHolder result_ids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		result_ids.value = new ResourceDescriptor_Transferable[0];

		ResultSetdbInterface.getResultIds(conn, result_set_id, me_id, result_ids);
	}

	static void removeNetDirectory(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] pt_ids,
			String[] cpt_ids,
			String[] eqt_ids,
			String[] lt_ids,
			String[] clt_ids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		NetDirectorydbInterfaceRemove.removePortTypes(conn, pt_ids);
		NetDirectorydbInterfaceRemove.removeEquipmentTypes(conn, eqt_ids);
		NetDirectorydbInterfaceRemove.removeLinkTypes(conn, lt_ids);
		NetDirectorydbInterfaceRemove.removeCablePortTypes(conn, cpt_ids);
		NetDirectorydbInterfaceRemove.removeCableLinkTypes(conn, clt_ids);
	}

	static void removeISMDirectory(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] kst_ids,
			String[] apt_ids,
			String[] tpt_ids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		ISMDirectorydbInterfaceRemove.removeAccessPortTypes(conn, apt_ids);
		ISMDirectorydbInterfaceRemove.removeRTUTypes(conn, kst_ids);
		ISMDirectorydbInterfaceRemove.removePathTypes(conn, tpt_ids);
	}

	static void removeNet(final Connection conn, AccessIdentity_Transferable accessIdentity, String[] p_ids, String[] cp_ids, String[] eq_ids, String[] l_ids, String[] cl_ids) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		NetdbInterfaceRemove.removeLinks(conn, l_ids);
		NetdbInterfaceRemove.removeCableLinks(conn, cl_ids);
		NetdbInterfaceRemove.removePorts(conn, p_ids);
		NetdbInterfaceRemove.removeCablePorts(conn, cp_ids);
		NetdbInterfaceRemove.removeEquipments(conn, eq_ids);
	}

	static void saveReportTemplates(final Connection conn, AccessIdentity_Transferable accessIdentity, ReportTemplate_Transferable[] rts) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		for (int i = 0; i < rts.length; i++)
			/**
			 * @todo A lame effort to implement error handling...
			 */
			try {
				(new ReportTemplate(conn, rts[i].id)).update(conn, rts[i]);
			} catch (Exception e) {
				e.printStackTrace();
				new ReportTemplate(conn, rts[i]);
			}
	}

	static void getStatedReportTemplates(final Connection conn, AccessIdentity_Transferable accessIdentity, String[] ids, ReportTemplateSeq_TransferableHolder reportTemplates) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		Collection c = new LinkedList();
		for (int i = 0; i < ids.length; i++)
			c.add((new ReportTemplate(conn, ids[i])).getTransferable());
		reportTemplates.value = (ReportTemplate_Transferable[]) (c.toArray(new ReportTemplate_Transferable[c.size()]));
	}

	static void removeReportTemplates(final Connection conn, AccessIdentity_Transferable accessIdentity, String[] reportTemplate_ids) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		for (int i = 0; i < reportTemplate_ids.length; i++)
			(new ReportTemplate(conn, reportTemplate_ids[i])).delete(conn);
	}

	static void removeSchemeOptimizeInfo(final Connection conn, AccessIdentity_Transferable accessIdentity, String[] soi_ids) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		for (int i = 0; i < soi_ids.length; i++)
			(new SchemeOptimizeInfo(conn, soi_ids[i])).delete(conn);
	}

	#sql public static final iterator ResourceIdIterator(
		String id, Timestamp modified);

	#sql public static final iterator ResultDescriptorIterator(
		String id, Timestamp elementary_start_time);
}
