/*
 * $Id: AMFICOMdbInterface.sqlj,v 1.1.2.4 2004/08/25 15:24:29 bass Exp $
 *
 * Copyright © 2004 Syrus Systems.
 * Научно-технический центр.
 * Проект: АМФИКОМ.
 */

package com.syrus.AMFICOM.server.object;

import com.syrus.AMFICOM.CORBA.Admin.*;
import com.syrus.AMFICOM.CORBA.Alarm.*;
import com.syrus.AMFICOM.CORBA.Constants;
import com.syrus.AMFICOM.CORBA.General.*;
import com.syrus.AMFICOM.CORBA.ISM.*;
import com.syrus.AMFICOM.CORBA.ISMDirectory.*;
import com.syrus.AMFICOM.CORBA.Map.*;
import com.syrus.AMFICOM.CORBA.Network.*;
import com.syrus.AMFICOM.CORBA.NetworkDirectory.*;
import com.syrus.AMFICOM.CORBA.Report.*;
import com.syrus.AMFICOM.CORBA.Resource.*;
import com.syrus.AMFICOM.CORBA.Scheme.*;
import com.syrus.AMFICOM.CORBA.Survey.*;
import com.syrus.AMFICOM.filter.LogicSchemeBase;
import com.syrus.AMFICOM.server.*;
import com.syrus.AMFICOM.server.event.*;
import com.syrus.AMFICOM.server.measurement.*;
import java.io.*;
import java.sql.*;
import java.util.*;
import org.omg.CORBA.StringHolder;

/**
 * @version $Revision: 1.1.2.4 $, $Date: 2004/08/25 15:24:29 $
 * @author $Author: bass $
 * @module server_v1
 */
final class AMFICOMdbInterface {
	private AMFICOMdbInterface() {
	}

	static int Logon(String username, byte[] password, String ior, AccessIdentity_TransferableHolder accessIdentity) throws AMFICOMRemoteException {
		return AMFICOMdbGeneral.Logon(username, password, ior, accessIdentity);
	}
	
	static int Logoff(AccessIdentity_Transferable accessIdentity) throws AMFICOMRemoteException {
		try {
			AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
			return AMFICOMdbGeneral.Logoff(accessIdentity);
		} catch (Exception e) {
			e.printStackTrace();
			throw new AMFICOMRemoteException(1, "fn Logoff:" + e.getMessage ());
		}
	}

	static int GetLoggedUserIds(AccessIdentity_Transferable accessIdentity, wstringSeqHolder userids) throws AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
		return AMFICOMdbGeneral.GetLoggedUserIds(accessIdentity, userids);
	}

	static int ChangePassword(AccessIdentity_Transferable accessIdentity, byte[] oldpassword, byte[] newpassword) throws AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
		return AMFICOMdbGeneral.ChangePassword(accessIdentity, oldpassword, newpassword);
	}

	static int GetObjects(
			AccessIdentity_Transferable accessIdentity,
			ImageResourceSeq_TransferableHolder imageseq,
			DomainSeq_TransferableHolder domainseq,
			OperatorCategorySeq_TransferableHolder categoryseq,
			OperatorGroupSeq_TransferableHolder groupseq,
			OperatorProfileSeq_TransferableHolder profileseq,
			CommandPermissionAttributesSeq_TransferableHolder execseq,
			UserSeq_TransferableHolder userseq)
			throws AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		Vector map_ids = new Vector();
		Vector img_ids = new Vector();

		imageseq.value = new ImageResource_Transferable[0];
		domainseq.value = new Domain_Transferable[0];
		categoryseq.value = new OperatorCategory_Transferable[0];
		groupseq.value = new OperatorGroup_Transferable[0];
		profileseq.value = new OperatorProfile_Transferable[0];
		execseq.value = new CommandPermissionAttributes_Transferable[0];
		userseq.value = new User_Transferable[0];
		ret = ObjectdbInterfaceLoad.loadDomains(domainseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceLoad.loadCategories(categoryseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceLoad.loadGroups(groupseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceLoad.loadProfiles(profileseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceLoad.loadExecs(execseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceLoad.loadUserDescriptors(userseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int GetStatedObjects(
			AccessIdentity_Transferable accessIdentity,
			String []category_ids,
			String []group_ids,
			String []profile_ids,
			OperatorCategorySeq_TransferableHolder categoryseq,
			OperatorGroupSeq_TransferableHolder groupseq,
			OperatorProfileSeq_TransferableHolder profileseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		categoryseq.value = new OperatorCategory_Transferable[0];
		groupseq.value = new OperatorGroup_Transferable[0];
		profileseq.value = new OperatorProfile_Transferable[0];

		ret = ObjectdbInterfaceLoad.loadCategories(categoryseq, category_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceLoad.loadGroups(groupseq, group_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceLoad.loadProfiles(profileseq, profile_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int GetUserDescriptors(
			AccessIdentity_Transferable accessIdentity,
			ImageResourceSeq_TransferableHolder imageseq,
			DomainSeq_TransferableHolder domainseq,
			UserSeq_TransferableHolder userseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;
		Vector img_ids = new Vector();

		imageseq.value = new ImageResource_Transferable[0];
		domainseq.value = new Domain_Transferable[0];
		userseq.value = new User_Transferable[0];

		ret = ObjectdbInterfaceLoad.loadDomains(domainseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceLoad.loadUserDescriptors(userseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int GetExecDescriptors(
			AccessIdentity_Transferable accessIdentity,
			CommandPermissionAttributesSeq_TransferableHolder execseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		execseq.value = new CommandPermissionAttributes_Transferable[0];

		ret = ObjectdbInterfaceLoad.loadExecs(execseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int SaveObjects(
			AccessIdentity_Transferable accessIdentity,
			ImageResource_Transferable[] imageseq,
			Domain_Transferable[] domainseq,
			OperatorCategory_Transferable[] categoryseq,
			OperatorGroup_Transferable[] groupseq,
			OperatorProfile_Transferable[] profileseq,
			CommandPermissionAttributes_Transferable[] execseq,
			User_Transferable[] userseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ret = ResourcedbInterface.saveImages(imageseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceSave.saveDomains(domainseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceSave.saveCategories(categoryseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceSave.saveGroups(groupseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceSave.saveProfiles(profileseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceSave.saveExecs(execseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceSave.saveUsers(userseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int RemoveObjects(
			AccessIdentity_Transferable accessIdentity,
			String[] domainseq,
			String[] categoryseq,
			String[] groupseq,
			String[] profileseq,
			String[] execseq,
			String[] userseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ret = ObjectdbInterfaceRemove.removeDomains(domainseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceRemove.removeCategories(categoryseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceRemove.removeGroups(groupseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceRemove.removeProfiles(profileseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceRemove.removeExecs(execseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ObjectdbInterfaceRemove.removeUsers(userseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int GetAdminObjects(
			AccessIdentity_Transferable accessIdentity,
			ServerSeq_TransferableHolder serverseq,
			ClientSeq_TransferableHolder clientseq,
			AgentSeq_TransferableHolder agentseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		serverseq.value = new Server_Transferable[0];
		clientseq.value = new Client_Transferable[0];
		agentseq.value = new Agent_Transferable[0];
		ret = AdmindbInterfaceLoad.loadServers(serverseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = AdmindbInterfaceLoad.loadClients(clientseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = AdmindbInterfaceLoad.loadAgents(agentseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int GetStatedAdminObjects(
			AccessIdentity_Transferable accessIdentity,
			String []server_ids,
			String []client_ids,
			String []agent_ids,
			ServerSeq_TransferableHolder serverseq,
			ClientSeq_TransferableHolder clientseq,
			AgentSeq_TransferableHolder agentseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		serverseq.value = new Server_Transferable[0];
		clientseq.value = new Client_Transferable[0];
		agentseq.value = new Agent_Transferable[0];
		ret = AdmindbInterfaceLoad.loadServers(serverseq, server_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = AdmindbInterfaceLoad.loadClients(clientseq, client_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = AdmindbInterfaceLoad.loadAgents(agentseq, agent_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int SaveAdminObjects(
			AccessIdentity_Transferable accessIdentity,
			Server_Transferable[] serverseq,
			Client_Transferable[] clientseq,
			Agent_Transferable[] agentseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ret = AdmindbInterfaceSave.saveServers(serverseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = AdmindbInterfaceSave.saveClients(clientseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = AdmindbInterfaceSave.saveAgents(agentseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int RemoveAdminObjects(
			AccessIdentity_Transferable accessIdentity,
			String[] serverseq,
			String[] clientseq,
			String[] agentseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ret = AdmindbInterfaceRemove.removeServers(serverseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = AdmindbInterfaceRemove.removeClients(clientseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = AdmindbInterfaceRemove.removeAgents(agentseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int GetMaps(
			AccessIdentity_Transferable accessIdentity,
			ImageResourceSeq_TransferableHolder imageseq,
			MapContextSeq_TransferableHolder mapseq,
			MapElementSeq_TransferableHolder equipmentseq,
			MapElementSeq_TransferableHolder kisseq,
			MapMarkElementSeq_TransferableHolder markseq,
			MapPhysicalNodeElementSeq_TransferableHolder nodeseq,
			MapNodeLinkElementSeq_TransferableHolder nodelinkseq,
			MapPhysicalLinkElementSeq_TransferableHolder linkseq,
			MapPathElementSeq_TransferableHolder pathseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		Vector map_ids = new Vector();
		Vector img_ids = new Vector();

		imageseq.value = new ImageResource_Transferable[0];
		mapseq.value = new MapContext_Transferable[0];
		equipmentseq.value = new MapElement_Transferable[0];
		kisseq.value = new MapElement_Transferable[0];
		markseq.value = new MapMarkElement_Transferable[0];
		nodeseq.value = new MapPhysicalNodeElement_Transferable[0];
		nodelinkseq.value = new MapNodeLinkElement_Transferable[0];
		linkseq.value = new MapPhysicalLinkElement_Transferable[0];
		pathseq.value = new MapPathElement_Transferable[0];

		ret = MapdbInterfaceLoad.loadMaps(accessIdentity.domain_id, map_ids, mapseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceLoad.loadMapElements(map_ids, equipmentseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ret = MapdbInterfaceLoad.loadMapKISs(map_ids, kisseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ret = MapdbInterfaceLoad.loadMapMarks(map_ids, markseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceLoad.loadMapNodes(map_ids, nodeseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceLoad.loadMapNodeLinks(map_ids, nodelinkseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceLoad.loadMapLinks(map_ids, linkseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ret = MapdbInterfaceLoad.loadMapPaths(map_ids, pathseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int GetJMaps(
			AccessIdentity_Transferable accessIdentity,
			ImageResourceSeq_TransferableHolder imageseq,
			ISMMapContextSeq_TransferableHolder mapseq,
			MapKISElementSeq_TransferableHolder kisseq,
			MapPhysicalNodeElementSeq_TransferableHolder nodeseq,
			MapNodeLinkElementSeq_TransferableHolder nodelinkseq,
			MapPhysicalLinkElementSeq_TransferableHolder linkseq,
			MapPathElementSeq_TransferableHolder pathseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		Vector map_ids = new Vector();
		Vector img_ids = new Vector();

		imageseq.value = new ImageResource_Transferable[0];
		mapseq.value = new ISMMapContext_Transferable[0];
		kisseq.value = new MapKISElement_Transferable[0];
		nodeseq.value = new MapPhysicalNodeElement_Transferable[0];
		nodelinkseq.value = new MapNodeLinkElement_Transferable[0];
		linkseq.value = new MapPhysicalLinkElement_Transferable[0];
		pathseq.value = new MapPathElement_Transferable[0];

		ret = MapdbInterfaceLoad.loadJMaps(map_ids, mapseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceLoad.loadJMapKISs(map_ids, kisseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceLoad.loadJMapNodes(map_ids, nodeseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceLoad.loadJMapNodeLinks(map_ids, nodelinkseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceLoad.loadJMapLinks(map_ids, linkseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceLoad.loadJMapPaths(map_ids, pathseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ResourcedbInterface.loadImages(imageseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int GetMap(
			AccessIdentity_Transferable accessIdentity,
			String map_id,
			ImageResourceSeq_TransferableHolder imageseq,
			MapContextSeq_TransferableHolder mapseq,
			MapElementSeq_TransferableHolder equipmentseq,
			MapElementSeq_TransferableHolder kisseq,
			MapMarkElementSeq_TransferableHolder markseq,
			MapPhysicalNodeElementSeq_TransferableHolder nodeseq,
			MapNodeLinkElementSeq_TransferableHolder nodelinkseq,
			MapPhysicalLinkElementSeq_TransferableHolder linkseq,
			MapPathElementSeq_TransferableHolder pathseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		Vector map_ids = new Vector();
		Vector img_ids = new Vector();

		imageseq.value = new ImageResource_Transferable[0];
		mapseq.value = new MapContext_Transferable[0];
		equipmentseq.value = new MapElement_Transferable[0];
		kisseq.value = new MapElement_Transferable[0];
		markseq.value = new MapMarkElement_Transferable[0];
		nodeseq.value = new MapPhysicalNodeElement_Transferable[0];
		nodelinkseq.value = new MapNodeLinkElement_Transferable[0];
		linkseq.value = new MapPhysicalLinkElement_Transferable[0];
		pathseq.value = new MapPathElement_Transferable[0];

		ret = MapdbInterfaceLoad.loadMaps(accessIdentity.domain_id, map_ids, mapseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		int ind = map_ids.indexOf(map_id);
		map_ids.clear();
		map_ids.add(map_id);
		MapContext_Transferable mc_t = mapseq.value[ind];
		mapseq.value = new MapContext_Transferable[1];
		mapseq.value[0] = mc_t;

		ret = MapdbInterfaceLoad.loadMapElements(map_ids, equipmentseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ret = MapdbInterfaceLoad.loadMapKISs(map_ids, kisseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ret = MapdbInterfaceLoad.loadMapMarks(map_ids, markseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceLoad.loadMapNodes(map_ids, nodeseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceLoad.loadMapNodeLinks(map_ids, nodelinkseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceLoad.loadMapLinks(map_ids, linkseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ret = MapdbInterfaceLoad.loadMapPaths(map_ids, pathseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int GetJMap(
			AccessIdentity_Transferable accessIdentity,
			String map_id,
			ImageResourceSeq_TransferableHolder imageseq,
			ISMMapContextSeq_TransferableHolder mapseq,
			MapKISElementSeq_TransferableHolder kisseq,
			MapPhysicalNodeElementSeq_TransferableHolder nodeseq,
			MapNodeLinkElementSeq_TransferableHolder nodelinkseq,
			MapPhysicalLinkElementSeq_TransferableHolder linkseq,
			MapPathElementSeq_TransferableHolder pathseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		Vector map_ids = new Vector();
		map_ids.add(map_id);
		Vector img_ids = new Vector();

		imageseq.value = new ImageResource_Transferable[0];
		mapseq.value = new ISMMapContext_Transferable[0];
		kisseq.value = new MapKISElement_Transferable[0];
		nodeseq.value = new MapPhysicalNodeElement_Transferable[0];
		nodelinkseq.value = new MapNodeLinkElement_Transferable[0];
		linkseq.value = new MapPhysicalLinkElement_Transferable[0];
		pathseq.value = new MapPathElement_Transferable[0];

		ret = MapdbInterfaceLoad.loadJMaps(map_ids, mapseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		int ind = map_ids.indexOf(map_id);
		map_ids.clear();
		map_ids.add(map_id);
		ISMMapContext_Transferable mc_t = mapseq.value[ind];
		mapseq.value = new ISMMapContext_Transferable[1];
		mapseq.value[0] = mc_t;

		ret = MapdbInterfaceLoad.loadJMapKISs(map_ids, kisseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceLoad.loadJMapNodes(map_ids, nodeseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceLoad.loadJMapNodeLinks(map_ids, nodelinkseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceLoad.loadJMapLinks(map_ids, linkseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceLoad.loadJMapPaths(map_ids, pathseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ResourcedbInterface.loadImages(imageseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int SaveMaps(
			AccessIdentity_Transferable accessIdentity,
			ImageResource_Transferable[] imageseq,
			MapContext_Transferable[] mapseq,
			MapElement_Transferable[] equipmentseq,
			MapElement_Transferable[] kisseq,
			MapMarkElement_Transferable[] markseq,
			MapPhysicalNodeElement_Transferable[] nodeseq,
			MapNodeLinkElement_Transferable[] nodelinkseq,
			MapPhysicalLinkElement_Transferable[] linkseq,
			MapPathElement_Transferable[] pathseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ret = ResourcedbInterface.saveImages(imageseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceSave.saveMaps(mapseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceSave.saveMapElements(equipmentseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ret = MapdbInterfaceSave.saveMapKISs(kisseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ret = MapdbInterfaceSave.saveMapMarks(markseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceSave.saveMapNodes(nodeseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceSave.saveMapNodeLinks(nodelinkseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceSave.saveMapLinks(linkseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ret = MapdbInterfaceSave.saveMapPaths(pathseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		return Constants.ERROR_NO_ERROR;
	}

	static int SaveJMaps(
			AccessIdentity_Transferable accessIdentity,
			ImageResource_Transferable[] imageseq,
			ISMMapContext_Transferable[] mapseq,
			MapKISElement_Transferable[] kisseq,
			MapPhysicalNodeElement_Transferable[] nodeseq,
			MapNodeLinkElement_Transferable[] nodelinkseq,
			MapPhysicalLinkElement_Transferable[] linkseq,
			MapPathElement_Transferable[] pathseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ret = ResourcedbInterface.saveImages(imageseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceSave.saveJMaps(mapseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceSave.saveJMapKISs(kisseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceSave.saveJMapNodes(nodeseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceSave.saveJMapNodeLinks(nodelinkseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceSave.saveJMapLinks(linkseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceSave.saveJMapPaths(pathseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int GetMapProtoElements(
			AccessIdentity_Transferable accessIdentity,
			ImageResourceSeq_TransferableHolder imageseq,
			MapProtoGroupSeq_TransferableHolder groupseq,
			MapProtoElementSeq_TransferableHolder protoseq,
			MapLinkProtoElementSeq_TransferableHolder linkseq,
			MapPathProtoElementSeq_TransferableHolder pathseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		Vector img_ids = new Vector();

		imageseq.value = new ImageResource_Transferable[0];
		groupseq.value = new MapProtoGroup_Transferable[0];
		protoseq.value = new MapProtoElement_Transferable[0];
		linkseq.value = new MapLinkProtoElement_Transferable[0];
		pathseq.value = new MapPathProtoElement_Transferable[0];

		ret = MapdbInterfaceProto.loadProtoGroups(accessIdentity.domain_id, groupseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceProto.loadProtoElements(accessIdentity.domain_id, protoseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceProto.loadLinkProto(accessIdentity.domain_id, linkseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceProto.loadPathProto(accessIdentity.domain_id, pathseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ResourcedbInterface.loadImages(imageseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int GetStatedMapProtoElements(
			AccessIdentity_Transferable accessIdentity,
			String[] group_ids,
			String[] element_ids,
			String[] link_ids,
			String[] path_ids,
			ImageResourceSeq_TransferableHolder imageseq,
			MapProtoGroupSeq_TransferableHolder groupseq,
			MapProtoElementSeq_TransferableHolder protoseq,
			MapLinkProtoElementSeq_TransferableHolder linkseq,
			MapPathProtoElementSeq_TransferableHolder pathseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		Vector img_ids = new Vector();

		imageseq.value = new ImageResource_Transferable[0];
		groupseq.value = new MapProtoGroup_Transferable[0];
		protoseq.value = new MapProtoElement_Transferable[0];
		linkseq.value = new MapLinkProtoElement_Transferable[0];
		pathseq.value = new MapPathProtoElement_Transferable[0];

		ret = MapdbInterfaceProto.loadProtoGroups(accessIdentity.domain_id, group_ids, groupseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceProto.loadProtoElements(accessIdentity.domain_id, element_ids, protoseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceProto.loadLinkProto(accessIdentity.domain_id, link_ids, linkseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceProto.loadPathProto(accessIdentity.domain_id, path_ids, pathseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ResourcedbInterface.loadImages(imageseq, img_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}


	static int SaveMapProtoElements(
			AccessIdentity_Transferable accessIdentity,
			ImageResource_Transferable[] images,
			MapProtoGroup_Transferable[] groups,
			MapProtoElement_Transferable[] protos)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;
		ret = ResourcedbInterface.saveImages(images);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceProto.saveProtoGroups(accessIdentity.domain_id, groups);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceProto.saveProtoElements(accessIdentity.domain_id, protos);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int RemoveMapProtoElements(
			AccessIdentity_Transferable accessIdentity,
			String[] group_ids,
			String[] proto_ids)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;
		ret = MapdbInterfaceProto.removeProtoGroups(group_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceProto.removeProtoElements(proto_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int GetSchemeProtoElements(
			AccessIdentity_Transferable accessIdentity,
			ImageResourceSeq_TransferableHolder imageseq,
			SchemeProtoElementSeq_TransferableHolder elementseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		Vector img_ids = new Vector();

		imageseq.value = new ImageResource_Transferable[0];
		elementseq.value = new SchemeProtoElement_Transferable[0];

		SchemedbInterfaceProtoLoad.getProtoElements(accessIdentity.domain_id, elementseq);
		return Constants.ERROR_NO_ERROR;
	}

	static int GetStatedSchemeProtoElements(
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			ImageResourceSeq_TransferableHolder imageseq,
			SchemeProtoElementSeq_TransferableHolder elementseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		Vector img_ids = new Vector();

		imageseq.value = new ImageResource_Transferable[0];
		elementseq.value = new SchemeProtoElement_Transferable[0];

		SchemedbInterfaceProtoLoad.getProtoElements(accessIdentity.domain_id, ids, elementseq);
		return Constants.ERROR_NO_ERROR;
	}

	static int SaveSchemeProtoElements(
			AccessIdentity_Transferable accessIdentity,
			ImageResource_Transferable[] images,
			SchemeProtoElement_Transferable[] elementseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ret = ResourcedbInterface.saveImages(images);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = SchemedbInterfaceProtoSave.saveProtoElements(accessIdentity.domain_id, elementseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int RemoveSchemeProtoElements(
			AccessIdentity_Transferable accessIdentity,
			String[] element_ids)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ret = SchemedbInterfaceProtoSave.removeProtoElements(element_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int GetSchemes(
			AccessIdentity_Transferable accessIdentity,
			ImageResourceSeq_TransferableHolder imageseq,
			SchemeSeq_TransferableHolder elementseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		Vector img_ids = new Vector();

		imageseq.value = new ImageResource_Transferable[0];
		elementseq.value = new Scheme_Transferable[0];

		SchemedbInterfaceLoad.getSchemes(accessIdentity.domain_id, elementseq);
		return Constants.ERROR_NO_ERROR;
	}

	static int GetStatedSchemes(
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			ImageResourceSeq_TransferableHolder imageseq,
			SchemeSeq_TransferableHolder elementseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		Vector img_ids = new Vector();

		imageseq.value = new ImageResource_Transferable[0];
		elementseq.value = new Scheme_Transferable[0];

		SchemedbInterfaceLoad.getSchemes(accessIdentity.domain_id, ids, elementseq);
		return Constants.ERROR_NO_ERROR;
	}

	static int SaveSchemes(
			AccessIdentity_Transferable accessIdentity,
			ImageResource_Transferable[] images,
			Scheme_Transferable[] elementseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ret = ResourcedbInterface.saveImages(images);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = SchemedbInterfaceSave.saveSchemes(accessIdentity.domain_id, elementseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int RemoveSchemes(
			AccessIdentity_Transferable accessIdentity,
			String[] scheme_ids,
			String[] scheme_path_ids,
			String[] scheme_cable_link_ids,
			String[] scheme_element_ids)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ret = SchemedbInterfaceSave.removeCableLinks(scheme_cable_link_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = SchemedbInterfaceSave.removeSchemeElements(scheme_element_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = SchemedbInterfaceSave.removeSchemes(scheme_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int RemoveMaps(
			AccessIdentity_Transferable accessIdentity,
			String[] mapseq,
			String[] equipmentseq,
			String[] kisseq,
			String[] markseq,
			String[] nodeseq,
			String[] nodelinkseq,
			String[] linkseq,
			String[] pathseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ret = MapdbInterfaceRemove.removeMaps(mapseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceRemove.removeElements(equipmentseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceRemove.removeKISs(kisseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceRemove.removeMarks(markseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceRemove.removeNodes(nodeseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceRemove.removeNodeLinks(nodelinkseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceRemove.removeLinks(linkseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceRemove.removePaths(pathseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int RemoveJMaps(
			AccessIdentity_Transferable accessIdentity,
			String[] mapseq,
			String[] kisseq,
			String[] nodeseq,
			String[] nodelinkseq,
			String[] linkseq,
			String[] pathseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ret = MapdbInterfaceRemove.removeJMaps(mapseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceRemove.removeKISs(kisseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceRemove.removeNodes(nodeseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceRemove.removeNodeLinks(nodelinkseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceRemove.removeLinks(linkseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = MapdbInterfaceRemove.removePaths(pathseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return Constants.ERROR_NO_ERROR;
	}

	static int LoadAttributeTypes(
			AccessIdentity_Transferable accessIdentity,
			ElementAttributeTypeSeq_TransferableHolder attrseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ret = MapdbInterfaceLoad.loadAttributeTypes(attrseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static int LoadStatedAttributeTypes(
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			ElementAttributeTypeSeq_TransferableHolder attrseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ret = MapdbInterfaceLoad.loadAttributeTypes(ids, attrseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static int ReloadAttributes(
			AccessIdentity_Transferable accessIdentity,
			String[] map_ids,
			ElementAttributeSeq_TransferableHolder attrseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		attrseq.value = new ElementAttribute_Transferable[0];

		Vector vector = new Vector();
		ret = MapdbInterfaceLoad.reloadAttributes(map_ids, vector);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ElementAttribute_Transferable[] attributes = new ElementAttribute_Transferable[vector.size()];
		vector.copyInto(attributes);
		attrseq.value = attributes;

		return ret;
	}

	static int ReloadISMAttributes(
			AccessIdentity_Transferable accessIdentity,
			String[] ism_map_ids,
			ElementAttributeSeq_TransferableHolder attrseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		attrseq.value = new ElementAttribute_Transferable[0];

		Vector vector = new Vector();
		ret = MapdbInterfaceLoad.reloadISMAttributes(ism_map_ids, vector);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ElementAttribute_Transferable[] attributes = new ElementAttribute_Transferable[vector.size()];
		vector.copyInto(attributes);
		attrseq.value = attributes;

		return ret;
	}

	static int GetAlarms(
			AccessIdentity_Transferable accessIdentity,
			AlarmSeq_TransferableHolder alarmseq,
			EventSourceSeq_TransferableHolder eventsourceseq,
			EventSeq_TransferableHolder eventseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		alarmseq.value = new Alarm_Transferable[0];
		eventsourceseq.value = new EventSource_Transferable[0];
		eventseq.value = new Event_Transferable[0];

		Hashtable ht = new Hashtable();
		Hashtable ht2 = new Hashtable();

		Alarm[] alarms;
		EventSource src;
		Event evt;
		try
		{
			alarms = Alarm.retrieveAlarms(accessIdentity.domain_id);
			alarmseq.value = new Alarm_Transferable[alarms.length];
			String mesg = "retrieve alarms for domain '" + accessIdentity.domain_id + "' - " + alarms.length + " found ";
			System.out.println(mesg);
			for(int i = 0; i < alarms.length; i++)
			{
				alarmseq.value[i] = alarms[i].getTransferable();
				evt = new Event(alarms[i].getEventId());
				src = new EventSource(evt.getSourceId());
				ht.put(evt.getSourceId(), src.getTransferable());
				ht2.put(alarms[i].getEventId(), evt.getTransferable());
			}
			eventsourceseq.value = new EventSource_Transferable[ht.size()];
			int i = 0;
			for(Enumeration enum = ht.elements(); enum.hasMoreElements();)
				eventsourceseq.value[i++] = (EventSource_Transferable )enum.nextElement();

			eventseq.value = new Event_Transferable[ht2.size()];
			i = 0;
			for(Enumeration enum = ht2.elements(); enum.hasMoreElements();)
				eventseq.value[i++] = (Event_Transferable )enum.nextElement();
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить тесты: " + ex.getMessage());
		}
		return ret;
	}

	static int GetStatedAlarms(
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			AlarmSeq_TransferableHolder alarmseq,
			EventSourceSeq_TransferableHolder eventsourceseq,
			EventSeq_TransferableHolder eventseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		alarmseq.value = new Alarm_Transferable[0];
		eventsourceseq.value = new EventSource_Transferable[0];
		eventseq.value = new Event_Transferable[0];

		Vector alarms = new Vector();
		Hashtable ht = new Hashtable();
		Hashtable ht2 = new Hashtable();

		Alarm alarm;
		EventSource src;
		Event evt;
		try
		{
			for(int i = 0; i < ids.length; i++)
			{
				alarm = new Alarm(ids[i]);
				if(alarm != null)
				{
					alarms.add(alarm.getTransferable());

					evt = new Event(alarm.getEventId());
					src = new EventSource(evt.getSourceId());
					ht.put(evt.getSourceId(), src.getTransferable());
					ht2.put(alarm.getEventId(), evt.getTransferable());
				}
			}

			alarmseq.value = new Alarm_Transferable[alarms.size()];
			alarms.copyInto(alarmseq.value);

			eventsourceseq.value = new EventSource_Transferable[ht.size()];
			int i = 0;
			for(Enumeration enum = ht.elements(); enum.hasMoreElements();)
				eventsourceseq.value[i++] = (EventSource_Transferable )enum.nextElement();

			eventseq.value = new Event_Transferable[ht2.size()];
			i = 0;
			for(Enumeration enum = ht2.elements(); enum.hasMoreElements();)
				eventseq.value[i++] = (Event_Transferable )enum.nextElement();
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить тесты: " + ex.getMessage());
		}
		return ret;
	}

	static int GetStatedAlarmsFiltered(
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			Filter_Transferable filter,
			AlarmSeq_TransferableHolder alarmseq,
			EventSourceSeq_TransferableHolder eventsourceseq,
			EventSeq_TransferableHolder eventseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		alarmseq.value = new Alarm_Transferable[0];
		eventsourceseq.value = new EventSource_Transferable[0];
		eventseq.value = new Event_Transferable[0];

		Vector nf_alarms = new Vector();

		Vector alarms = new Vector();
		Hashtable ht = new Hashtable();
		Hashtable ht2 = new Hashtable();

		Alarm alarm;
		EventSource src;
		Event evt;
		try
		{
			for(int i = 0; i < ids.length; i++)
			{
				alarm = new Alarm(ids[i]);
				if(alarm != null)
				{
					nf_alarms.add(alarm);
				}
			}

			LogicSchemeBase ls = new LogicSchemeBase(new AlarmFilter());

			try
			{
				ByteArrayInputStream bis = new ByteArrayInputStream(filter.logic_scheme);
				ObjectInputStream in = new ObjectInputStream(bis);
				ls.readObject(in);
			}
			catch(Exception ex)
			{
				System.out.println("cannot read logic");
			}

			Vector res = new Vector();

			for(int i = 0; i < nf_alarms.size(); i++)
			{
				java.lang.Object obj = nf_alarms.get(i);
				if(ls.passesAllConstraints(obj))
					res.add(obj);
			}
			nf_alarms = res;

			for(int i = 0; i < nf_alarms.size(); i++)
			{
				alarm = (Alarm )nf_alarms.get(i);
				if(alarm != null)
				{
					alarms.add(alarm.getTransferable());

					evt = new Event(alarm.getEventId());
					src = new EventSource(evt.getSourceId());
					ht.put(evt.getSourceId(), src.getTransferable());
					ht2.put(alarm.getEventId(), evt.getTransferable());
				}
			}

			alarmseq.value = new Alarm_Transferable[alarms.size()];
			alarms.copyInto(alarmseq.value);

			eventsourceseq.value = new EventSource_Transferable[ht.size()];
			int i = 0;
			for(Enumeration enum = ht.elements(); enum.hasMoreElements();)
				eventsourceseq.value[i++] = (EventSource_Transferable )enum.nextElement();

			eventseq.value = new Event_Transferable[ht2.size()];
			i = 0;
			for(Enumeration enum = ht2.elements(); enum.hasMoreElements();)
				eventseq.value[i++] = (Event_Transferable )enum.nextElement();
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить тесты: " + ex.getMessage());
		}
		return ret;
	}

	static int GetMessages(AccessIdentity_Transferable accessIdentity, MessageSeq_TransferableHolder messageseq) throws AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
		messageseq.value = new Message_Transferable[0];
		return Constants.ERROR_NO_ERROR;
	}

	static int SetAlarm(
			AccessIdentity_Transferable accessIdentity,
			Alarm_Transferable alarm)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		try
		{
			Alarm a = new Alarm(alarm.id);
			if(alarm.status.value() == AlarmStatus._ALARM_STATUS_ASSIGNED)
				a.assignTo(alarm.assigned_to);
			if(alarm.status.value() == AlarmStatus._ALARM_STATUS_FIXED)
				a.setFixed(alarm.fixed_by);
			a.setComments(alarm.comments);
			if(alarm.status.value() == AlarmStatus._ALARM_STATUS_DELETED)
				DeleteAlarm(accessIdentity, alarm.id);
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_DELETING, "Невозможно удалить сигнал тревоги: " + ex.getMessage());
		}
		return Constants.ERROR_NO_ERROR;
	}

	static int DeleteAlarm(
			AccessIdentity_Transferable accessIdentity,
			String alarm_id)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		try
		{
			Alarm alarm = new Alarm(alarm_id);
			alarm.delete();
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_DELETING, "Невозможно удалить сигнал тревоги: " + ex.getMessage());
		}
		return Constants.ERROR_NO_ERROR;
	}

	static int GetAlarmIdsForMonitoredElement(AccessIdentity_Transferable accessIdentity, String me_id, ResourceDescriptorSeq_TransferableHolder alarmids) throws AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
		return MaintenancedbInterface.getAlarmIdsForMonitoredElement(me_id, alarmids);
	}

	static int LoadMaintenanceData(AccessIdentity_Transferable accessIdentity, EventSourceTypeSeq_TransferableHolder est, AlertingMessageSeq_TransferableHolder am, AlertingMessageUserSeq_TransferableHolder amu) throws AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
		Vector vec = MaintenancedbInterface.getEventSourceTypes();
		est.value = new EventSourceType_Transferable[vec.size()];
		vec.copyInto(est.value);
		vec = MaintenancedbInterface.getAlertingMessages();
		am.value = new AlertingMessage_Transferable[vec.size()];
		vec.copyInto(am.value);
		vec = MaintenancedbInterface.getAlertingMessageUsers();
		amu.value = new AlertingMessageUser_Transferable[vec.size()];
		vec.copyInto(amu.value);
		return Constants.ERROR_NO_ERROR;
	}

	static int SaveMaintenanceData(
			AccessIdentity_Transferable accessIdentity,
			AlertingMessage_Transferable []am,
			AlertingMessageUser_Transferable []amu)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
		for(int i = 0; i < am.length; i++)
			MaintenancedbInterface.saveAlertingMessages(am[i]);
		for(int i = 0; i < amu.length; i++)
			MaintenancedbInterface.saveAlertingMessageUsers(amu[i]);
		return Constants.ERROR_NO_ERROR;
	}

	static int RemoveMaintenanceData(
			AccessIdentity_Transferable accessIdentity,
			String amu_id)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
		MaintenancedbInterface.removeAlertingMessageUser(amu_id);
		return Constants.ERROR_NO_ERROR;
	}

	static int GetUId(
			AccessIdentity_Transferable accessIdentity,
			String type,
			StringHolder id)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		try
		{
			id.value = ResourcedbInterface.getUId(type);
			return Constants.ERROR_NO_ERROR;
		}
		catch(Exception e)
		{
			id.value = "";
			return Constants.ERROR_UID;
		}
	}

	static int GetResourceDescriptors(
			AccessIdentity_Transferable accessIdentity,
			String type,
			ResourceDescriptorSeq_TransferableHolder desc)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		Vector vec = getResourceDescriptors(type);
		desc.value = new ResourceDescriptor_Transferable[vec.size()];
		vec.copyInto(desc.value);
		return Constants.ERROR_NO_ERROR;
	}

	private static Vector getResourceDescriptors(String type) {
		Vector vec = new Vector();

		String id_s = null;
		String where_s = null;

		String It_id = "";
		long It_modified = 0;
		ResourceIdIterator rdIt = null;

		for (int i = 0; i < ResourcedbInterface.DESC_IDS.length; i += 3)
			if (ResourcedbInterface.DESC_IDS[i].equals(type)) {
				id_s = ResourcedbInterface.DESC_IDS[i + 1];
				where_s = ResourcedbInterface.DESC_IDS[i + 2];
				break;
			}

		if (id_s == null) {
			System.out.println("DESC: unknown type - " + type);
			return vec;
		}

		String query = "select ID, MODIFIED from AMFICOM." + id_s + where_s;


		try {
			#sql {
				BEGIN
					open :OUT rdIt for :query;
				END;
			};
			while (rdIt.next()) {
				It_id = rdIt.id();
				try {
					It_modified = rdIt.modified().getTime();
				} catch (Exception e) {
					System.out.println("CHECK! error fetchig MODIFIED for " + It_id + " from " + id_s);
					It_modified = System.currentTimeMillis();
				}
				vec.add(new ResourceDescriptor_Transferable(It_id, It_modified));
			}
			rdIt.close();
		} catch (Exception e) {
			if (rdIt != null)
				try {
					rdIt.close();
				} catch (SQLException sqle) {
					;
				}
			System.out.println("getResourceDescriptors: " + e.getMessage());
			System.out.println("                    at: " + query);
			return new Vector();
		}
		return vec;
	}

	static int GetResourceDescriptor(
			AccessIdentity_Transferable accessIdentity,
			String type,
			String id,
			ResourceDescriptor_TransferableHolder desc)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		desc.value = getResourceDescriptor(type, id);
		if(desc.value == null)
			throw new AMFICOMRemoteException(0, "Нельзя загрузить дескриптор ресурса: " + type + " " + id);
		return Constants.ERROR_NO_ERROR;
	}

	private static ResourceDescriptor_Transferable getResourceDescriptor(String type, String id) {
		String id_s = null;
		String where_s = null;

		String It_id = "";
		long It_modified = 0;
		ResourceIdIterator rdIt = null;

		for (int i = 0; i < ResourcedbInterface.DESC_IDS.length; i += 3)
			if (ResourcedbInterface.DESC_IDS[i].equals(type)) {
				id_s = ResourcedbInterface.DESC_IDS[i + 1];
				where_s = ResourcedbInterface.DESC_IDS[i + 2];
				break;
			}

		if (id_s == null) {
			System.out.println("DESC: unknown type - " + type);
			if (type.equals("result")) {
				ResultDescriptorIterator rIt = null;
				String query = "select ID, ELEMENTARY_START_TIME from AMFICOM.RESULTS where ID = '" + id + "'";
				try {
					#sql {
						BEGIN
							open :OUT rIt for :query;
						END;
					};
					if (rIt.next()) {
						It_id = rIt.id();
						try {
							It_modified = rIt.elementary_start_time().getTime();
						} catch (Exception e) {
							System.out.println("CHECK! error fetchig elementary_start_time for " + It_id + " from " + id_s);
							It_modified = System.currentTimeMillis();
						}
						rIt.close();
						return new ResourceDescriptor_Transferable(It_id, It_modified);
					}
					else
						rIt.close();
				} catch (Exception e) {
					if (rIt != null)
						try {
							rIt.close();
						} catch (SQLException sqle) {
							;
						}
					System.out.println("getResourceDescriptor: " + e.getMessage());
					System.out.println("                    at: " + query);
					return null;
				}
			}
			return null;
		}

		String query = "select ID, MODIFIED from AMFICOM." + id_s + where_s;
		if (query.indexOf("where") != -1)
			query += " and ID = '" + id + "'";
		else
			query += " where ID = '" + id + "'";


		try {
			#sql {
				BEGIN
					open :OUT rdIt for :query;
				END;
			};
			if (rdIt.next()) {
				It_id = rdIt.id();
				try {
					It_modified = rdIt.modified().getTime();
				} catch (Exception e) {
					System.out.println("CHECK! error fetchig MODIFIED for " + It_id + " from " + id_s);
					It_modified = System.currentTimeMillis();
				}
				rdIt.close();
				return new ResourceDescriptor_Transferable(It_id, It_modified);
			} else
				rdIt.close();
		} catch (Exception e) {
			if (rdIt != null)
				try {
					rdIt.close();
				} catch (SQLException sqle) {
					;
				}
			System.out.println("getResourceDescriptor: " + e.getMessage());
			System.out.println("                    at: " + query);
			return null;
		}
		return null;
	}

	static int GetResourceDescriptorsByIds(
			AccessIdentity_Transferable accessIdentity,
			String type,
			String[] ids,
			ResourceDescriptorSeq_TransferableHolder desc)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		Vector vec = getResourceDescriptors(type);
		Vector vec3 = new Vector();
		for(int i = 0; i < ids.length; i++)
			vec3.add(ids[i]);
		Vector vec2 = new Vector();
		for(int i = 0; i < vec.size(); i++)
		{
			ResourceDescriptor_Transferable d = (ResourceDescriptor_Transferable )vec.get(i);
			if(vec3.contains(d.resource_id))
				vec2.add(d);
		}
		desc.value = new ResourceDescriptor_Transferable[vec2.size()];
		vec2.copyInto(desc.value);
		return Constants.ERROR_NO_ERROR;
	}

	static int GetResultDescriptorsByIds(
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			ResourceDescriptorSeq_TransferableHolder desc)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;
		desc.value = new ResourceDescriptor_Transferable[0];
		Result res;
		Vector vec = new Vector();
		Vector idsvec = new Vector();
		for(int i = 0; i < ids.length; i++)
		{
			try
			{
				res = new Result(ids[i]);
				if(!idsvec.contains(res.getId()))
				{
					ResourceDescriptor_Transferable d = new ResourceDescriptor_Transferable(res.getId(), res.getElementaryStartTime().getTime());
					vec.add(d);
					idsvec.add(res.getId());
				}
			}
			catch(Exception ex)
			{
			}
		}
		desc.value = new ResourceDescriptor_Transferable[vec.size()];
		vec.copyInto(desc.value);
		return Constants.ERROR_NO_ERROR;
	}

	static int GetDomainResourceDescriptors(AccessIdentity_Transferable accessIdentity, String type, ResourceDescriptorSeq_TransferableHolder resourceDescriptorSeq) throws AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		String id_s = null;
		String where_s = null;

		String It_id = "";
		long It_modified = 0;
		ResourceIdIterator rdIt = null;

		for (int i = 0; i < ResourcedbInterface.DESC_IDS.length; i += 3)
			if (ResourcedbInterface.DESC_IDS[i].equals(type)) {
				id_s = ResourcedbInterface.DESC_IDS[i + 1];
				where_s = ResourcedbInterface.DESC_IDS[i + 2];
				break;
			}

		Collection resourceDescriptors = new LinkedList();
		if (id_s != null) {
			String query = "select ID, MODIFIED from AMFICOM." + id_s + where_s;
	
			if (where_s.indexOf("where") == -1)
				query += " where";
			else
				query += " and";
			query += " DOMAIN_ID = '" + accessIdentity.domain_id + "'";
	
	
			try {
				#sql {
					BEGIN
						open :OUT rdIt for :query;
					END;
				};
				while (rdIt.next()) {
					It_id = rdIt.id();
					try {
						It_modified = rdIt.modified().getTime();
					} catch (Exception e) {
						System.out.println("CHECK! error fetchig MODIFIED for " + It_id + " from " + id_s);
						It_modified = System.currentTimeMillis();
					}
					resourceDescriptors.add(new ResourceDescriptor_Transferable(It_id, It_modified));
				}
				rdIt.close();
			} catch (Exception e) {
				if (rdIt != null)
					try {
						rdIt.close();
					} catch (SQLException sqle) {
						;
					}
					System.out.println("getDomainResourceDescriptors: " + e.getMessage());
					System.out.println("                          at: " + query);
					resourceDescriptors.clear();
			}
		}
		resourceDescriptorSeq.value = (ResourceDescriptor_Transferable[]) (resourceDescriptors.toArray(new ResourceDescriptor_Transferable[resourceDescriptors.size()]));
		return Constants.ERROR_NO_ERROR;
	}

	static int GetResults(
			AccessIdentity_Transferable accessIdentity,
			ClientResultSeq_TransferableHolder resultseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		resultseq.value = new ClientResult_Transferable[0];
		Result res;
		IdIterator idIt = null;
		Vector vec = new Vector();
		try
		{

			#sql idIt = { select ID from AMFICOM.RESULTS };
			while(idIt.next())
			{
				res = new Result(idIt.id());
				vec.add(res.getClientTransferable());
			}
			idIt.close();
			resultseq.value = new ClientResult_Transferable[vec.size()];
			vec.copyInto(resultseq.value);
		}
		catch(Exception ex)
		{
			if(idIt != null) try
			{
			idIt.close();
			}catch(Exception exe) {}
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат: " + ex.getMessage());
		}

		return ret;
	}

	static int GetStatedResults(
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			ClientResultSeq_TransferableHolder resultseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		resultseq.value = new ClientResult_Transferable[0];

		Vector idsvec = new Vector();
		for(int i = 0; i < ids.length; i++)
			idsvec.add(ids[i]);

		Result res;
		IdIterator idIt = null;
		Vector vec = new Vector();
		try
		{

			#sql idIt = { select ID from AMFICOM.RESULTS };
			while(idIt.next())
			{
				if(idsvec.contains(idIt.id()))
				{
					res = new Result(idIt.id());
					vec.add(res.getClientTransferable());
				}
			}
			idIt.close();
			resultseq.value = new ClientResult_Transferable[vec.size()];
			vec.copyInto(resultseq.value);
		}
		catch(Exception ex)
		{
			if(idIt != null) try
			{
			idIt.close();
			}catch(Exception exe) {}
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат: " + ex.getMessage());
		}

		return ret;
	}

	static int GetRequests(
			AccessIdentity_Transferable accessIdentity,
			ClientTestRequestSeq_TransferableHolder treqseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		treqseq.value = new ClientTestRequest_Transferable[0];

		ret = SurveydbInterfaceLoad.loadRequests(accessIdentity.domain_id, treqseq);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static int GetTests(
			AccessIdentity_Transferable accessIdentity,
			ClientTestSeq_TransferableHolder testseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		testseq.value = new ClientTest_Transferable[0];

		Test[] tests;
		try
		{
			tests = Test.retrieveTests(accessIdentity.domain_id);
			testseq.value = new ClientTest_Transferable[tests.length];
			for(int i = 0; i < tests.length; i++)
				testseq.value[i] = tests[i].getClientTransferable();
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить тесты: " + ex.getMessage());
		}
		return ret;
	}

	static int GetStatedTests(
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			ClientTestSeq_TransferableHolder testseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		testseq.value = new ClientTest_Transferable[0];

		Test[] tests;
		Vector vec = new Vector();
		try
		{
			for(int i = 0; i < ids.length; i++)
			{
				Test test = new Test(ids[i]);
				if(test != null)
					vec.add(test.getClientTransferable());
			}
			testseq.value = new ClientTest_Transferable[vec.size()];
			vec.copyInto(testseq.value);
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить тесты: " + ex.getMessage());
		}
		return ret;
	}

	static int GetOneTimeTestIdsInDiapazon(
			AccessIdentity_Transferable accessIdentity,
			long start_time,
			long end_time,
			ResourceDescriptorSeq_TransferableHolder desc)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		Vector vec1 = getResourceDescriptors("testonetime");
		ResourceDescriptor_Transferable[] desc1 = new ResourceDescriptor_Transferable[vec1.size()];
		vec1.copyInto(desc1);

		Vector vec = filterTimeDiapazon(start_time, end_time, desc1);

		desc.value = new ResourceDescriptor_Transferable[vec.size()];
		vec.copyInto(desc.value);
		return Constants.ERROR_NO_ERROR;
	}

	static int GetTestIdsInDiapazon(
			AccessIdentity_Transferable accessIdentity,
			long start_time,
			long end_time,
			ResourceDescriptorSeq_TransferableHolder desc)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		Vector vec1 = getResourceDescriptors("test");
		ResourceDescriptor_Transferable[] desc1 = new ResourceDescriptor_Transferable[vec1.size()];
		vec1.copyInto(desc1);

		Vector vec = filterTimeDiapazon(start_time, end_time, desc1);
		System.out.println("tests in diapazon - " + vec.size());
		vec = filterDomain(vec, accessIdentity.domain_id);
		System.out.println("tests in domain - " + vec.size());

		desc.value = new ResourceDescriptor_Transferable[vec.size()];
		vec.copyInto(desc.value);
		return Constants.ERROR_NO_ERROR;
	}

	static Vector filterDomain(Vector invec, String domain_id)
	{
		Vector vec = new Vector();
		String dom;
		String kis_id;
		ResourceDescriptor_Transferable rd;
		Test test;

		for(int i = 0; i < invec.size(); i++)
		{
			try
			{
				rd = (ResourceDescriptor_Transferable )invec.get(i);
				test = new Test(rd.resource_id);
				kis_id = test.getKISId();
				
				#sql {
					select domain_id into :dom from equipments
					where id = :kis_id
				};
				if(domain_id.equals(dom))
				{
					vec.add(rd);
					System.out.println("Test " + test.getId());
				}
			}
			catch(Exception e)
			{
				e.printStackTrace();
			}
		}
		return vec;
	}

	static Vector filterTimeDiapazon(
			long start_time,
			long end_time,
			ResourceDescriptor_Transferable[] desc1)
		throws AMFICOMRemoteException
	{
		Vector vec = new Vector();

		try
		{
			for(int i = 0; i < desc1.length; i++)
			{
				Test test = new Test(desc1[i].resource_id);
				long st = test.getTransferable().start_time;
				if(test.getTemporalType() == TestTemporalType._TEST_TEMPORAL_TYPE_ONETIME)
				{
					if(st <= end_time && st >= start_time)
					{
						vec.add(desc1[i]);
					}
				}
				else
				if(test.getTemporalType() == TestTemporalType._TEST_TEMPORAL_TYPE_PERIODICAL)
				{
					long et = test.getEndTime().getTime();
					if(st <= end_time && et >= start_time)
					{
						vec.add(desc1[i]);
					}
				}
				else
				if(test.getTemporalType() == TestTemporalType._TEST_TEMPORAL_TYPE_TIMETABLE)
				{
					long et = st;
					long[] ti = test.getTransferable().time_stamps.ti();
					for(int j = 0; j < ti.length; j++)
						if(ti[j] > et)
							et = ti[j];
					if(st <= end_time && et >= start_time)
					{
						vec.add(desc1[i]);
					}
				}
			}

			return vec;
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить тест: " + ex.getMessage());
		}
	}

	static int GetTestIdsForMonitoredElement(
			AccessIdentity_Transferable accessIdentity,
			String me_id,
			ResourceDescriptorSeq_TransferableHolder testids)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;
		return SurveydbInterfaceLoad.getTestIdsForMonitoredElement(me_id, testids);
	}

	static int GetAnalysis(
			AccessIdentity_Transferable accessIdentity,
			ClientAnalysisSeq_TransferableHolder analysisseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		analysisseq.value = new ClientAnalysis_Transferable[0];

		Analysis[] a;
		try
		{
			a = Analysis.retrieveUserAnalysises(accessIdentity.domain_id);
			analysisseq.value = new ClientAnalysis_Transferable[a.length];
			for(int i = 0; i < a.length; i++)
				analysisseq.value[i] = a[i].getClientTransferable();
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить Объекты анализа: " + ex.getMessage());
		}
		return ret;
	}

	static int GetAnalysisIdsForMonitoredElement(
			AccessIdentity_Transferable accessIdentity,
			String me_id,
			ResourceDescriptorSeq_TransferableHolder analysisids)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		analysisids.value = new ResourceDescriptor_Transferable[0];

		Vector vec = new Vector();

		ResourceIdIterator idIt = null;

		try
		{
			#sql idIt = { select ID, MODIFIED from AMFICOM.ANALYSIS
				where MONITORED_ELEMENT_ID = :me_id
				and DELETED IS NULL
				and USER_ID IS NOT NULL
			};
			while(idIt.next())
				vec.add(new ResourceDescriptor_Transferable(idIt.id(), idIt.modified().getTime()));
			idIt.close();

			analysisids.value = new ResourceDescriptor_Transferable[vec.size()];
			vec.copyInto(analysisids.value);
		}
		catch(Exception ex)
		{
			if(idIt != null) try
			{
			idIt.close();
			}catch(Exception exe) {}
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить анализ: " + ex.getMessage());
		}
		return ret;
	}

	static int GetModelings(
			AccessIdentity_Transferable accessIdentity,
			ClientModelingSeq_TransferableHolder modelingseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		modelingseq.value = new ClientModeling_Transferable[0];
		Modeling[] m;
		try
		{
			m = Modeling.retrieveModelings();
			modelingseq.value = new ClientModeling_Transferable[m.length];
			for(int i = 0; i < m.length; i++)
				modelingseq.value[i] = m[i].getClientTransferable();
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить Объекты моделирования " + ex.getMessage());
		}
		return ret;
	}

	static int GetModelingIdsForSchemePath(
			AccessIdentity_Transferable accessIdentity,
			String scheme_path_id,
			ResourceDescriptorSeq_TransferableHolder modelingids)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		modelingids.value = new ResourceDescriptor_Transferable[0];

		Vector vec = new Vector();

		ResourceIdIterator idIt = null;
		try
		{

			#sql idIt = { select ID, MODIFIED from AMFICOM.MODELING
				where SCHEME_PATH_ID = :scheme_path_id
				and DELETED IS NULL
				and USER_ID IS NOT NULL
			};
			while(idIt.next())
				vec.add(new ResourceDescriptor_Transferable(idIt.id(), idIt.modified().getTime()));
			idIt.close();

			modelingids.value = new ResourceDescriptor_Transferable[vec.size()];
			vec.copyInto(modelingids.value);
		}
		catch(Exception ex)
		{
			if(idIt != null) try
			{
			idIt.close();
			}catch(Exception exe) {}
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить модели: " + ex.getMessage());
		}
		return ret;
	}

	static int GetEvaluations(
			AccessIdentity_Transferable accessIdentity,
			ClientEvaluationSeq_TransferableHolder evaluationseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		evaluationseq.value = new ClientEvaluation_Transferable[0];
		Evaluation[] e;
		try
		{
			e = Evaluation.retrieveUserEvaluations(accessIdentity.domain_id);
			evaluationseq.value = new ClientEvaluation_Transferable[e.length];
			for(int i = 0; i < e.length; i++)
				evaluationseq.value[i] = e[i].getClientTransferable();
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить Объекты оценки: " + ex.getMessage());
		}
		return ret;
	}

	static int GetEvaluationIdsForMonitoredElement(
			AccessIdentity_Transferable accessIdentity,
			String me_id,
			ResourceDescriptorSeq_TransferableHolder evaluationids)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		evaluationids.value = new ResourceDescriptor_Transferable[0];

		Vector vec = new Vector();

		ResourceIdIterator idIt = null;
		try
		{

			#sql idIt = { select ID, MODIFIED from AMFICOM.EVALUATIONS
				where MONITORED_ELEMENT_ID = :me_id
				and DELETED IS NULL
				and USER_ID IS NOT NULL
			};
			while(idIt.next())
				vec.add(new ResourceDescriptor_Transferable(idIt.id(), idIt.modified().getTime()));
			idIt.close();

			evaluationids.value = new ResourceDescriptor_Transferable[vec.size()];
			vec.copyInto(evaluationids.value);
		}
		catch(Exception ex)
		{
			if(idIt != null) try
			{
			idIt.close();
			}catch(Exception exe) {}
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить оценку: " + ex.getMessage());
		}
		return ret;
	}

	static int GetRequestTests(
			AccessIdentity_Transferable accessIdentity,
			String request_id,
			ClientTestSeq_TransferableHolder testseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		testseq.value = new ClientTest_Transferable[0];
		Test test;
		Vector vec = new Vector();

		IdIterator idIt = null;
		try
		{

			#sql idIt = { select ID from AMFICOM.TESTS
				where REQUEST_ID = :request_id
				and DELETED IS NULL
			};
			while(idIt.next())
			{
				test = new Test(idIt.id());
				vec.add(test.getTransferable());
			}
			idIt.close();

			testseq.value = new ClientTest_Transferable[vec.size()];
			vec.copyInto(testseq.value);
		}
		catch(Exception ex)
		{
			if(idIt != null) try
			{
			idIt.close();
			}catch(Exception exe) {}
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить тесты: " + ex.getMessage());
		}
		return ret;
	}

	static int QueryResource(
			AccessIdentity_Transferable accessIdentity,
			String parameter_id,
			String kis_id,
			String parameter_type_id)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		String a_id = ResourcedbInterface.getUId("resourcequery");
		try
		{
			#sql { insert into RESOURCEQUERIES(
					ID,
					PARAMETER_ID,
					KIS_ID,
					PARAMETER_TYPE_ID)
				values(
					:a_id,
					:parameter_id,
					:kis_id,
					:parameter_type_id)

			};
		}
		catch (SQLException e)
		{
			System.out.println("id " + a_id + " param " + parameter_id);
			e.printStackTrace();
			return Constants.ERROR_SAVING;
		}
		return Constants.ERROR_NO_ERROR;
	}

	static int RemoveTests(
			AccessIdentity_Transferable accessIdentity,
			String[] testids)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		try
		{
			for(int i = 0; i < testids.length; i++)
				new Test(testids[i]).delete();
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_UPDATING, "Невозможно ИЗМЕНИТЬ тест: " + ex.getMessage());
		}

		return ret;
	}

	static int UpdateTests(
			AccessIdentity_Transferable accessIdentity,
			ClientTest_Transferable[] testseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		try
		{
			for(int i = 0; i < testseq.length; i++)
			try
			{
				new Test(testseq[i]);
			}
			catch(Exception ex)
			{
				new Test(testseq[i].id).update(testseq[i]);
			}

		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_UPDATING, "Невозможно ИЗМЕНИТЬ тест: " + ex.getMessage());
		}
		return ret;
	}

	static int GetLastResult(
			AccessIdentity_Transferable accessIdentity,
			String me_id,
			ClientResult_TransferableHolder result)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		result.value = new ClientResult_Transferable();

		IdIterator idIt = null;

		try
		{
			String test_id = "";
			Timestamp est;
			String max_test_id = "";
			Timestamp max_est = new Timestamp(0);

			String res_id = "";

			#sql idIt = { select ID from AMFICOM.TESTS
					where MONITORED_ELEMENT_ID = :me_id };

			while(idIt.next())
			{
				test_id = idIt.id();

				#sql { select MAX(ELEMENTARY_START_TIME) into :est
					from AMFICOM.RESULTS
					where TEST_ID = :test_id
				};
				if(est.getTime() > max_est.getTime())
				{
					max_est = est;
					max_test_id = test_id;
				}
			}
			idIt.close();

			#sql { select ID into :res_id from AMFICOM.RESULTS
				where TEST_ID = :max_test_id
				and ELEMENTARY_START_TIME = :max_est
			};

			result.value = new Result(res_id).getClientTransferable();
		}
		catch(Exception ex)
		{
			if(idIt != null) try
			{
			idIt.close();
			}catch(Exception exe) {}
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат теста: " + ex.getMessage());
		}

		return ret;
	}

	static int GetTestResults(
			AccessIdentity_Transferable accessIdentity,
			String test_id,
			ClientResultSeq_TransferableHolder results)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		results.value = new ClientResult_Transferable[0];
		Result[] res;
		try
		{
			res = Result.retrieveResults("test", test_id);

			results.value = new ClientResult_Transferable[res.length];
			for(int i = 0; i < res.length; i++)
				results.value[i] = res[i].getClientTransferable();
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат теста: " + ex.getMessage());
		}
		return ret;
	}

	static int GetAnalysisResults(
			AccessIdentity_Transferable accessIdentity,
			String analysis_id,
			ClientResultSeq_TransferableHolder results)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		results.value = new ClientResult_Transferable[0];
		Result[] res;
		try
		{
			res = Result.retrieveResults("analysis", analysis_id);

			results.value = new ClientResult_Transferable[res.length];
			for(int i = 0; i < res.length; i++)
				results.value[i] = res[i].getClientTransferable();
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат анализа: " + ex.getMessage());
		}
		return ret;
	}

	static ClientResult_Transferable[] GetStatisticsAnalysisResults(
			AccessIdentity_Transferable accessIdentity,
			String monitored_element_id,
			long start_time,
			long end_time)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ClientResult_Transferable[] results = new ClientResult_Transferable[0];

		Vector vec = new Vector();
		String me_id;
		Result res;
		IdIterator idIt = null;
		try
		{
			#sql idIt =
			{
				select ID from AMFICOM.RESULTS
				where RESULT_TYPE = 'analysis'
				and ELEMENTARY_START_TIME < :(new Timestamp(end_time))
				and ELEMENTARY_START_TIME > :(new Timestamp(start_time))
				and ANALYSIS_ID in
					( select ID from AMFICOM.ANALYSIS
						where MONITORED_ELEMENT_ID = :monitored_element_id
						and DELETED is null
					)
			};

			while(idIt.next())
			{
				res = new Result(idIt.id());
				vec.add(res.getClientTransferable());
			}
			idIt.close();


			results = new ClientResult_Transferable[vec.size()];
			vec.copyInto(results);
		}
		catch(Exception ex)
		{
			if(idIt != null) try
			{
			idIt.close();
			}catch(Exception exe) {}
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат анализа: " + ex.getMessage());
		}
		return results;
	}

	static ClientResult_Transferable[] GetStatisticsAnalysisResultsByTS(
			AccessIdentity_Transferable accessIdentity,
			String monitored_element_id,
			long start_time,
			long end_time,
			String test_setup_id)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ClientResult_Transferable[] results = new ClientResult_Transferable[0];

		Vector vec = new Vector();
		String me_id;
		Result res;
		IdIterator idIt = null;
		try
		{
			#sql idIt =
			{
				select ID from AMFICOM.RESULTS
				where RESULT_TYPE = 'analysis'
				and ELEMENTARY_START_TIME < :(new Timestamp(end_time))
				and ELEMENTARY_START_TIME > :(new Timestamp(start_time))
				and ANALYSIS_ID in
					( select ID from AMFICOM.ANALYSIS
						where MONITORED_ELEMENT_ID = :monitored_element_id
						and DELETED is null
					)
				and ANALYSIS_ID in
					( select ANALYSIS_ID from AMFICOM.TESTS
						where MONITORED_ELEMENT_ID = :monitored_element_id
						and TEST_SETUP_ID = :test_setup_id
						and ANALYSIS_ID is not null
						and DELETED is null
					)
			};

			while(idIt.next())
			{
				res = new Result(idIt.id());
				vec.add(res.getClientTransferable());
			}
			idIt.close();


			results = new ClientResult_Transferable[vec.size()];
			vec.copyInto(results);
		}
		catch(Exception ex)
		{
			if(idIt != null) try
			{
			idIt.close();
			}catch(Exception exe) {}
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат анализа: " + ex.getMessage());
		}
		return results;
	}

	static int GetModelingResult(
			AccessIdentity_Transferable accessIdentity,
			String modeling_id,
			ClientResult_TransferableHolder result)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		result.value = new ClientResult_Transferable();
		Result[] res;
		try
		{
			res = Result.retrieveResults("modeling", modeling_id);
			if(res.length != 0)
				result.value = res[0].getClientTransferable();
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат моделирования: " + ex.getMessage());
		}
		return ret;
	}

	static int GetEvaluationResults(
			AccessIdentity_Transferable accessIdentity,
			String evaluation_id,
			ClientResultSeq_TransferableHolder results)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		results.value = new ClientResult_Transferable[0];
		Result[] res;
		try
		{
			res = Result.retrieveResults("evaluation", evaluation_id);

			results.value = new ClientResult_Transferable[res.length];
			for(int i = 0; i < res.length; i++)
				results.value[i] = res[i].getClientTransferable();
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат оценки: " + ex.getMessage());
		}
		return ret;
	}

	static int GetLastResultId(
			AccessIdentity_Transferable accessIdentity,
			String me_id,
			ResourceDescriptor_TransferableHolder result)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		result.value = new ResourceDescriptor_Transferable();
		ClientResult_TransferableHolder resulth = new ClientResult_TransferableHolder();
		int ret = GetLastResult(accessIdentity, me_id, resulth);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		result.value = new ResourceDescriptor_Transferable(resulth.value.id, resulth.value.elementary_start_time);
		return ret;
	}

	static int GetTestResultIds(
			AccessIdentity_Transferable accessIdentity,
			String test_id,
			ResourceDescriptorSeq_TransferableHolder results)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		results.value = new ResourceDescriptor_Transferable[0];
		Result[] res;
		try
		{
			res = Result.retrieveResults("test", test_id);

			results.value = new ResourceDescriptor_Transferable[res.length];
			for(int i = 0; i < res.length; i++)
				results.value[i] = new ResourceDescriptor_Transferable(res[i].getId(), res[i].getElementaryStartTime().getTime());
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат теста: " + ex.getMessage());
		}
		return ret;
	}

	static int GetAnalysisResultIds(
			AccessIdentity_Transferable accessIdentity,
			String analysis_id,
			ResourceDescriptorSeq_TransferableHolder results)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		results.value = new ResourceDescriptor_Transferable[0];
		Result[] res;
		try
		{
			res = Result.retrieveResults("analysis", analysis_id);

			results.value = new ResourceDescriptor_Transferable[res.length];
			for(int i = 0; i < res.length; i++)
				results.value[i] = new ResourceDescriptor_Transferable(res[i].getId(), res[i].getElementaryStartTime().getTime());
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат анализа: " + ex.getMessage());
		}
		return ret;
	}

	static int GetModelingResultId(
			AccessIdentity_Transferable accessIdentity,
			String modeling_id,
			ResourceDescriptor_TransferableHolder result)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		result.value = new ResourceDescriptor_Transferable();

		Result[] res;
		try
		{
			res = Result.retrieveResults("modeling", modeling_id);
			if(res.length != 0)
				result.value = new ResourceDescriptor_Transferable(res[0].getId(), res[0].getElementaryStartTime().getTime());
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат моделирования: " + ex.getMessage());
		}
		return ret;
	}

	static int GetEvaluationResultIds(
			AccessIdentity_Transferable accessIdentity,
			String evaluation_id,
			ResourceDescriptorSeq_TransferableHolder results)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;
		results.value = new ResourceDescriptor_Transferable[0];
		Result[] res;
		try
		{
			res = Result.retrieveResults("evaluation", evaluation_id);

			results.value = new ResourceDescriptor_Transferable[res.length];
			for(int i = 0; i < res.length; i++)
				results.value[i] = new ResourceDescriptor_Transferable(res[i].getId(), res[i].getElementaryStartTime().getTime());
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат оценки: " + ex.getMessage());
		}
		return ret;
	}

	static int GetResult(
			AccessIdentity_Transferable accessIdentity,
			String result_id,
			ClientResult_TransferableHolder result)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		try
		{
			result.value = new Result(result_id).getClientTransferable();
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат: " + ex.getMessage());
		}

		return ret;
	}

	static int SaveAnalysis(
			AccessIdentity_Transferable accessIdentity,
			ClientAnalysis_Transferable analysis,
			ClientResult_Transferable result)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;
		try
		{
			new Analysis(analysis);
			new Result(result);
		}
		catch(SQLException sqle)
		{
			sqle.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, "Невозможно сохранить анализ: " + sqle.getMessage());
		}
		catch(Exception e)
		{
			/**
			 * @todo Soon, Arseniy will introduce a separate exception type.
			 */
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, "Невозможно сохранить анализ: " + e.getMessage());
		}
		return ret;
	}

	static int SaveModeling(
			AccessIdentity_Transferable accessIdentity,
			ClientModeling_Transferable modeling,
			ClientResult_Transferable result)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;
		try
		{
			new Modeling(modeling);
			new Result(result);
		}
		catch(SQLException sqle)
		{
			sqle.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, "Невозможно сохранить модель: " + sqle.getMessage());
		}
		catch(Exception e)
		{
			/**
			 * @todo Soon, Arseniy will introduce a separate exception type.
			 */
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, "Невозможно сохранить модель: " + e.getMessage());
		}
		return ret;
	}

	static int SaveEvaluation(
			AccessIdentity_Transferable accessIdentity,
			ClientEvaluation_Transferable evaluation,
			ClientResult_Transferable result)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;
		try
		{
			new Evaluation(evaluation);
			new Result(result);
		}
		catch(SQLException sqle)
		{
			sqle.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, "Невозможно сохранить оценку: " + sqle.getMessage());
		}
		catch(Exception e)
		{
			/**
			 * @todo Soon, Arseniy will introduce a separate exception type.
			 */
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, "Невозможно сохранить оценку: " + e.getMessage());
		}
		return ret;
	}

	static int GetResultSets(
			AccessIdentity_Transferable accessIdentity,
			ResultSetSeq_TransferableHolder resultsets)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
		int ret = Constants.ERROR_NO_ERROR;

		resultsets.value = new ResultSet_Transferable[0];

		ret = ResultSetdbInterface.getResultSets(accessIdentity.domain_id, resultsets);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static int GetStatedResultSets(
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			ResultSetSeq_TransferableHolder resultsets)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
		int ret = Constants.ERROR_NO_ERROR;

		resultsets.value = new ResultSet_Transferable[0];

		ret = ResultSetdbInterface.getResultSets(accessIdentity.domain_id, resultsets, ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static int GetResultSetResultIds(
			AccessIdentity_Transferable accessIdentity,
			String result_set_id,
			ResourceDescriptorSeq_TransferableHolder result_ids)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
		int ret = Constants.ERROR_NO_ERROR;

		result_ids.value = new ResourceDescriptor_Transferable[0];

		ret = ResultSetdbInterface.getResultIds(result_set_id, result_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static int GetResultSetResultMEIds(
			AccessIdentity_Transferable accessIdentity,
			String result_set_id,
			String me_id,
			ResourceDescriptorSeq_TransferableHolder result_ids)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
		int ret = Constants.ERROR_NO_ERROR;

		result_ids.value = new ResourceDescriptor_Transferable[0];

		ret = ResultSetdbInterface.getResultIds(result_set_id, me_id, result_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}


	static int LoadGlobalParameterTypes(
			AccessIdentity_Transferable accessIdentity,
			GlobalParameterTypeSeq_TransferableHolder params)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;
		GlobalParameterType_Transferable[] gp = new GlobalParameterType_Transferable[0];
		ret = SurveydbInterfaceLoad.loadGlobalParameterTypes(params);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static int LoadGlobalParameterTypes(
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			GlobalParameterTypeSeq_TransferableHolder params)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;
		GlobalParameterType_Transferable[] gp = new GlobalParameterType_Transferable[0];
		ret = SurveydbInterfaceLoad.loadGlobalParameterTypes(ids, params);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static int LoadTestTypes(
			AccessIdentity_Transferable accessIdentity,
			TestTypeSeq_TransferableHolder ttypeseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ttypeseq.value = new TestType_Transferable[0];

		TestType[] ttypes;
		try
		{
			ttypes = TestType.retrieveTestTypes();
			ttypeseq.value = new TestType_Transferable[ttypes.length];
			for(int i = 0; i < ttypes.length; i++)
				ttypeseq.value[i] = ttypes[i].getTransferable();
		}
		catch(SQLException e)
		{
			String mesg = "Exception while getting test types: " + e.getMessage();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
		return ret;
	}

	static int LoadTestTypes(
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			TestTypeSeq_TransferableHolder ttypeseq)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ttypeseq.value = new TestType_Transferable[0];

		try
		{
			ttypeseq.value = new TestType_Transferable[ids.length];
			for(int i = 0; i < ids.length; i++)
				ttypeseq.value[i] = new TestType(ids[i]).getTransferable();
		}
		catch(SQLException e)
		{
			String mesg = "Exception while getting test types: " + e.getMessage();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
		return ret;
	}

	static int LoadAnalysisTypes(
			AccessIdentity_Transferable accessIdentity,
			AnalysisTypeSeq_TransferableHolder atypes)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		atypes.value = new AnalysisType_Transferable[0];
		AnalysisType[] at;
		try
		{
			at = AnalysisType.retrieveAnalysisTypes();
			atypes.value = new AnalysisType_Transferable[at.length];
			for(int i = 0; i < at.length; i++)
				atypes.value[i] = at[i].getTransferable();
		}
		catch(SQLException e)
		{
			String mesg = "Exception while getting analysis types: " + e.getMessage();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
		return ret;
	}

	static int LoadAnalysisTypes(
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			AnalysisTypeSeq_TransferableHolder atypes)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		atypes.value = new AnalysisType_Transferable[0];
		try
		{
			atypes.value = new AnalysisType_Transferable[ids.length];
			for(int i = 0; i < ids.length; i++)
				atypes.value[i] = new AnalysisType(ids[i]).getTransferable();
		}
		catch(SQLException e)
		{
			String mesg = "Exception while getting analysis types: " + e.getMessage();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
		return ret;
	}

	static int LoadEvaluationTypes(
			AccessIdentity_Transferable accessIdentity,
			EvaluationTypeSeq_TransferableHolder etypes)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		etypes.value = new EvaluationType_Transferable[0];
		EvaluationType[] et;
		try
		{
			et = EvaluationType.retrieveEvaluationTypes();
			etypes.value = new EvaluationType_Transferable[et.length];
			for(int i = 0; i < et.length; i++)
				etypes.value[i] = et[i].getTransferable();
		}
		catch(SQLException e)
		{
			String mesg = "Exception while getting evaluation types: " + e.getMessage();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
		return ret;
	}

	static int LoadEvaluationTypes(
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			EvaluationTypeSeq_TransferableHolder etypes)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		etypes.value = new EvaluationType_Transferable[0];
		try
		{
			System.out.println("get evaluation " + ids[0]);
			etypes.value = new EvaluationType_Transferable[ids.length];
			for(int i = 0; i < ids.length; i++)
				etypes.value[i] = new EvaluationType(ids[i]).getTransferable();
		}
		catch(SQLException e)
		{
			String mesg = "Exception while getting evaluation types: " + e.getMessage();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
		return ret;
	}

	static int LoadModelingTypes(
			AccessIdentity_Transferable accessIdentity,
			ModelingTypeSeq_TransferableHolder mtypes)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		mtypes.value = new ModelingType_Transferable[0];
		ModelingType[] mt;
		try
		{
			System.out.println("get all modelings");
			mt = ModelingType.retrieveModelingTypes();
			mtypes.value = new ModelingType_Transferable[mt.length];
			for(int i = 0; i < mt.length; i++)
				mtypes.value[i] = mt[i].getTransferable();
		}
		catch(SQLException e)
		{
			String mesg = "Exception while getting modeling types: " + e.getMessage();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
		return ret;
	}

	static int LoadModelingTypes(
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			ModelingTypeSeq_TransferableHolder mtypes)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		mtypes.value = new ModelingType_Transferable[0];
		try
		{
			System.out.println("get modeling " + ids[0]);
			mtypes.value = new ModelingType_Transferable[ids.length];
			for(int i = 0; i < ids.length; i++)
				mtypes.value[i] = new ModelingType(ids[i]).getTransferable();
		}
		catch(SQLException e)
		{
			String mesg = "Exception while getting modeling types: " + e.getMessage();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
		return ret;
	}

	static int LoadCriteriaSets(
			AccessIdentity_Transferable accessIdentity,
			ClientCriteriaSetSeq_TransferableHolder css)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		css.value = new ClientCriteriaSet_Transferable[0];
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static int LoadThresholdSets(
			AccessIdentity_Transferable accessIdentity,
			ClientThresholdSetSeq_TransferableHolder tss)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		tss.value = new ClientThresholdSet_Transferable[0];
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static int LoadEtalons(
			AccessIdentity_Transferable accessIdentity,
			ClientEtalonSeq_TransferableHolder ets)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ets.value = new ClientEtalon_Transferable[0];
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static String createTestSetup(
			AccessIdentity_Transferable accessIdentity,
			TestSetup_Transferable test_setup_t)
		throws AMFICOMRemoteException
	{
		TestSetup ts = null;
		int count;
		try
		{
			#sql { select count(*) into :count from AMFICOM.TESTSETUPS
				where ID = :(test_setup_t.id)
			};
			if(count == 0)
			{
				ts = new TestSetup(test_setup_t);
				return ts.getId();
			}
			else
			{
				ts = new TestSetup(test_setup_t.id);
				ts.update(test_setup_t);
				return test_setup_t.id;
			}
		}
		catch (SQLException e)
		{
			String mesg = "Exception while saving TestSetup '" + test_setup_t.name + "' for test_type_id '" + test_setup_t.test_type_id + "': " + e.getMessage();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
	}

	static String createTestArgumentSet(
			AccessIdentity_Transferable accessIdentity,
			ClientTestArgumentSet_Transferable arg_set_t)
		throws AMFICOMRemoteException
	{
		TestArgumentSet tas = null;
		int count;
		try
		{
			#sql { select count(*) into :count from AMFICOM.TESTARGUMENTSETS
				where ID = :(arg_set_t.id)
			};
			if(count == 0)
			{
				tas = new TestArgumentSet(arg_set_t);
				return tas.getId();
			}
			else
			{
				tas = new TestArgumentSet(arg_set_t.id);
				tas.update(arg_set_t);
				return arg_set_t.id;
			}
		}
		catch (SQLException sqle)
		{
			String mesg = "Exception while saving teas argument set '" + arg_set_t.name + "' for test_type_id '" + arg_set_t.test_type_id + "': " + sqle.getMessage();
			System.out.println(mesg);
			sqle.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
		catch (Exception e)
		{
			/**
			 * @todo Soon, Arseniy will introduce a separate exception type.
			 */
			String mesg = "Exception while saving teas argument set '" + arg_set_t.name + "' for test_type_id '" + arg_set_t.test_type_id + "': " + e.getMessage();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
	}

	static String createCriteriaSet(
			AccessIdentity_Transferable accessIdentity,
			ClientCriteriaSet_Transferable criteria_set_t)
		throws AMFICOMRemoteException
	{
		CriteriaSet cs = null;
		int count;
		try
		{
			#sql { select count(*) into :count from AMFICOM.CRITERIASETS
				where ID = :(criteria_set_t.id)
			};
			if(count == 0)
			{
				cs = new CriteriaSet(criteria_set_t);
				return cs.getId();
			}
			else
			{
				cs = new CriteriaSet(criteria_set_t.id);
				cs.update(criteria_set_t);
				return criteria_set_t.id;
			}
		}
		catch (SQLException sqle)
		{
			String mesg = "Exception while saving criteria set '" + criteria_set_t.name + "' for analysis_type_id '" + criteria_set_t.analysis_type_id + "': " + sqle.getMessage();
			System.out.println(mesg);
			sqle.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
		catch (Exception e)
		{
			/**
			 * @todo Soon, Arseniy will introduce a separate exception type.
			 */
			String mesg = "Exception while saving criteria set '" + criteria_set_t.name + "' for analysis_type_id '" + criteria_set_t.analysis_type_id + "': " + e.getMessage();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
	}

	static String createThresholdSet(
			AccessIdentity_Transferable accessIdentity,
			ClientThresholdSet_Transferable th_set_t)
		throws AMFICOMRemoteException
	{
		ThresholdSet th = null;
		int count;
		try
		{
			#sql { select count(*) into :count from AMFICOM.THRESHOLDSETS
				where ID = :(th_set_t.id)
			};
			if(count == 0)
			{
				th = new ThresholdSet(th_set_t);
				return th.getId();
			}
			else
			{
				th = new ThresholdSet(th_set_t.id);
				th.update(th_set_t);
				return th_set_t.id;
			}
		}
		catch (SQLException sqle)
		{
			String mesg = "Exception while saving Threshold set '" + th_set_t.name + "' for evaluation_type_id '" + th_set_t.evaluation_type_id + "': " + sqle.getMessage();
			System.out.println(mesg);
			sqle.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
		catch (Exception e)
		{
			/**
			 * @todo Soon, Arseniy will introduce a separate exception type.
			 */
			String mesg = "Exception while saving Threshold set '" + th_set_t.name + "' for evaluation_type_id '" + th_set_t.evaluation_type_id + "': " + e.getMessage();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
	}

	static String createEtalon(
			AccessIdentity_Transferable accessIdentity,
			ClientEtalon_Transferable e_t)
		throws AMFICOMRemoteException
	{
		String id = null;
		int count;
		try
		{
			#sql { select count(*) into :count from AMFICOM.ETALONS
				where ID = :(e_t.id)
			};
			if(count == 0)
				id = new Etalon(e_t).getId();
			else
			{
				new Etalon(e_t.id).update(e_t);
				id = e_t.id;
			}
		}
		catch (SQLException sqle)
		{
			String mesg = "Exception while saving Etalon '" + e_t.name + "' : " + sqle.getMessage();
			System.out.println(mesg);
			sqle.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
		catch (Exception e)
		{
			/**
			 * @todo Soon, Arseniy will introduce a separate exception type.
			 */
			String mesg = "Exception while saving Etalon '" + e_t.name + "' : " + e.getMessage();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
		return id;
	}

	static int LoadNetDirectory(
			AccessIdentity_Transferable accessIdentity,
			PortTypeSeq_TransferableHolder porttypes,
			EquipmentTypeSeq_TransferableHolder equipmenttypes,
			LinkTypeSeq_TransferableHolder linktypes,
			TestPortTypeSeq_TransferableHolder tporttypes,
			CharacteristicTypeSeq_TransferableHolder characteristictypes,
			CablePortTypeSeq_TransferableHolder cableporttypes,
			CableLinkTypeSeq_TransferableHolder cablelinktypes)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		Vector port_vec = new Vector();
		Vector equipment_vec = new Vector();
		Vector link_vec = new Vector();

		porttypes.value = new PortType_Transferable[0];
		equipmenttypes.value = new EquipmentType_Transferable[0];
		linktypes.value = new LinkType_Transferable[0];
		tporttypes.value = new TestPortType_Transferable[0];
		characteristictypes.value = new CharacteristicType_Transferable[0];
		cableporttypes.value = new CablePortType_Transferable[0];
		cablelinktypes.value = new CableLinkType_Transferable[0];
		ret = NetDirectorydbInterfaceLoad.loadPortTypes(porttypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceLoad.loadEquipmentTypes(equipmenttypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceLoad.loadLinkTypes(linktypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceLoad.loadTestPortTypes(tporttypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceLoad.loadCharacteristicTypes(characteristictypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceLoad.loadCablePortTypes(cableporttypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceLoad.loadCableTypes(cablelinktypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		return ret;
	}

	static int LoadStatedNetDirectory(
			AccessIdentity_Transferable accessIdentity,
			String[] pt_ids,
			String[] eqt_ids,
			String[] lt_ids,
			String[] cht_ids,
			String[] cpt_ids,
			String[] clt_ids,
			PortTypeSeq_TransferableHolder porttypes,
			EquipmentTypeSeq_TransferableHolder equipmenttypes,
			LinkTypeSeq_TransferableHolder linktypes,
			TestPortTypeSeq_TransferableHolder tporttypes,
			CharacteristicTypeSeq_TransferableHolder characteristictypes,
			CablePortTypeSeq_TransferableHolder cableporttypes,
			CableLinkTypeSeq_TransferableHolder cablelinktypes)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		Vector port_vec = new Vector();
		Vector equipment_vec = new Vector();
		Vector link_vec = new Vector();

		porttypes.value = new PortType_Transferable[0];
		equipmenttypes.value = new EquipmentType_Transferable[0];
		linktypes.value = new LinkType_Transferable[0];
		tporttypes.value = new TestPortType_Transferable[0];
		characteristictypes.value = new CharacteristicType_Transferable[0];
		cableporttypes.value = new CablePortType_Transferable[0];
		cablelinktypes.value = new CableLinkType_Transferable[0];
		ret = NetDirectorydbInterfaceLoad.loadPortTypes(pt_ids, porttypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceLoad.loadEquipmentTypes(eqt_ids, equipmenttypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceLoad.loadLinkTypes(lt_ids, linktypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceLoad.loadCharacteristicTypes(cht_ids, characteristictypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceLoad.loadCablePortTypes(cpt_ids, cableporttypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceLoad.loadCableTypes(clt_ids, cablelinktypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static int LoadISMDirectory(
			AccessIdentity_Transferable accessIdentity,
			EquipmentTypeSeq_TransferableHolder kistypes,
			AccessPortTypeSeq_TransferableHolder aporttypes,
			TransmissionPathTypeSeq_TransferableHolder pathtypes)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		kistypes.value = new EquipmentType_Transferable[0];
		aporttypes.value = new AccessPortType_Transferable[0];
		pathtypes.value = new TransmissionPathType_Transferable[0];
		ret = ISMDirectorydbInterfaceLoad.loadAccessPortTypes(aporttypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ISMDirectorydbInterfaceLoad.loadPathTypes(pathtypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		return ret;
	}

	static int LoadStatedISMDirectory(
			AccessIdentity_Transferable accessIdentity,
			String[] kis_ids,
			String[] aport_ids,
			String[] path_ids,
			EquipmentTypeSeq_TransferableHolder kistypes,
			AccessPortTypeSeq_TransferableHolder aporttypes,
			TransmissionPathTypeSeq_TransferableHolder pathtypes)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		kistypes.value = new EquipmentType_Transferable[0];
		aporttypes.value = new AccessPortType_Transferable[0];
		pathtypes.value = new TransmissionPathType_Transferable[0];
		ret = ISMDirectorydbInterfaceLoad.loadAccessPortTypes(aport_ids, aporttypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ISMDirectorydbInterfaceLoad.loadPathTypes(path_ids, pathtypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static int RemoveNetDirectory(
			AccessIdentity_Transferable accessIdentity,
			String[] pt_ids,
			String[] cpt_ids,
			String[] eqt_ids,
			String[] lt_ids,
			String[] clt_ids)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;
		ret = NetDirectorydbInterfaceRemove.removePortTypes(pt_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceRemove.removeEquipmentTypes(eqt_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceRemove.removeLinkTypes(lt_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceRemove.removeCablePortTypes(cpt_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceRemove.removeCableLinkTypes(clt_ids);
		return ret;
	}

	static int RemoveISMDirectory(
			AccessIdentity_Transferable accessIdentity,
			String[] kst_ids,
			String[] apt_ids,
			String[] tpt_ids)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;
		ret = ISMDirectorydbInterfaceRemove.removeAccessPortTypes(apt_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ISMDirectorydbInterfaceRemove.removeRTUTypes(kst_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ISMDirectorydbInterfaceRemove.removePathTypes(tpt_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static int SaveNetDirectory(
			AccessIdentity_Transferable accessIdentity,
			PortType_Transferable[] porttypes,
			EquipmentType_Transferable[] equipmenttypes,
			LinkType_Transferable[] linktypes,
			TestPortType_Transferable[] tporttypes,
			CharacteristicType_Transferable[] characteristictypes,
			CablePortType_Transferable[] cableporttypes,
			CableLinkType_Transferable[] cablelinktypes)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;
		ret = NetDirectorydbInterfaceSave.savePortTypes(porttypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceSave.saveEquipmentTypes(equipmenttypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceSave.saveLinkTypes(linktypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceSave.saveCharacteristicTypes(characteristictypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceSave.saveCablePortTypes(cableporttypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetDirectorydbInterfaceSave.saveCableLinkTypes(cablelinktypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static int SaveISMDirectory(
			AccessIdentity_Transferable accessIdentity,
			EquipmentType_Transferable[] kistypes,
			AccessPortType_Transferable[] aporttypes,
			TransmissionPathType_Transferable[] pathtypes)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;
		ret = ISMDirectorydbInterfaceSave.saveAccessPortTypes(aporttypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ISMDirectorydbInterfaceSave.saveRTUTypes(kistypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ISMDirectorydbInterfaceSave.savePathTypes(pathtypes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static int LoadNet(
			AccessIdentity_Transferable accessIdentity,
			PortSeq_TransferableHolder ports,
			CablePortSeq_TransferableHolder cports,
			EquipmentSeq_TransferableHolder equipments,
			LinkSeq_TransferableHolder links,
			CableLinkSeq_TransferableHolder clinks,
			TestPortSeq_TransferableHolder testports)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		Vector port_vec = new Vector();
		Vector cport_vec = new Vector();
		Vector testport_vec = new Vector();

		ports.value = new Port_Transferable[0];
		cports.value = new CablePort_Transferable[0];
		equipments.value = new Equipment_Transferable[0];
		links.value = new Link_Transferable[0];
		clinks.value = new CableLink_Transferable[0];
		testports.value = new TestPort_Transferable[0];
		ret = NetdbInterfaceLoad.loadEquipments(accessIdentity.domain_id, equipments, port_vec, cport_vec, testport_vec);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ret = NetdbInterfaceLoad.loadLinks(accessIdentity.domain_id, links);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetdbInterfaceLoad.loadCableLinks(accessIdentity.domain_id, clinks);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ports.value = new Port_Transferable[port_vec.size()];
		port_vec.copyInto(ports.value);
		cports.value = new CablePort_Transferable[cport_vec.size()];
		cport_vec.copyInto(cports.value);
		testports.value = new TestPort_Transferable[testport_vec.size()];
		testport_vec.copyInto(testports.value);

		return ret;
	}

	static int LoadStatedNet(
			AccessIdentity_Transferable accessIdentity,
			String[] p_ids,
			String[] cp_ids,
			String[] eq_ids,
			String[] l_ids,
			String[] cl_ids,
			PortSeq_TransferableHolder ports,
			CablePortSeq_TransferableHolder cports,
			EquipmentSeq_TransferableHolder equipments,
			LinkSeq_TransferableHolder links,
			CableLinkSeq_TransferableHolder clinks,
			TestPortSeq_TransferableHolder testports)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		Vector port_vec = new Vector();
		Vector cport_vec = new Vector();
		Vector testport_vec = new Vector();

		ports.value = new Port_Transferable[0];
		cports.value = new CablePort_Transferable[0];
		equipments.value = new Equipment_Transferable[0];
		links.value = new Link_Transferable[0];
		clinks.value = new CableLink_Transferable[0];
		testports.value = new TestPort_Transferable[0];
		ret = NetdbInterfaceLoad.loadEquipments(accessIdentity.domain_id, eq_ids, equipments, port_vec, cport_vec, testport_vec);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ret = NetdbInterfaceLoad.loadLinks(accessIdentity.domain_id, l_ids, links);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetdbInterfaceLoad.loadCableLinks(accessIdentity.domain_id, cl_ids, clinks);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ports.value = new Port_Transferable[port_vec.size()];
		port_vec.copyInto(ports.value);
		cports.value = new CablePort_Transferable[cport_vec.size()];
		cport_vec.copyInto(cports.value);
		testports.value = new TestPort_Transferable[testport_vec.size()];
		testport_vec.copyInto(testports.value);

		return ret;
	}

	static int LoadISM(
			AccessIdentity_Transferable accessIdentity,
			PortSeq_TransferableHolder ports,
			CablePortSeq_TransferableHolder cports,
			EquipmentSeq_TransferableHolder kiss,
			LinkSeq_TransferableHolder links,
			CableLinkSeq_TransferableHolder clinks,
			MonitoredElementSeq_TransferableHolder mes,
			TransmissionPathSeq_TransferableHolder paths,
			AccessPortSeq_TransferableHolder accessports)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		Vector port_vec = new Vector();
		Vector cport_vec = new Vector();
		Vector accessport_vec = new Vector();

		ports.value = new Port_Transferable[0];
		cports.value = new CablePort_Transferable[0];
		kiss.value = new Equipment_Transferable[0];
		links.value = new Link_Transferable[0];
		clinks.value = new CableLink_Transferable[0];
		mes.value = new MonitoredElement_Transferable[0];
		paths.value = new TransmissionPath_Transferable[0];
		accessports.value = new AccessPort_Transferable[0];
		ret = ISMdbInterfaceLoad.loadKISs(accessIdentity.domain_id, kiss, port_vec, cport_vec, accessport_vec);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ret = ISMdbInterfaceLoad.loadTransmissionPaths(accessIdentity.domain_id, paths);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ret = ISMdbInterfaceLoad.loadMonitoredElements(accessIdentity.domain_id, mes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ports.value = new Port_Transferable[port_vec.size()];
		port_vec.copyInto(ports.value);
		cports.value = new CablePort_Transferable[cport_vec.size()];
		cport_vec.copyInto(cports.value);
		accessports.value = new AccessPort_Transferable[accessport_vec.size()];
		accessport_vec.copyInto(accessports.value);
		return ret;
	}

	static int LoadStatedISM(
			AccessIdentity_Transferable accessIdentity,
			String[] p_ids,
			String[] cp_ids,
			String[] k_ids,
			String[] l_ids,
			String[] cl_ids,
			String[] me_ids,
			String[] t_ids,
			String[] ap_ids,
			PortSeq_TransferableHolder ports,
			CablePortSeq_TransferableHolder cports,
			EquipmentSeq_TransferableHolder kiss,
			LinkSeq_TransferableHolder links,
			CableLinkSeq_TransferableHolder clinks,
			MonitoredElementSeq_TransferableHolder mes,
			TransmissionPathSeq_TransferableHolder paths,
			AccessPortSeq_TransferableHolder accessports)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		Vector port_vec = new Vector();
		Vector cport_vec = new Vector();
		Vector accessport_vec = new Vector();

		ports.value = new Port_Transferable[0];
		cports.value = new CablePort_Transferable[0];
		kiss.value = new Equipment_Transferable[0];
		links.value = new Link_Transferable[0];
		clinks.value = new CableLink_Transferable[0];
		mes.value = new MonitoredElement_Transferable[0];
		paths.value = new TransmissionPath_Transferable[0];
		accessports.value = new AccessPort_Transferable[0];
		ret = ISMdbInterfaceLoad.loadKISs(accessIdentity.domain_id, k_ids, kiss, port_vec, cport_vec, accessport_vec);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ret = ISMdbInterfaceLoad.loadTransmissionPaths(accessIdentity.domain_id, t_ids, paths);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ret = ISMdbInterfaceLoad.loadMonitoredElements(accessIdentity.domain_id, me_ids, mes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;

		ports.value = new Port_Transferable[port_vec.size()];
		port_vec.copyInto(ports.value);
		cports.value = new CablePort_Transferable[cport_vec.size()];
		cport_vec.copyInto(cports.value);
		accessports.value = new AccessPort_Transferable[accessport_vec.size()];
		accessport_vec.copyInto(accessports.value);
		return ret;
	}

	static int SaveNet(
			AccessIdentity_Transferable accessIdentity,
			Port_Transferable[] ports,
			CablePort_Transferable[] cports,
			Equipment_Transferable[] equipments,
			Link_Transferable[] links,
			CableLink_Transferable[] clinks,
			TestPort_Transferable[] testports)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ret = NetdbInterfaceSave.saveEquipments(equipments);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetdbInterfaceSave.savePorts(ports);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetdbInterfaceSave.saveCablePorts(cports);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetdbInterfaceSave.saveTestPorts(testports);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetdbInterfaceSave.saveLinks(links);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetdbInterfaceSave.saveCableLinks(clinks);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static int SaveISM(
			AccessIdentity_Transferable accessIdentity,
			Port_Transferable[] ports,
			CablePort_Transferable[] cports,
			Equipment_Transferable[] kiss,
			Link_Transferable[] links,
			CableLink_Transferable[] clinks,
			MonitoredElement_Transferable[] mes,
			TransmissionPath_Transferable[] paths,
			AccessPort_Transferable[] accessports)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;

		ret = ISMdbInterfaceSave.saveKISs(kiss);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetdbInterfaceSave.savePorts(ports);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetdbInterfaceSave.saveCablePorts(cports);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ISMdbInterfaceSave.saveAccessPorts(accessports);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ISMdbInterfaceSave.saveTransmissionPaths(paths);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ISMdbInterfaceSave.saveMonitoredElements(mes);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static int RemoveNet(
			AccessIdentity_Transferable accessIdentity,
			String[] p_ids,
			String[] cp_ids,
			String[] eq_ids,
			String[] l_ids,
			String[] cl_ids)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;
		ret = NetdbInterfaceRemove.removeLinks(l_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetdbInterfaceRemove.removeCableLinks(cl_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetdbInterfaceRemove.removePorts(p_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetdbInterfaceRemove.removeCablePorts(cp_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = NetdbInterfaceRemove.removeEquipments(eq_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}

	static int RemoveISM(
			AccessIdentity_Transferable accessIdentity,
			String[] p_ids,
			String[] cp_ids,
			String[] ks_ids,
			String[] l_ids,
			String[] cl_ids,
			String[] me_ids,
			String[] t_ids,
			String[] ap_ids)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		int ret = Constants.ERROR_NO_ERROR;
		ret = ISMdbInterfaceRemove.removeAccessPorts(ap_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ISMdbInterfaceRemove.removeTransmissionPaths(t_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		ret = ISMdbInterfaceRemove.removeKISs(ks_ids);
		if(ret != Constants.ERROR_NO_ERROR)
			return ret;
		return ret;
	}


	static String saveReportTemplates(
			AccessIdentity_Transferable accessIdentity,
			ReportTemplate_Transferable[] rts)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
		for(int i = 0; i < rts.length; i++)
		{
			try
			{
				ReportTemplate r = new ReportTemplate(rts[i].id);
				r.update(rts[i]);
			}
			catch(Exception ex)
			{
				System.out.println("report template not found for update - inserting new");
				try
				{
					ReportTemplate r = new ReportTemplate(rts[i]);
				}
				catch(Exception exx)
				{
					System.out.println("ERROR! new report template could newt be created!");
					exx.printStackTrace();
				}
			}
		}
		return "";
	}

	static void getStatedReportTemplates(
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			ReportTemplateSeq_TransferableHolder reportTemplates)
		throws AMFICOMRemoteException
	{
		Vector vec = new Vector();
		for(int i = 0; i < ids.length; i++)
			try
			{
				ReportTemplate rt = new ReportTemplate(ids[i]);
				vec.add(rt.getTransferable());
			}
			catch(Exception ex)
			{
				System.out.println("error retrieving report template " + ids[i] + " - " + ex.getMessage());
				ex.printStackTrace();
			}
		ReportTemplate_Transferable[] rt = new ReportTemplate_Transferable[vec.size()];
		vec.copyInto(rt);

		reportTemplates.value = rt;
	}

	static void removeReportTemplates(
			AccessIdentity_Transferable accessIdentity,
			String[] reportTemplate_ids)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);

		for(int i = 0; i < reportTemplate_ids.length; i++)
			try
			{
				ReportTemplate rt = new ReportTemplate(reportTemplate_ids[i]);
				rt.delete();
			}
			catch(Exception ex)
			{
				System.out.println("error removing report template " + reportTemplate_ids[i] + " - " + ex.getMessage());
				ex.printStackTrace();
			}
	}

   	static String saveSchemeOptimizeInfo(
			AccessIdentity_Transferable accessIdentity,
			SchemeOptimizeInfo_Transferable soi)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
		try
		{
				new SchemeOptimizeInfo(soi);
		}
		catch(Exception ex)
		{
			ex.printStackTrace();
		}

		return "";
	}

	static SchemeOptimizeInfo_Transferable[] getSchemeOptimizeInfo(
			AccessIdentity_Transferable accessIdentity)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
		try
		{
			return SchemeOptimizeInfo.getSOIs();
		}
		catch(Exception ex)
		{
			ex.printStackTrace();
		}
		return new SchemeOptimizeInfo_Transferable[0];
	}

	static void removeSchemeOptimizeInfo(
			AccessIdentity_Transferable accessIdentity,
			String[] soi_ids)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
		try
		{
			for(int i = 0; i < soi_ids.length; i++)
			{
				SchemeOptimizeInfo soi = new SchemeOptimizeInfo(soi_ids[i]);
				soi.delete();
			}
		}
		catch(Exception ex)
		{
			ex.printStackTrace();
		}
	}


	static String saveSchemeMonitoringSolutions(
			AccessIdentity_Transferable accessIdentity,
			SchemeMonitoringSolution_Transferable sol)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
		try
		{
				new SchemeMonitoringSolution(sol);
		}
		catch(Exception ex)
		{
			ex.printStackTrace();
		}

		return "";
	}

	static SchemeMonitoringSolution_Transferable[] getSchemeMonitoringSolutions(
			AccessIdentity_Transferable accessIdentity)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
		try
		{
			return SchemeMonitoringSolution.getSMSs();
		}
		catch(Exception ex)
		{
			ex.printStackTrace();
		}
		return new SchemeMonitoringSolution_Transferable[0];
	}

	static void removeSchemeMonitoringSolutions(
			AccessIdentity_Transferable accessIdentity,
			String[] sol_ids)
		throws AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(accessIdentity);
		try
		{
			for(int i = 0; i < sol_ids.length; i++)
			{
				SchemeMonitoringSolution sol = new SchemeMonitoringSolution(sol_ids[i]);
				sol.delete();
			}
		}
		catch(Exception ex)
		{
			ex.printStackTrace();
		}
	}

	#sql private static final iterator IdIterator(String id);

	#sql public static final iterator ResourceIdIterator(String id, Timestamp modified);

	#sql public static final iterator ResultDescriptorIterator(String id, Timestamp elementary_start_time);
}
