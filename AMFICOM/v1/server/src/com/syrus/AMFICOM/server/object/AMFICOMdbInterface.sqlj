/*
 * $Id: AMFICOMdbInterface.sqlj,v 1.1.2.7 2004/10/18 15:31:41 bass Exp $
 *
 * Copyright © 2004 Syrus Systems.
 * Научно-технический центр.
 * Проект: АМФИКОМ.
 */

package com.syrus.AMFICOM.server.object;

import com.syrus.AMFICOM.CORBA.Admin.*;
import com.syrus.AMFICOM.CORBA.Alarm.*;
import com.syrus.AMFICOM.CORBA.Constants;
import com.syrus.AMFICOM.CORBA.General.*;
import com.syrus.AMFICOM.CORBA.ISM.*;
import com.syrus.AMFICOM.CORBA.ISMDirectory.*;
import com.syrus.AMFICOM.CORBA.Map.*;
import com.syrus.AMFICOM.CORBA.Network.*;
import com.syrus.AMFICOM.CORBA.NetworkDirectory.*;
import com.syrus.AMFICOM.CORBA.Report.*;
import com.syrus.AMFICOM.CORBA.Resource.*;
import com.syrus.AMFICOM.CORBA.Scheme.*;
import com.syrus.AMFICOM.CORBA.Survey.*;
import com.syrus.AMFICOM.filter.LogicSchemeBase;
import com.syrus.AMFICOM.server.*;
import com.syrus.AMFICOM.server.event.*;
import com.syrus.AMFICOM.server.measurement.*;
import java.io.*;
import java.sql.*;
import java.util.*;
import sqlj.runtime.ref.DefaultContext;

/**
 * @version $Revision: 1.1.2.7 $, $Date: 2004/10/18 15:31:41 $
 * @author $Author: bass $
 * @module server_v1
 */
final class AMFICOMdbInterface {
	private AMFICOMdbInterface() {
	}

	static void saveMaps(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ImageResource_Transferable[] imageseq,
			Map_Transferable[] mapseq,
			MapElement_Transferable[] equipmentseq,
			MapElement_Transferable[] kisseq,
			MapMarkElement_Transferable[] markseq,
			MapPhysicalNodeElement_Transferable[] nodeseq,
			MapNodeLinkElement_Transferable[] nodelinkseq,
			MapPhysicalLinkElement_Transferable[] linkseq,
			MapPathElement_Transferable[] pathseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		ResourcedbInterface.setImages(conn, imageseq);
		MapdbInterfaceSave.saveMaps(conn, mapseq);
		MapdbInterfaceSave.saveMapElements(conn, equipmentseq);

		MapdbInterfaceSave.saveMapKISs(conn, kisseq);

		MapdbInterfaceSave.saveMapMarks(conn, markseq);
		MapdbInterfaceSave.saveMapNodes(conn, nodeseq);
		MapdbInterfaceSave.saveMapNodeLinks(conn, nodelinkseq);
		MapdbInterfaceSave.saveMapLinks(conn, linkseq);

		MapdbInterfaceSave.saveMapPaths(conn, pathseq);
	}

	static void getMapProtoElements(final Connection conn, AccessIdentity_Transferable accessIdentity, ImageResourceSeq_TransferableHolder imageResourceSeq, SchemeProtoGroupSeq_TransferableHolder groupseq, MapNodeProtoElementSeq_TransferableHolder protoseq, MapLinkProtoElementSeq_TransferableHolder linkseq, MapPathProtoElementSeq_TransferableHolder pathseq) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		Collection imageResourceIds = new LinkedList();

		MapdbInterfaceProto.loadProtoGroups(conn, accessIdentity.domain_id, groupseq);
		MapdbInterfaceProto.loadProtoElements(conn, accessIdentity.domain_id, protoseq, imageResourceIds);
		MapdbInterfaceProto.loadLinkProto(conn, accessIdentity.domain_id, linkseq);
		MapdbInterfaceProto.loadPathProto(conn, accessIdentity.domain_id, pathseq);

		Collection imageResources = ResourcedbInterface.getImages(conn, imageResourceIds);
		imageResourceSeq.value = (ImageResource_Transferable[]) (imageResources.toArray(new ImageResource_Transferable[imageResources.size()]));
	}

	static void getStatedMapProtoElements(final Connection conn, AccessIdentity_Transferable accessIdentity, String[] group_ids, String[] element_ids, String[] link_ids, String[] path_ids, ImageResourceSeq_TransferableHolder imageResourceSeq, SchemeProtoGroupSeq_TransferableHolder groupseq, MapNodeProtoElementSeq_TransferableHolder protoseq, MapLinkProtoElementSeq_TransferableHolder linkseq, MapPathProtoElementSeq_TransferableHolder pathseq) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		Collection imageResourceIds = new LinkedList();

		MapdbInterfaceProto.loadProtoGroups(conn, accessIdentity.domain_id, group_ids, groupseq);
		MapdbInterfaceProto.loadProtoElements(conn, accessIdentity.domain_id, element_ids, protoseq, imageResourceIds);
		MapdbInterfaceProto.loadLinkProto(conn, accessIdentity.domain_id, link_ids, linkseq);
		MapdbInterfaceProto.loadPathProto(conn, accessIdentity.domain_id, path_ids, pathseq);

		Collection imageResources = ResourcedbInterface.getImages(conn, imageResourceIds);
		imageResourceSeq.value = (ImageResource_Transferable[]) (imageResources.toArray(new ImageResource_Transferable[imageResources.size()]));
	}

	static void saveMapProtoElements(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ImageResource_Transferable[] images,
			SchemeProtoGroup_Transferable[] groups,
			MapNodeProtoElement_Transferable[] protos)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		ResourcedbInterface.setImages(conn, images);
		MapdbInterfaceProto.saveProtoGroups(conn, accessIdentity.domain_id, groups);
		MapdbInterfaceProto.saveProtoElements(conn, accessIdentity.domain_id, protos);
	}

	static void removeMapProtoElements(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] group_ids,
			String[] proto_ids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		MapdbInterfaceProto.removeProtoGroups(conn, group_ids);
		MapdbInterfaceProto.removeProtoElements(conn, proto_ids);
	}

	static void getSchemeProtoElements(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ImageResourceSeq_TransferableHolder imageseq,
			SchemeProtoElementSeq_TransferableHolder elementseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		imageseq.value = new ImageResource_Transferable[0];
		elementseq.value = new SchemeProtoElement_Transferable[0];
		SchemedbInterfaceProtoLoad.getProtoElements(conn, accessIdentity.domain_id, elementseq);
	}

	static void getStatedSchemeProtoElements(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			ImageResourceSeq_TransferableHolder imageseq,
			SchemeProtoElementSeq_TransferableHolder elementseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		imageseq.value = new ImageResource_Transferable[0];
		elementseq.value = new SchemeProtoElement_Transferable[0];
		SchemedbInterfaceProtoLoad.getProtoElements(conn, accessIdentity.domain_id, ids, elementseq);
	}

	static void saveSchemeProtoElements(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ImageResource_Transferable[] images,
			SchemeProtoElement_Transferable[] elementseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		ResourcedbInterface.setImages(conn, images);
		SchemedbInterfaceProtoSave.saveProtoElements(conn, accessIdentity.domain_id, elementseq);
	}

	static void removeSchemeProtoElements(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] element_ids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		SchemedbInterfaceProtoSave.removeProtoElements(conn, element_ids);
	}

	static void getSchemes(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ImageResourceSeq_TransferableHolder imageseq,
			SchemeSeq_TransferableHolder elementseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		imageseq.value = new ImageResource_Transferable[0];
		elementseq.value = new Scheme_Transferable[0];
		SchemedbInterfaceLoad.getSchemes(conn, accessIdentity.domain_id, elementseq);
	}

	static void getStatedSchemes(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			ImageResourceSeq_TransferableHolder imageseq,
			SchemeSeq_TransferableHolder elementseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		imageseq.value = new ImageResource_Transferable[0];
		elementseq.value = new Scheme_Transferable[0];
		SchemedbInterfaceLoad.getSchemes(conn, accessIdentity.domain_id, ids, elementseq);
	}

	static void saveSchemes(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ImageResource_Transferable[] images,
			Scheme_Transferable[] elementseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		ResourcedbInterface.setImages(conn, images);
		SchemedbInterfaceSave.saveSchemes(conn, accessIdentity.domain_id, elementseq);
	}

	static void removeSchemes(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] scheme_ids,
			String[] scheme_path_ids,
			String[] scheme_cable_link_ids,
			String[] scheme_element_ids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		SchemedbInterfaceSave.removeCableLinks(conn, scheme_cable_link_ids);
		SchemedbInterfaceSave.removeSchemeElements(conn, scheme_element_ids);
		SchemedbInterfaceSave.removeSchemes(conn, scheme_ids);
	}

	static void removeMaps(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] mapseq,
			String[] equipmentseq,
			String[] kisseq,
			String[] markseq,
			String[] nodeseq,
			String[] nodelinkseq,
			String[] linkseq,
			String[] pathseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		MapdbInterfaceRemove.removeMaps(conn, mapseq);
		MapdbInterfaceRemove.removeElements(conn, equipmentseq);
		MapdbInterfaceRemove.removeKISs(conn, kisseq);
		MapdbInterfaceRemove.removeMarks(conn, markseq);
		MapdbInterfaceRemove.removeNodes(conn, nodeseq);
		MapdbInterfaceRemove.removeNodeLinks(conn, nodelinkseq);
		MapdbInterfaceRemove.removeLinks(conn, linkseq);
		MapdbInterfaceRemove.removePaths(conn, pathseq);
	}

	static void loadAttributeTypes(final Connection conn, AccessIdentity_Transferable accessIdentity, ElementAttributeTypeSeq_TransferableHolder attrseq) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		MapdbInterfaceLoad.loadAttributeTypes(conn, attrseq);
	}

	static void loadStatedAttributeTypes(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			ElementAttributeTypeSeq_TransferableHolder attrseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		MapdbInterfaceLoad.loadAttributeTypes(conn, ids, attrseq);
	}

	static void reloadAttributes(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] map_ids,
			ElementAttributeSeq_TransferableHolder attrseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		attrseq.value = new ElementAttribute_Transferable[0];

		Vector vector = new Vector();
		MapdbInterfaceLoad.reloadAttributes(conn, map_ids, vector);

		ElementAttribute_Transferable[] attributes = new ElementAttribute_Transferable[vector.size()];
		vector.copyInto(attributes);
		attrseq.value = attributes;
	}

	static void reloadISMAttributes(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] ism_map_ids,
			ElementAttributeSeq_TransferableHolder attrseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		attrseq.value = new ElementAttribute_Transferable[0];

		Vector vector = new Vector();
		MapdbInterfaceLoad.reloadISMAttributes(conn, ism_map_ids, vector);

		ElementAttribute_Transferable[] attributes = new ElementAttribute_Transferable[vector.size()];
		vector.copyInto(attributes);
		attrseq.value = attributes;
	}

	static void getAlarms(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			AlarmSeq_TransferableHolder alarmseq,
			EventSourceSeq_TransferableHolder eventsourceseq,
			EventSeq_TransferableHolder eventseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		alarmseq.value = new Alarm_Transferable[0];
		eventsourceseq.value = new EventSource_Transferable[0];
		eventseq.value = new Event_Transferable[0];

		Hashtable ht = new Hashtable();
		Hashtable ht2 = new Hashtable();

		Alarm[] alarms;
		EventSource src;
		Event evt;
		try
		{
			alarms = Alarm.retrieveAlarms(accessIdentity.domain_id);
			alarmseq.value = new Alarm_Transferable[alarms.length];
			String mesg = "retrieve alarms for domain '" + accessIdentity.domain_id + "' - " + alarms.length + " found ";
			System.out.println(mesg);
			for (int i = 0; i < alarms.length; i++)
			{
				alarmseq.value[i] = alarms[i].getTransferable();
				evt = new Event(alarms[i].getEventId());
				src = new EventSource(evt.getSourceId());
				ht.put(evt.getSourceId(), src.getTransferable());
				ht2.put(alarms[i].getEventId(), evt.getTransferable());
			}
			eventsourceseq.value = new EventSource_Transferable[ht.size()];
			int i = 0;
			for (Enumeration enum = ht.elements(); enum.hasMoreElements();)
				eventsourceseq.value[i++] = (EventSource_Transferable )enum.nextElement();

			eventseq.value = new Event_Transferable[ht2.size()];
			i = 0;
			for (Enumeration enum = ht2.elements(); enum.hasMoreElements();)
				eventseq.value[i++] = (Event_Transferable )enum.nextElement();
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить тесты: " + ex.toString());
		}
	}

	static void getStatedAlarms(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			AlarmSeq_TransferableHolder alarmseq,
			EventSourceSeq_TransferableHolder eventsourceseq,
			EventSeq_TransferableHolder eventseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		alarmseq.value = new Alarm_Transferable[0];
		eventsourceseq.value = new EventSource_Transferable[0];
		eventseq.value = new Event_Transferable[0];

		Vector alarms = new Vector();
		Hashtable ht = new Hashtable();
		Hashtable ht2 = new Hashtable();

		Alarm alarm;
		EventSource src;
		Event evt;
		try
		{
			for (int i = 0; i < ids.length; i++)
			{
				alarm = new Alarm(ids[i]);
				if (alarm != null)
				{
					alarms.add(alarm.getTransferable());

					evt = new Event(alarm.getEventId());
					src = new EventSource(evt.getSourceId());
					ht.put(evt.getSourceId(), src.getTransferable());
					ht2.put(alarm.getEventId(), evt.getTransferable());
				}
			}

			alarmseq.value = new Alarm_Transferable[alarms.size()];
			alarms.copyInto(alarmseq.value);

			eventsourceseq.value = new EventSource_Transferable[ht.size()];
			int i = 0;
			for (Enumeration enum = ht.elements(); enum.hasMoreElements();)
				eventsourceseq.value[i++] = (EventSource_Transferable )enum.nextElement();

			eventseq.value = new Event_Transferable[ht2.size()];
			i = 0;
			for (Enumeration enum = ht2.elements(); enum.hasMoreElements();)
				eventseq.value[i++] = (Event_Transferable )enum.nextElement();
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить тесты: " + ex.toString());
		}
	}

	static void getStatedAlarmsFiltered(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			Filter_Transferable filter,
			AlarmSeq_TransferableHolder alarmseq,
			EventSourceSeq_TransferableHolder eventsourceseq,
			EventSeq_TransferableHolder eventseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		alarmseq.value = new Alarm_Transferable[0];
		eventsourceseq.value = new EventSource_Transferable[0];
		eventseq.value = new Event_Transferable[0];

		Vector nf_alarms = new Vector();

		Vector alarms = new Vector();
		Hashtable ht = new Hashtable();
		Hashtable ht2 = new Hashtable();

		Alarm alarm;
		EventSource src;
		Event evt;
		try
		{
			for (int i = 0; i < ids.length; i++)
			{
				alarm = new Alarm(ids[i]);
				if (alarm != null)
				{
					nf_alarms.add(alarm);
				}
			}

			LogicSchemeBase ls = new LogicSchemeBase(new AlarmFilter());

			try {
				ByteArrayInputStream bis = new ByteArrayInputStream(filter.logic_scheme);
				ObjectInputStream in = new ObjectInputStream(bis);
				ls.readObject(in);
			} catch (Exception e) {
				e.printStackTrace();
			}

			Vector res = new Vector();

			for (int i = 0; i < nf_alarms.size(); i++)
			{
				java.lang.Object obj = nf_alarms.get(i);
				if (ls.passesAllConstraints(obj))
					res.add(obj);
			}
			nf_alarms = res;

			for (int i = 0; i < nf_alarms.size(); i++)
			{
				alarm = (Alarm )nf_alarms.get(i);
				if (alarm != null)
				{
					alarms.add(alarm.getTransferable());

					evt = new Event(alarm.getEventId());
					src = new EventSource(evt.getSourceId());
					ht.put(evt.getSourceId(), src.getTransferable());
					ht2.put(alarm.getEventId(), evt.getTransferable());
				}
			}

			alarmseq.value = new Alarm_Transferable[alarms.size()];
			alarms.copyInto(alarmseq.value);

			eventsourceseq.value = new EventSource_Transferable[ht.size()];
			int i = 0;
			for (Enumeration enum = ht.elements(); enum.hasMoreElements();)
				eventsourceseq.value[i++] = (EventSource_Transferable )enum.nextElement();

			eventseq.value = new Event_Transferable[ht2.size()];
			i = 0;
			for (Enumeration enum = ht2.elements(); enum.hasMoreElements();)
				eventseq.value[i++] = (Event_Transferable )enum.nextElement();
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить тесты: " + ex.toString());
		}
	}

	static void getMessages(final Connection conn, AccessIdentity_Transferable accessIdentity, MessageSeq_TransferableHolder messageseq) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		messageseq.value = new Message_Transferable[0];
	}

	static void setAlarm(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			Alarm_Transferable alarm)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		try
		{
			Alarm a = new Alarm(alarm.id);
			if (alarm.status.value() == AlarmStatus._ALARM_STATUS_ASSIGNED)
				a.assignTo(alarm.assigned_to);
			if (alarm.status.value() == AlarmStatus._ALARM_STATUS_FIXED)
				a.setFixed(alarm.fixed_by);
			a.setComments(alarm.comments);
			if (alarm.status.value() == AlarmStatus._ALARM_STATUS_DELETED)
				deleteAlarm(conn, accessIdentity, alarm.id);
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_DELETING, "Невозможно удалить сигнал тревоги: " + ex.toString());
		}
	}

	static void deleteAlarm(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String alarm_id)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		try
		{
			Alarm alarm = new Alarm(alarm_id);
			alarm.delete();
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_DELETING, "Невозможно удалить сигнал тревоги: " + ex.toString());
		}
	}

	static void getAlarmIdsForMonitoredElement(final Connection conn, AccessIdentity_Transferable accessIdentity, String me_id, ResourceDescriptorSeq_TransferableHolder alarmids) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		MaintenancedbInterface.getAlarmIdsForMonitoredElement(conn, me_id, alarmids);
	}

	static void loadMaintenanceData(final Connection conn, AccessIdentity_Transferable accessIdentity, EventSourceTypeSeq_TransferableHolder est, AlertingMessageSeq_TransferableHolder am, AlertingMessageUserSeq_TransferableHolder amu) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		Vector vec = MaintenancedbInterface.getEventSourceTypes(conn);
		est.value = new EventSourceType_Transferable[vec.size()];
		vec.copyInto(est.value);
		vec = MaintenancedbInterface.getAlertingMessages(conn);
		am.value = new AlertingMessage_Transferable[vec.size()];
		vec.copyInto(am.value);
		vec = MaintenancedbInterface.getAlertingMessageUsers(conn);
		amu.value = new AlertingMessageUser_Transferable[vec.size()];
		vec.copyInto(amu.value);
	}

	static void saveMaintenanceData(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			AlertingMessage_Transferable []am,
			AlertingMessageUser_Transferable []amu)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		for (int i = 0; i < am.length; i++)
			MaintenancedbInterface.saveAlertingMessages(conn, am[i]);
		for (int i = 0; i < amu.length; i++)
			MaintenancedbInterface.saveAlertingMessageUsers(conn, amu[i]);
	}

	static void removeMaintenanceData(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String amu_id)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		MaintenancedbInterface.removeAlertingMessageUser(conn, amu_id);
	}

	static void getResourceDescriptors(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String type,
			ResourceDescriptorSeq_TransferableHolder desc)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);

		Vector vec = getResourceDescriptors(conn, type);
		desc.value = new ResourceDescriptor_Transferable[vec.size()];
		vec.copyInto(desc.value);
	}

	private static Vector getResourceDescriptors(final Connection conn, String type) throws SQLException {
		Vector vec = new Vector();

		String id_s = null;
		String where_s = null;

		String itId = "";
		long itModified = 0;
		ResourceIdIterator rdIt = null;

		for (int i = 0; i < ResourcedbInterface.DESC_IDS.length; i += 3)
			if (ResourcedbInterface.DESC_IDS[i].equals(type)) {
				id_s = ResourcedbInterface.DESC_IDS[i + 1];
				where_s = ResourcedbInterface.DESC_IDS[i + 2];
				break;
			}

		if (id_s == null) {
			System.out.println("DESC: unknown type - " + type);
			return vec;
		}

		try {
			#sql [new DefaultContext(conn)] {
				BEGIN OPEN :OUT rdIt FOR :("SELECT id, modified FROM amficom." + id_s + where_s); END;
			};
			while (rdIt.next()) {
				itId = rdIt.id();
				try {
					itModified = rdIt.modified().getTime();
				} catch (Exception e) {
					e.printStackTrace();
					itModified = System.currentTimeMillis();
				}
				vec.add(new ResourceDescriptor_Transferable(itId, itModified));
			}
		} catch (Exception e) {
			e.printStackTrace();
			return new Vector();
		} finally {
			if (rdIt != null)
				rdIt.close();
		}
		return vec;
	}

	static void getResourceDescriptor(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String type,
			String id,
			ResourceDescriptor_TransferableHolder desc)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);

		desc.value = getResourceDescriptor(conn, type, id);
		if (desc.value == null)
			throw new AMFICOMRemoteException(0, "Нельзя загрузить дескриптор ресурса: " + type + " " + id);
	}

	private static ResourceDescriptor_Transferable getResourceDescriptor(final Connection conn, String type, String id) throws SQLException {
		DefaultContext connCtx = new DefaultContext(conn);

		String id_s = null;
		String where_s = null;

		String itId = "";
		long itModified = 0;
		ResourceIdIterator rdIt = null;

		for (int i = 0; i < ResourcedbInterface.DESC_IDS.length; i += 3)
			if (ResourcedbInterface.DESC_IDS[i].equals(type)) {
				id_s = ResourcedbInterface.DESC_IDS[i + 1];
				where_s = ResourcedbInterface.DESC_IDS[i + 2];
				break;
			}

		if (id_s == null) {
			System.out.println("DESC: unknown type - " + type);
			if (type.equals("result")) {
				ResultDescriptorIterator rIt = null;
				try {
					#sql [connCtx] {
						BEGIN OPEN :OUT rIt FOR :("SELECT id, elementary_start_time FROM amficom.results WHERE id = '" + id + "'"); END;
					};
					if (rIt.next()) {
						itId = rIt.id();
						try {
							itModified = rIt.elementary_start_time().getTime();
						} catch (Exception e) {
							e.printStackTrace();
							itModified = System.currentTimeMillis();
						}
						return new ResourceDescriptor_Transferable(itId, itModified);
					}
				} catch (Exception e) {
					e.printStackTrace();
					return null;
				} finally {
					if (rIt != null)
						rIt.close();
				}
			}
			return null;
		}
		try {
			#sql [connCtx] {
				BEGIN OPEN :OUT rdIt FOR :("SELECT id, modified FROM amficom." + id_s + where_s + " " + ((where_s.indexOf("where") != -1) ? "AND" : "WHERE") + " id = '" + id + "'"); END;
			};
			if (rdIt.next()) {
				itId = rdIt.id();
				try {
					itModified = rdIt.modified().getTime();
				} catch (Exception e) {
					e.printStackTrace();
					itModified = System.currentTimeMillis();
				}
				return new ResourceDescriptor_Transferable(itId, itModified);
			}
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		} finally {
			if (rdIt != null)
				rdIt.close();
		}
		return null;
	}

	static void getResourceDescriptorsByIds(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String type,
			String[] ids,
			ResourceDescriptorSeq_TransferableHolder desc)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);

		Vector vec = getResourceDescriptors(conn, type);
		Vector vec3 = new Vector();
		for (int i = 0; i < ids.length; i++)
			vec3.add(ids[i]);
		Vector vec2 = new Vector();
		for (int i = 0; i < vec.size(); i++)
		{
			ResourceDescriptor_Transferable d = (ResourceDescriptor_Transferable )vec.get(i);
			if (vec3.contains(d.resource_id))
				vec2.add(d);
		}
		desc.value = new ResourceDescriptor_Transferable[vec2.size()];
		vec2.copyInto(desc.value);
	}

	static void getResultDescriptorsByIds(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			ResourceDescriptorSeq_TransferableHolder desc)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		desc.value = new ResourceDescriptor_Transferable[0];
		Result res;
		Vector vec = new Vector();
		Vector idsvec = new Vector();
		for (int i = 0; i < ids.length; i++)
		{
			try
			{
				res = new Result(ids[i]);
				if (!idsvec.contains(res.getId()))
				{
					ResourceDescriptor_Transferable d = new ResourceDescriptor_Transferable(res.getId(), res.getElementaryStartTime().getTime());
					vec.add(d);
					idsvec.add(res.getId());
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		desc.value = new ResourceDescriptor_Transferable[vec.size()];
		vec.copyInto(desc.value);
	}

	static void getDomainResourceDescriptors(final Connection conn, AccessIdentity_Transferable accessIdentity, String type, ResourceDescriptorSeq_TransferableHolder resourceDescriptorSeq) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);

		String id_s = null;
		String where_s = null;

		String itId = "";
		long itModified = 0;
		ResourceIdIterator rdIt = null;

		for (int i = 0; i < ResourcedbInterface.DESC_IDS.length; i += 3)
			if (ResourcedbInterface.DESC_IDS[i].equals(type)) {
				id_s = ResourcedbInterface.DESC_IDS[i + 1];
				where_s = ResourcedbInterface.DESC_IDS[i + 2];
				break;
			}

		Collection resourceDescriptors = new LinkedList();
		if (id_s != null) {
			try {
				#sql [new DefaultContext(conn)] {
					BEGIN OPEN :OUT rdIt FOR :("SELECT id, modified FROM amficom." + id_s + where_s + " " + ((where_s.indexOf("where") == -1) ? "WHERE" : "AND") + " domain_id = '" + accessIdentity.domain_id + "'"); END;
				};
				while (rdIt.next()) {
					itId = rdIt.id();
					try {
						itModified = rdIt.modified().getTime();
					} catch (Exception e) {
						e.printStackTrace();
						itModified = System.currentTimeMillis();
					}
					resourceDescriptors.add(new ResourceDescriptor_Transferable(itId, itModified));
				}
			} catch (Exception e) {
				e.printStackTrace();
				resourceDescriptors.clear();
			} finally {
				if (rdIt != null)
					rdIt.close();
			}
		}
		resourceDescriptorSeq.value = (ResourceDescriptor_Transferable[]) (resourceDescriptors.toArray(new ResourceDescriptor_Transferable[resourceDescriptors.size()]));
	}

	static void getResults(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ClientResultSeq_TransferableHolder resultseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		resultseq.value = new ClientResult_Transferable[0];
		IdIterator idIt = null;
		Vector vec = new Vector();
		try {
			#sql [new DefaultContext(conn)] idIt = {
				SELECT id FROM amficom.results
			};
			while(idIt.next())
				vec.add((new Result(idIt.id())).getClientTransferable());
			resultseq.value = new ClientResult_Transferable[vec.size()];
			vec.copyInto(resultseq.value);
		} catch (Exception e) {
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат: " + e.toString());
		} finally {
			if (idIt != null)
				idIt.close();
		}
	}

	static void getStatedResults(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			ClientResultSeq_TransferableHolder resultseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		resultseq.value = new ClientResult_Transferable[0];

		Vector idsvec = new Vector();
		for (int i = 0; i < ids.length; i++)
			idsvec.add(ids[i]);

		IdIterator idIt = null;
		Vector vec = new Vector();
		try {
			#sql [new DefaultContext(conn)] idIt = {
				SELECT id FROM amficom.results
			};
			while(idIt.next())
				if (idsvec.contains(idIt.id()))
					vec.add((new Result(idIt.id())).getClientTransferable());
			resultseq.value = new ClientResult_Transferable[vec.size()];
			vec.copyInto(resultseq.value);
		} catch (Exception e) {
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат: " + e.toString());
		} finally {
			if (idIt != null)
				idIt.close();
		}
	}

	static void getRequests(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ClientTestRequestSeq_TransferableHolder treqseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		treqseq.value = new ClientTestRequest_Transferable[0];

		SurveydbInterfaceLoad.loadRequests(conn, accessIdentity.domain_id, treqseq);
	}

	static void getTests(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ClientTestSeq_TransferableHolder testseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		testseq.value = new ClientTest_Transferable[0];

		Test[] tests;
		try
		{
			tests = Test.retrieveTests(accessIdentity.domain_id);
			testseq.value = new ClientTest_Transferable[tests.length];
			for (int i = 0; i < tests.length; i++)
				testseq.value[i] = tests[i].getClientTransferable();
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить тесты: " + ex.toString());
		}
	}

	static void getStatedTests(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			ClientTestSeq_TransferableHolder testseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		testseq.value = new ClientTest_Transferable[0];

		Vector vec = new Vector();
		try
		{
			for (int i = 0; i < ids.length; i++)
			{
				Test test = new Test(ids[i]);
				if (test != null)
					vec.add(test.getClientTransferable());
			}
			testseq.value = new ClientTest_Transferable[vec.size()];
			vec.copyInto(testseq.value);
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить тесты: " + ex.toString());
		}
	}

	static void getTestIdsInDiapazon(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			long start_time,
			long end_time,
			ResourceDescriptorSeq_TransferableHolder desc)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);

		Vector vec1 = getResourceDescriptors(conn, "test");
		ResourceDescriptor_Transferable[] desc1 = new ResourceDescriptor_Transferable[vec1.size()];
		vec1.copyInto(desc1);

		Vector vec = filterTimeDiapazon(start_time, end_time, desc1);
		System.out.println("tests in diapazon - " + vec.size());
		vec = filterDomain(conn, vec, accessIdentity.domain_id);
		System.out.println("tests in domain - " + vec.size());

		desc.value = new ResourceDescriptor_Transferable[vec.size()];
		vec.copyInto(desc.value);
	}

	static Vector filterDomain(final Connection conn, Vector invec, String domain_id) throws SQLException {
		Vector vec = new Vector();
		String dom;
		String kis_id;
		ResourceDescriptor_Transferable rd;
		Test test;

		for (int i = 0; i < invec.size(); i++)
		{
			try
			{
				rd = (ResourceDescriptor_Transferable )invec.get(i);
				test = new Test(rd.resource_id);
				kis_id = test.getKISId();
				
				#sql [new DefaultContext(conn)] {
					select domain_id into :dom from equipments
					where id = :kis_id
				};
				if (domain_id.equals(dom))
				{
					vec.add(rd);
					System.out.println("Test " + test.getId());
				}
			}
			catch (Exception e)
			{
				e.printStackTrace();
			}
		}
		return vec;
	}

	static Vector filterTimeDiapazon(long start_time, long end_time, ResourceDescriptor_Transferable[] desc1) throws AMFICOMRemoteException {
		Vector vec = new Vector();

		try
		{
			for (int i = 0; i < desc1.length; i++)
			{
				Test test = new Test(desc1[i].resource_id);
				long st = test.getTransferable().start_time;
				if (test.getTemporalType() == TestTemporalType._TEST_TEMPORAL_TYPE_ONETIME)
				{
					if (st <= end_time && st >= start_time)
					{
						vec.add(desc1[i]);
					}
				}
				else
				if (test.getTemporalType() == TestTemporalType._TEST_TEMPORAL_TYPE_PERIODICAL)
				{
					long et = test.getEndTime().getTime();
					if (st <= end_time && et >= start_time)
					{
						vec.add(desc1[i]);
					}
				}
				else
				if (test.getTemporalType() == TestTemporalType._TEST_TEMPORAL_TYPE_TIMETABLE)
				{
					long et = st;
					long[] ti = test.getTransferable().time_stamps.ti();
					for (int j = 0; j < ti.length; j++)
						if (ti[j] > et)
							et = ti[j];
					if (st <= end_time && et >= start_time)
					{
						vec.add(desc1[i]);
					}
				}
			}

			return vec;
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить тест: " + ex.toString());
		}
	}

	static void getTestIdsForMonitoredElement(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String me_id,
			ResourceDescriptorSeq_TransferableHolder testids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		SurveydbInterfaceLoad.getTestIdsForMonitoredElement(conn, me_id, testids);
	}

	static void getAnalysis(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ClientAnalysisSeq_TransferableHolder analysisseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		analysisseq.value = new ClientAnalysis_Transferable[0];

		Analysis[] a;
		try
		{
			a = Analysis.retrieveUserAnalysises(accessIdentity.domain_id);
			analysisseq.value = new ClientAnalysis_Transferable[a.length];
			for (int i = 0; i < a.length; i++)
				analysisseq.value[i] = a[i].getClientTransferable();
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить Объекты анализа: " + ex.toString());
		}
	}

	static void getAnalysisIdsForMonitoredElement(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String me_id,
			ResourceDescriptorSeq_TransferableHolder analysisids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		analysisids.value = new ResourceDescriptor_Transferable[0];

		Vector vec = new Vector();

		ResourceIdIterator idIt = null;

		try
		{
			#sql [new DefaultContext(conn)] idIt = {
				select ID, MODIFIED from AMFICOM.ANALYSIS
				where MONITORED_ELEMENT_ID = :me_id
				and DELETED IS NULL
				and USER_ID IS NOT NULL
			};
			while(idIt.next())
				vec.add(new ResourceDescriptor_Transferable(idIt.id(), idIt.modified().getTime()));
			analysisids.value = new ResourceDescriptor_Transferable[vec.size()];
			vec.copyInto(analysisids.value);
		}
		catch (Exception e) {
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить анализ: " + e.toString());
		} finally {
			if (idIt != null)
				idIt.close();
		}
	}

	static void getModelings(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ClientModelingSeq_TransferableHolder modelingseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		modelingseq.value = new ClientModeling_Transferable[0];
		Modeling[] m;
		try
		{
			m = Modeling.retrieveModelings();
			modelingseq.value = new ClientModeling_Transferable[m.length];
			for (int i = 0; i < m.length; i++)
				modelingseq.value[i] = m[i].getClientTransferable();
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить Объекты моделирования " + ex.toString());
		}
	}

	static void getModelingIdsForSchemePath(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String scheme_path_id,
			ResourceDescriptorSeq_TransferableHolder modelingids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		modelingids.value = new ResourceDescriptor_Transferable[0];

		Vector vec = new Vector();

		ResourceIdIterator idIt = null;
		try
		{

			#sql [new DefaultContext(conn)] idIt = {
				select ID, MODIFIED from AMFICOM.MODELING
				where SCHEME_PATH_ID = :scheme_path_id
				and DELETED IS NULL
				and USER_ID IS NOT NULL
			};
			while(idIt.next())
				vec.add(new ResourceDescriptor_Transferable(idIt.id(), idIt.modified().getTime()));
			modelingids.value = new ResourceDescriptor_Transferable[vec.size()];
			vec.copyInto(modelingids.value);
		} catch (Exception e) {
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить модели: " + e.toString());
		} finally {
			if (idIt != null)
				idIt.close();
		}
	}

	static void getEvaluations(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ClientEvaluationSeq_TransferableHolder evaluationseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		evaluationseq.value = new ClientEvaluation_Transferable[0];
		Evaluation[] e;
		try
		{
			e = Evaluation.retrieveUserEvaluations(accessIdentity.domain_id);
			evaluationseq.value = new ClientEvaluation_Transferable[e.length];
			for (int i = 0; i < e.length; i++)
				evaluationseq.value[i] = e[i].getClientTransferable();
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить Объекты оценки: " + ex.toString());
		}
	}

	static void getEvaluationIdsForMonitoredElement(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String me_id,
			ResourceDescriptorSeq_TransferableHolder evaluationids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		evaluationids.value = new ResourceDescriptor_Transferable[0];

		Vector vec = new Vector();

		ResourceIdIterator idIt = null;
		try
		{

			#sql [new DefaultContext(conn)] idIt = {
				select ID, MODIFIED from AMFICOM.EVALUATIONS
				where MONITORED_ELEMENT_ID = :me_id
				and DELETED IS NULL
				and USER_ID IS NOT NULL
			};
			while(idIt.next())
				vec.add(new ResourceDescriptor_Transferable(idIt.id(), idIt.modified().getTime()));

			evaluationids.value = new ResourceDescriptor_Transferable[vec.size()];
			vec.copyInto(evaluationids.value);
		} catch (Exception e) {
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить оценку: " + e.toString());
		} finally {
			if (idIt != null)
				idIt.close();
		}
	}

	static void getRequestTests(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String request_id,
			ClientTestSeq_TransferableHolder testseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		testseq.value = new ClientTest_Transferable[0];
		Test test;
		Vector vec = new Vector();

		IdIterator idIt = null;
		try
		{

			#sql [new DefaultContext(conn)] idIt = { select ID from AMFICOM.TESTS
				where REQUEST_ID = :request_id
				and DELETED IS NULL
			};
			while(idIt.next())
			{
				test = new Test(idIt.id());
				vec.add(test.getTransferable());
			}

			testseq.value = new ClientTest_Transferable[vec.size()];
			vec.copyInto(testseq.value);
		} catch (Exception e) {
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно загрузить тесты: " + e.toString());
		} finally {
			if (idIt != null)
				idIt.close();
		}
	}

	static void queryResource(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String parameter_id,
			String kis_id,
			String parameter_type_id)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		try {
			#sql [new DefaultContext(conn)] {
				insert into RESOURCEQUERIES(
					ID,
					PARAMETER_ID,
					KIS_ID,
					PARAMETER_TYPE_ID)
				values(
					:(ResourcedbInterface.getUid(conn, "resourcequery")),
					:parameter_id,
					:kis_id,
					:parameter_type_id)
			};
		} catch (SQLException sqle) {
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, sqle.toString());
		}
	}

	static void removeTests(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] testids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		try
		{
			for (int i = 0; i < testids.length; i++)
				new Test(testids[i]).delete();
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_UPDATING, "Невозможно ИЗМЕНИТЬ тест: " + ex.toString());
		}
	}

	static void updateTests(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ClientTest_Transferable[] testseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		try {
			for (int i = 0; i < testseq.length; i++)
				try {
					new Test(testseq[i]);
				} catch (Exception e) {
					e.printStackTrace();
					new Test(testseq[i].id).update(testseq[i]);
				}
		} catch (SQLException sqle) {
			sqle.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_UPDATING, "Невозможно ИЗМЕНИТЬ тест: " + sqle.toString());
		}
	}

	static void getLastResult(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String me_id,
			ClientResult_TransferableHolder result)
		throws SQLException, AMFICOMRemoteException
	{
		DefaultContext connCtx = new DefaultContext(conn);

		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		result.value = new ClientResult_Transferable();

		IdIterator idIt = null;

		try
		{
			String test_id = "";
			Timestamp est;
			String max_test_id = "";
			Timestamp max_est = new Timestamp(0);

			String res_id = "";

			#sql [connCtx] idIt = { select ID from AMFICOM.TESTS
					where MONITORED_ELEMENT_ID = :me_id };

			while(idIt.next())
			{
				test_id = idIt.id();

				#sql [connCtx] { select MAX(ELEMENTARY_START_TIME) into :est
					from AMFICOM.RESULTS
					where TEST_ID = :test_id
				};
				if (est.getTime() > max_est.getTime())
				{
					max_est = est;
					max_test_id = test_id;
				}
			}
			#sql [connCtx] { select ID into :res_id from AMFICOM.RESULTS
				where TEST_ID = :max_test_id
				and ELEMENTARY_START_TIME = :max_est
			};

			result.value = new Result(res_id).getClientTransferable();
		} catch (Exception e) {
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат теста: " + e.toString());
		} finally {
			if (idIt != null)
				idIt.close();
		}
	}

	static void getTestResults(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String test_id,
			ClientResultSeq_TransferableHolder results)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		results.value = new ClientResult_Transferable[0];
		Result[] res;
		try
		{
			res = Result.retrieveResults("test", test_id);

			results.value = new ClientResult_Transferable[res.length];
			for (int i = 0; i < res.length; i++)
				results.value[i] = res[i].getClientTransferable();
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат теста: " + ex.toString());
		}
	}

	static void getAnalysisResults(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String analysis_id,
			ClientResultSeq_TransferableHolder results)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		results.value = new ClientResult_Transferable[0];
		Result[] res;
		try
		{
			res = Result.retrieveResults("analysis", analysis_id);

			results.value = new ClientResult_Transferable[res.length];
			for (int i = 0; i < res.length; i++)
				results.value[i] = res[i].getClientTransferable();
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат анализа: " + ex.toString());
		}
	}

	static ClientResult_Transferable[] getStatisticsAnalysisResults(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String monitored_element_id,
			long start_time,
			long end_time)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		ClientResult_Transferable[] results = new ClientResult_Transferable[0];

		Vector vec = new Vector();
		IdIterator idIt = null;
		try
		{
			#sql [new DefaultContext(conn)] idIt = {
				select ID from AMFICOM.RESULTS
				where RESULT_TYPE = 'analysis'
				and ELEMENTARY_START_TIME < :(new Timestamp(end_time))
				and ELEMENTARY_START_TIME > :(new Timestamp(start_time))
				and ANALYSIS_ID in
					( select ID from AMFICOM.ANALYSIS
						where MONITORED_ELEMENT_ID = :monitored_element_id
						and DELETED is null
					)
			};

			while(idIt.next())
				vec.add((new Result(idIt.id())).getClientTransferable());
			results = new ClientResult_Transferable[vec.size()];
			vec.copyInto(results);
		}
		catch (Exception e) {
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат анализа: " + e.toString());
		} finally {
			if (idIt != null)
				idIt.close();
		}
		return results;
	}

	static ClientResult_Transferable[] getStatisticsAnalysisResultsByTS(final Connection conn, AccessIdentity_Transferable accessIdentity, String monitored_element_id, long start_time, long end_time, String test_setup_id) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		ClientResult_Transferable[] results = new ClientResult_Transferable[0];
		Vector vec = new Vector();
		IdIterator idIt = null;
		try {
			#sql [new DefaultContext(conn)] idIt = {
				SELECT id FROM amficom.results WHERE result_type = 'analysis' AND elementary_start_time < :(new Timestamp(end_time)) AND elementary_start_time > :(new Timestamp(start_time)) AND analysis_id IN (SELECT id FROM amficom.analysis WHERE monitored_element_id = :monitored_element_id AND deleted IS NULL) AND analysis_id IN (SELECT analysis_id FROM amficom.tests WHERE monitored_element_id = :monitored_element_id AND test_setup_id = :test_setup_id AND analysis_id IS NOT NULL AND deleted IS NULL)
			};
			while(idIt.next())
				vec.add((new Result(idIt.id())).getClientTransferable());
			results = new ClientResult_Transferable[vec.size()];
			vec.copyInto(results);
		} catch (Exception e) {
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат анализа: " + e.toString());
		} finally {
			if (idIt != null)
				idIt.close();
		}
		return results;
	}

	static void getModelingResult(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String modeling_id,
			ClientResult_TransferableHolder result)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		result.value = new ClientResult_Transferable();
		Result[] res;
		try
		{
			res = Result.retrieveResults("modeling", modeling_id);
			if (res.length != 0)
				result.value = res[0].getClientTransferable();
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат моделирования: " + ex.toString());
		}
	}

	static void getEvaluationResults(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String evaluation_id,
			ClientResultSeq_TransferableHolder results)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		results.value = new ClientResult_Transferable[0];
		Result[] res;
		try
		{
			res = Result.retrieveResults("evaluation", evaluation_id);

			results.value = new ClientResult_Transferable[res.length];
			for (int i = 0; i < res.length; i++)
				results.value[i] = res[i].getClientTransferable();
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат оценки: " + ex.toString());
		}
	}

	static void getLastResultId(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String me_id,
			ResourceDescriptor_TransferableHolder result)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);

		result.value = new ResourceDescriptor_Transferable();
		ClientResult_TransferableHolder resulth = new ClientResult_TransferableHolder();
		getLastResult(conn, accessIdentity, me_id, resulth);
		result.value = new ResourceDescriptor_Transferable(resulth.value.id, resulth.value.elementary_start_time);
	}

	static void getTestResultIds(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String test_id,
			ResourceDescriptorSeq_TransferableHolder results)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		results.value = new ResourceDescriptor_Transferable[0];
		Result[] res;
		try
		{
			res = Result.retrieveResults("test", test_id);

			results.value = new ResourceDescriptor_Transferable[res.length];
			for (int i = 0; i < res.length; i++)
				results.value[i] = new ResourceDescriptor_Transferable(res[i].getId(), res[i].getElementaryStartTime().getTime());
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат теста: " + ex.toString());
		}
	}

	static void getAnalysisResultIds(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String analysis_id,
			ResourceDescriptorSeq_TransferableHolder results)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		results.value = new ResourceDescriptor_Transferable[0];
		Result[] res;
		try
		{
			res = Result.retrieveResults("analysis", analysis_id);

			results.value = new ResourceDescriptor_Transferable[res.length];
			for (int i = 0; i < res.length; i++)
				results.value[i] = new ResourceDescriptor_Transferable(res[i].getId(), res[i].getElementaryStartTime().getTime());
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат анализа: " + ex.toString());
		}
	}

	static void getModelingResultId(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String modeling_id,
			ResourceDescriptor_TransferableHolder result)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		result.value = new ResourceDescriptor_Transferable();

		Result[] res;
		try
		{
			res = Result.retrieveResults("modeling", modeling_id);
			if (res.length != 0)
				result.value = new ResourceDescriptor_Transferable(res[0].getId(), res[0].getElementaryStartTime().getTime());
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат моделирования: " + ex.toString());
		}
	}

	static void getEvaluationResultIds(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String evaluation_id,
			ResourceDescriptorSeq_TransferableHolder results)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		results.value = new ResourceDescriptor_Transferable[0];
		Result[] res;
		try
		{
			res = Result.retrieveResults("evaluation", evaluation_id);

			results.value = new ResourceDescriptor_Transferable[res.length];
			for (int i = 0; i < res.length; i++)
				results.value[i] = new ResourceDescriptor_Transferable(res[i].getId(), res[i].getElementaryStartTime().getTime());
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат оценки: " + ex.toString());
		}
	}

	static void getResult(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String result_id,
			ClientResult_TransferableHolder result)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		try
		{
			result.value = new Result(result_id).getClientTransferable();
		}
		catch (SQLException ex)
		{
			ex.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_LOADING, "Невозможно получить результат: " + ex.toString());
		}
	}

	static void saveAnalysis(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ClientAnalysis_Transferable analysis,
			ClientResult_Transferable result)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		try
		{
			new Analysis(analysis);
			new Result(result);
		}
		catch (SQLException sqle)
		{
			sqle.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, "Невозможно сохранить анализ: " + sqle.toString());
		}
		catch (Exception e)
		{
			/**
			 * @todo Soon, Arseniy will introduce a separate exception type.
			 */
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, "Невозможно сохранить анализ: " + e.toString());
		}
	}

	static void saveModeling(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ClientModeling_Transferable modeling,
			ClientResult_Transferable result)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		try
		{
			new Modeling(modeling);
			new Result(result);
		}
		catch (SQLException sqle)
		{
			sqle.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, "Невозможно сохранить модель: " + sqle.toString());
		}
		catch (Exception e)
		{
			/**
			 * @todo Soon, Arseniy will introduce a separate exception type.
			 */
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, "Невозможно сохранить модель: " + e.toString());
		}
	}

	static void saveEvaluation(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ClientEvaluation_Transferable evaluation,
			ClientResult_Transferable result)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		try
		{
			new Evaluation(evaluation);
			new Result(result);
		}
		catch (SQLException sqle)
		{
			sqle.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, "Невозможно сохранить оценку: " + sqle.toString());
		}
		catch (Exception e)
		{
			/**
			 * @todo Soon, Arseniy will introduce a separate exception type.
			 */
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, "Невозможно сохранить оценку: " + e.toString());
		}
	}

	static void getResultSets(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ResultSetSeq_TransferableHolder resultsets)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		resultsets.value = new ResultSet_Transferable[0];

		ResultSetdbInterface.getResultSets(conn, accessIdentity.domain_id, resultsets);
	}

	static void getStatedResultSets(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			ResultSetSeq_TransferableHolder resultsets)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		resultsets.value = new ResultSet_Transferable[0];

		ResultSetdbInterface.getResultSets(conn, accessIdentity.domain_id, resultsets, ids);
	}

	static void getResultSetResultIds(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String result_set_id,
			ResourceDescriptorSeq_TransferableHolder result_ids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		result_ids.value = new ResourceDescriptor_Transferable[0];

		ResultSetdbInterface.getResultIds(conn, result_set_id, result_ids);
	}

	static void getResultSetResultMEIds(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String result_set_id,
			String me_id,
			ResourceDescriptorSeq_TransferableHolder result_ids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		result_ids.value = new ResourceDescriptor_Transferable[0];

		ResultSetdbInterface.getResultIds(conn, result_set_id, me_id, result_ids);
	}


	static void loadGlobalParameterTypes(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			GlobalParameterTypeSeq_TransferableHolder params)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		SurveydbInterfaceLoad.loadGlobalParameterTypes(conn, params);
	}

	static void loadGlobalParameterTypes(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			GlobalParameterTypeSeq_TransferableHolder params)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		SurveydbInterfaceLoad.loadGlobalParameterTypes(conn, ids, params);
	}

	static void loadTestTypes(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			TestTypeSeq_TransferableHolder ttypeseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		ttypeseq.value = new TestType_Transferable[0];

		TestType[] ttypes;
		try
		{
			ttypes = TestType.retrieveTestTypes();
			ttypeseq.value = new TestType_Transferable[ttypes.length];
			for (int i = 0; i < ttypes.length; i++)
				ttypeseq.value[i] = ttypes[i].getTransferable();
		}
		catch (SQLException e)
		{
			String mesg = "Exception while getting test types: " + e.toString();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
	}

	static void loadTestTypes(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			TestTypeSeq_TransferableHolder ttypeseq)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		ttypeseq.value = new TestType_Transferable[0];

		try
		{
			ttypeseq.value = new TestType_Transferable[ids.length];
			for (int i = 0; i < ids.length; i++)
				ttypeseq.value[i] = new TestType(ids[i]).getTransferable();
		}
		catch (SQLException e)
		{
			String mesg = "Exception while getting test types: " + e.toString();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
	}

	static void loadAnalysisTypes(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			AnalysisTypeSeq_TransferableHolder atypes)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		atypes.value = new AnalysisType_Transferable[0];
		AnalysisType[] at;
		try
		{
			at = AnalysisType.retrieveAnalysisTypes();
			atypes.value = new AnalysisType_Transferable[at.length];
			for (int i = 0; i < at.length; i++)
				atypes.value[i] = at[i].getTransferable();
		}
		catch (SQLException e)
		{
			String mesg = "Exception while getting analysis types: " + e.toString();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
	}

	static void loadAnalysisTypes(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			AnalysisTypeSeq_TransferableHolder atypes)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		atypes.value = new AnalysisType_Transferable[0];
		try
		{
			atypes.value = new AnalysisType_Transferable[ids.length];
			for (int i = 0; i < ids.length; i++)
				atypes.value[i] = new AnalysisType(ids[i]).getTransferable();
		}
		catch (SQLException e)
		{
			String mesg = "Exception while getting analysis types: " + e.toString();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
	}

	static void loadEvaluationTypes(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			EvaluationTypeSeq_TransferableHolder etypes)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		etypes.value = new EvaluationType_Transferable[0];
		EvaluationType[] et;
		try
		{
			et = EvaluationType.retrieveEvaluationTypes();
			etypes.value = new EvaluationType_Transferable[et.length];
			for (int i = 0; i < et.length; i++)
				etypes.value[i] = et[i].getTransferable();
		}
		catch (SQLException e)
		{
			String mesg = "Exception while getting evaluation types: " + e.toString();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
	}

	static void loadEvaluationTypes(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			EvaluationTypeSeq_TransferableHolder etypes)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		etypes.value = new EvaluationType_Transferable[0];
		try
		{
			System.out.println("get evaluation " + ids[0]);
			etypes.value = new EvaluationType_Transferable[ids.length];
			for (int i = 0; i < ids.length; i++)
				etypes.value[i] = new EvaluationType(ids[i]).getTransferable();
		}
		catch (SQLException e)
		{
			String mesg = "Exception while getting evaluation types: " + e.toString();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
	}

	static void loadModelingTypes(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ModelingTypeSeq_TransferableHolder mtypes)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		mtypes.value = new ModelingType_Transferable[0];
		ModelingType[] mt;
		try
		{
			System.out.println("get all modelings");
			mt = ModelingType.retrieveModelingTypes();
			mtypes.value = new ModelingType_Transferable[mt.length];
			for (int i = 0; i < mt.length; i++)
				mtypes.value[i] = mt[i].getTransferable();
		}
		catch (SQLException e)
		{
			String mesg = "Exception while getting modeling types: " + e.toString();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
	}

	static void loadModelingTypes(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] ids,
			ModelingTypeSeq_TransferableHolder mtypes)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		mtypes.value = new ModelingType_Transferable[0];
		try
		{
			mtypes.value = new ModelingType_Transferable[ids.length];
			for (int i = 0; i < ids.length; i++)
				mtypes.value[i] = new ModelingType(ids[i]).getTransferable();
		}
		catch (SQLException e)
		{
			String mesg = "Exception while getting modeling types: " + e.toString();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
	}

	static void loadCriteriaSets(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ClientCriteriaSetSeq_TransferableHolder css)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		css.value = new ClientCriteriaSet_Transferable[0];
	}

	static void loadThresholdSets(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ClientThresholdSetSeq_TransferableHolder tss)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		tss.value = new ClientThresholdSet_Transferable[0];
	}

	static void loadEtalons(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ClientEtalonSeq_TransferableHolder ets)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		ets.value = new ClientEtalon_Transferable[0];
	}

	static String createTestSetup(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			TestSetup_Transferable test_setup_t)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		TestSetup ts = null;
		int count;
		try
		{
			#sql [new DefaultContext(conn)] {
				SELECT COUNT(*) INTO :count FROM amficom.testsetups WHERE id = :(test_setup_t.id)
			};
			if (count == 0)
			{
				ts = new TestSetup(test_setup_t);
				return ts.getId();
			}
			else
			{
				ts = new TestSetup(test_setup_t.id);
				ts.update(test_setup_t);
				return test_setup_t.id;
			}
		}
		catch (SQLException e)
		{
			String mesg = "Exception while saving TestSetup '" + test_setup_t.name + "' for test_type_id '" + test_setup_t.test_type_id + "': " + e.toString();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
	}

	static String createTestArgumentSet(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ClientTestArgumentSet_Transferable arg_set_t)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		TestArgumentSet tas = null;
		int count;
		try
		{
			#sql [new DefaultContext(conn)] {
				SELECT COUNT(*) INTO :count FROM amficom.testargumentsets WHERE id = :(arg_set_t.id)
			};
			if (count == 0)
			{
				tas = new TestArgumentSet(arg_set_t);
				return tas.getId();
			}
			else
			{
				tas = new TestArgumentSet(arg_set_t.id);
				tas.update(arg_set_t);
				return arg_set_t.id;
			}
		}
		catch (SQLException sqle)
		{
			String mesg = "Exception while saving teas argument set '" + arg_set_t.name + "' for test_type_id '" + arg_set_t.test_type_id + "': " + sqle.toString();
			System.out.println(mesg);
			sqle.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
		catch (Exception e)
		{
			/**
			 * @todo Soon, Arseniy will introduce a separate exception type.
			 */
			String mesg = "Exception while saving teas argument set '" + arg_set_t.name + "' for test_type_id '" + arg_set_t.test_type_id + "': " + e.toString();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
	}

	static String createCriteriaSet(final Connection conn, AccessIdentity_Transferable accessIdentity, ClientCriteriaSet_Transferable criteria_set_t) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		CriteriaSet cs = null;
		int count;
		try
		{
			#sql [new DefaultContext(conn)] {
				select count(*) into :count from AMFICOM.CRITERIASETS
				where ID = :(criteria_set_t.id)
			};
			if (count == 0)
			{
				cs = new CriteriaSet(criteria_set_t);
				return cs.getId();
			}
			else
			{
				cs = new CriteriaSet(criteria_set_t.id);
				cs.update(criteria_set_t);
				return criteria_set_t.id;
			}
		}
		catch (SQLException sqle)
		{
			String mesg = "Exception while saving criteria set '" + criteria_set_t.name + "' for analysis_type_id '" + criteria_set_t.analysis_type_id + "': " + sqle.toString();
			System.out.println(mesg);
			sqle.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
		catch (Exception e)
		{
			/**
			 * @todo Soon, Arseniy will introduce a separate exception type.
			 */
			String mesg = "Exception while saving criteria set '" + criteria_set_t.name + "' for analysis_type_id '" + criteria_set_t.analysis_type_id + "': " + e.toString();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
	}

	static String createThresholdSet(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ClientThresholdSet_Transferable th_set_t)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		ThresholdSet th = null;
		int count;
		try
		{
			#sql [new DefaultContext(conn)] {
				SELECT COUNT(*) INTO :count FROM amficom.thresholdsets WHERE id = :(th_set_t.id)
			};
			if (count == 0)
			{
				th = new ThresholdSet(th_set_t);
				return th.getId();
			}
			else
			{
				th = new ThresholdSet(th_set_t.id);
				th.update(th_set_t);
				return th_set_t.id;
			}
		}
		catch (SQLException sqle)
		{
			String mesg = "Exception while saving Threshold set '" + th_set_t.name + "' for evaluation_type_id '" + th_set_t.evaluation_type_id + "': " + sqle.toString();
			System.out.println(mesg);
			sqle.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
		catch (Exception e)
		{
			/**
			 * @todo Soon, Arseniy will introduce a separate exception type.
			 */
			String mesg = "Exception while saving Threshold set '" + th_set_t.name + "' for evaluation_type_id '" + th_set_t.evaluation_type_id + "': " + e.toString();
			System.out.println(mesg);
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, mesg);
		}
	}

	static String createEtalon(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			ClientEtalon_Transferable e_t)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		String id = null;
		int count;
		try
		{
			#sql [new DefaultContext(conn)] {
				SELECT COUNT(*) INTO :count FROM amficom.etalons WHERE id = :(e_t.id)
			};
			if (count == 0)
				id = new Etalon(e_t).getId();
			else {
				new Etalon(e_t.id).update(e_t);
				id = e_t.id;
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw new AMFICOMRemoteException(Constants.ERROR_SAVING, e.toString());
		}
		return id;
	}

	static void loadStatedNetDirectory(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] pt_ids,
			String[] eqt_ids,
			String[] lt_ids,
			String[] cht_ids,
			String[] cpt_ids,
			String[] clt_ids,
			PortTypeSeq_TransferableHolder porttypes,
			EquipmentTypeSeq_TransferableHolder equipmenttypes,
			LinkTypeSeq_TransferableHolder linktypes,
			CharacteristicTypeSeq_TransferableHolder characteristictypes,
			CablePortTypeSeq_TransferableHolder cableporttypes,
			CableLinkTypeSeq_TransferableHolder cablelinktypes)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		porttypes.value = new PortType_Transferable[0];
		equipmenttypes.value = new EquipmentType_Transferable[0];
		linktypes.value = new LinkType_Transferable[0];
		characteristictypes.value = new CharacteristicType_Transferable[0];
		cableporttypes.value = new CablePortType_Transferable[0];
		cablelinktypes.value = new CableLinkType_Transferable[0];
		NetDirectorydbInterfaceLoad.loadPortTypes(conn, pt_ids, porttypes);
		NetDirectorydbInterfaceLoad.loadEquipmentTypes(conn, eqt_ids, equipmenttypes);
		NetDirectorydbInterfaceLoad.loadLinkTypes(conn, lt_ids, linktypes);
		NetDirectorydbInterfaceLoad.loadCharacteristicTypes(conn, cht_ids, characteristictypes);
		NetDirectorydbInterfaceLoad.loadCablePortTypes(conn, cpt_ids, cableporttypes);
		NetDirectorydbInterfaceLoad.loadCableTypes(conn, clt_ids, cablelinktypes);
	}

	static void loadISMDirectory(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			EquipmentTypeSeq_TransferableHolder kistypes,
			MeasurementPortTypeSeq_TransferableHolder aporttypes,
			TransmissionPathTypeSeq_TransferableHolder pathtypes)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		kistypes.value = new EquipmentType_Transferable[0];
		aporttypes.value = new MeasurementPortType_Transferable[0];
		pathtypes.value = new TransmissionPathType_Transferable[0];
		ISMDirectorydbInterfaceLoad.loadAccessPortTypes(conn, aporttypes);
		ISMDirectorydbInterfaceLoad.loadPathTypes(conn, pathtypes);
	}

	static void loadStatedISMDirectory(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] kis_ids,
			String[] aport_ids,
			String[] path_ids,
			EquipmentTypeSeq_TransferableHolder kistypes,
			MeasurementPortTypeSeq_TransferableHolder aporttypes,
			TransmissionPathTypeSeq_TransferableHolder pathtypes)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		kistypes.value = new EquipmentType_Transferable[0];
		aporttypes.value = new MeasurementPortType_Transferable[0];
		pathtypes.value = new TransmissionPathType_Transferable[0];
		ISMDirectorydbInterfaceLoad.loadAccessPortTypes(conn, aport_ids, aporttypes);
		ISMDirectorydbInterfaceLoad.loadPathTypes(conn, path_ids, pathtypes);
	}

	static void removeNetDirectory(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] pt_ids,
			String[] cpt_ids,
			String[] eqt_ids,
			String[] lt_ids,
			String[] clt_ids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		NetDirectorydbInterfaceRemove.removePortTypes(conn, pt_ids);
		NetDirectorydbInterfaceRemove.removeEquipmentTypes(conn, eqt_ids);
		NetDirectorydbInterfaceRemove.removeLinkTypes(conn, lt_ids);
		NetDirectorydbInterfaceRemove.removeCablePortTypes(conn, cpt_ids);
		NetDirectorydbInterfaceRemove.removeCableLinkTypes(conn, clt_ids);
	}

	static void removeISMDirectory(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			String[] kst_ids,
			String[] apt_ids,
			String[] tpt_ids)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		ISMDirectorydbInterfaceRemove.removeAccessPortTypes(conn, apt_ids);
		ISMDirectorydbInterfaceRemove.removeRTUTypes(conn, kst_ids);
		ISMDirectorydbInterfaceRemove.removePathTypes(conn, tpt_ids);
	}

	static void saveNetDirectory(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			PortType_Transferable[] porttypes,
			EquipmentType_Transferable[] equipmenttypes,
			LinkType_Transferable[] linktypes,
			CharacteristicType_Transferable[] characteristictypes,
			CablePortType_Transferable[] cableporttypes,
			CableLinkType_Transferable[] cablelinktypes)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		NetDirectorydbInterfaceSave.savePortTypes(conn, porttypes);
		NetDirectorydbInterfaceSave.saveEquipmentTypes(conn, equipmenttypes);
		NetDirectorydbInterfaceSave.saveLinkTypes(conn, linktypes);
		NetDirectorydbInterfaceSave.saveCharacteristicTypes(conn, characteristictypes);
		NetDirectorydbInterfaceSave.saveCablePortTypes(conn, cableporttypes);
		NetDirectorydbInterfaceSave.saveCableLinkTypes(conn, cablelinktypes);
	}

	static void saveISMDirectory(final Connection conn, 
			AccessIdentity_Transferable accessIdentity,
			EquipmentType_Transferable[] kistypes,
			MeasurementPortType_Transferable[] aporttypes,
			TransmissionPathType_Transferable[] pathtypes)
		throws SQLException, AMFICOMRemoteException
	{
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		ISMDirectorydbInterfaceSave.saveAccessPortTypes(conn, aporttypes);
		ISMDirectorydbInterfaceSave.saveRTUTypes(conn, kistypes);
		ISMDirectorydbInterfaceSave.savePathTypes(conn, pathtypes);
	}

	static void loadStatedNet(final Connection conn, AccessIdentity_Transferable accessIdentity, String[] p_ids, String[] cp_ids, String[] eq_ids, String[] l_ids, String[] cl_ids, PortSeq_TransferableHolder ports, CablePortSeq_TransferableHolder cports, EquipmentSeq_TransferableHolder equipments, LinkSeq_TransferableHolder links, CableLinkSeq_TransferableHolder clinks) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		Vector port_vec = new Vector();
		Vector cport_vec = new Vector();

		ports.value = new Port_Transferable[0];
		cports.value = new CablePort_Transferable[0];
		equipments.value = new Equipment_Transferable[0];
		links.value = new Link_Transferable[0];
		clinks.value = new CableLink_Transferable[0];

		NetdbInterfaceLoad.loadEquipments(conn, accessIdentity.domain_id, eq_ids, equipments, port_vec, cport_vec);
		NetdbInterfaceLoad.loadLinks(conn, accessIdentity.domain_id, l_ids, links);
		NetdbInterfaceLoad.loadCableLinks(conn, accessIdentity.domain_id, cl_ids, clinks);

		ports.value = (Port_Transferable[]) (port_vec.toArray(new Port_Transferable[port_vec.size()]));
		cports.value = (CablePort_Transferable[]) (cport_vec.toArray(new CablePort_Transferable[cport_vec.size()]));
	}

	static void loadISM(final Connection conn, AccessIdentity_Transferable accessIdentity, PortSeq_TransferableHolder ports, CablePortSeq_TransferableHolder cports, EquipmentSeq_TransferableHolder kiss, LinkSeq_TransferableHolder links, CableLinkSeq_TransferableHolder clinks, MonitoredElementSeq_TransferableHolder mes, TransmissionPathSeq_TransferableHolder paths, MeasurementPortSeq_TransferableHolder accessports) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		Vector port_vec = new Vector();
		Vector cport_vec = new Vector();
		Vector accessport_vec = new Vector();
		ISMdbInterfaceLoad.loadKISs(conn, accessIdentity.domain_id, kiss, port_vec, cport_vec, accessport_vec);
		ISMdbInterfaceLoad.loadTransmissionPaths(conn, accessIdentity.domain_id, paths);
		ISMdbInterfaceLoad.loadMonitoredElements(conn, accessIdentity.domain_id, mes);
		ports.value = (Port_Transferable[]) (port_vec.toArray(new Port_Transferable[port_vec.size()]));
		cports.value = (CablePort_Transferable[]) (cport_vec.toArray(new CablePort_Transferable[cport_vec.size()]));
		accessports.value = (MeasurementPort_Transferable[]) (accessport_vec.toArray(new MeasurementPort_Transferable[accessport_vec.size()]));
		kiss.value = new Equipment_Transferable[0];
		links.value = new Link_Transferable[0];
		clinks.value = new CableLink_Transferable[0];
		mes.value = new MonitoredElement_Transferable[0];
		paths.value = new TransmissionPath_Transferable[0];
	}

	static void loadStatedISM(final Connection conn, AccessIdentity_Transferable accessIdentity, String[] p_ids, String[] cp_ids, String[] k_ids, String[] l_ids, String[] cl_ids, String[] me_ids, String[] t_ids, String[] ap_ids, PortSeq_TransferableHolder ports, CablePortSeq_TransferableHolder cports, EquipmentSeq_TransferableHolder kiss, LinkSeq_TransferableHolder links, CableLinkSeq_TransferableHolder clinks, MonitoredElementSeq_TransferableHolder mes, TransmissionPathSeq_TransferableHolder paths, MeasurementPortSeq_TransferableHolder accessports) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		Vector port_vec = new Vector();
		Vector cport_vec = new Vector();
		Vector accessport_vec = new Vector();
		ISMdbInterfaceLoad.loadKISs(conn, accessIdentity.domain_id, k_ids, kiss, port_vec, cport_vec, accessport_vec);
		ISMdbInterfaceLoad.loadTransmissionPaths(conn, accessIdentity.domain_id, t_ids, paths);
		ISMdbInterfaceLoad.loadMonitoredElements(conn, accessIdentity.domain_id, me_ids, mes);
		ports.value = (Port_Transferable[]) (port_vec.toArray(new Port_Transferable[port_vec.size()]));
		cports.value = (CablePort_Transferable[]) (cport_vec.toArray(new CablePort_Transferable[cport_vec.size()]));
		accessports.value = (MeasurementPort_Transferable[]) (accessport_vec.toArray(new MeasurementPort_Transferable[accessport_vec.size()]));
		kiss.value = new Equipment_Transferable[0];
		links.value = new Link_Transferable[0];
		clinks.value = new CableLink_Transferable[0];
		mes.value = new MonitoredElement_Transferable[0];
		paths.value = new TransmissionPath_Transferable[0];
	}

	static void saveNet(final Connection conn, AccessIdentity_Transferable accessIdentity, Port_Transferable[] ports, CablePort_Transferable[] cports, Equipment_Transferable[] equipments, Link_Transferable[] links, CableLink_Transferable[] clinks) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		NetdbInterfaceSave.saveEquipments(conn, equipments);
		NetdbInterfaceSave.savePorts(conn, ports);
		NetdbInterfaceSave.saveCablePorts(conn, cports);
		NetdbInterfaceSave.saveLinks(conn, links);
		NetdbInterfaceSave.saveCableLinks(conn, clinks);
	}

	static void saveISM(final Connection conn, AccessIdentity_Transferable accessIdentity, Port_Transferable[] ports, CablePort_Transferable[] cports, Equipment_Transferable[] kiss, Link_Transferable[] links, CableLink_Transferable[] clinks, MonitoredElement_Transferable[] mes, TransmissionPath_Transferable[] paths, MeasurementPort_Transferable[] accessports) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		ISMdbInterfaceSave.saveKISs(conn, kiss);
		NetdbInterfaceSave.savePorts(conn, ports);
		NetdbInterfaceSave.saveCablePorts(conn, cports);
		ISMdbInterfaceSave.saveAccessPorts(conn, accessports);
		ISMdbInterfaceSave.saveTransmissionPaths(conn, paths);
		ISMdbInterfaceSave.saveMonitoredElements(conn, mes);
	}

	static void removeNet(final Connection conn, AccessIdentity_Transferable accessIdentity, String[] p_ids, String[] cp_ids, String[] eq_ids, String[] l_ids, String[] cl_ids) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		NetdbInterfaceRemove.removeLinks(conn, l_ids);
		NetdbInterfaceRemove.removeCableLinks(conn, cl_ids);
		NetdbInterfaceRemove.removePorts(conn, p_ids);
		NetdbInterfaceRemove.removeCablePorts(conn, cp_ids);
		NetdbInterfaceRemove.removeEquipments(conn, eq_ids);
	}

	static void removeISM(final Connection conn, AccessIdentity_Transferable accessIdentity, String[] p_ids, String[] cp_ids, String[] ks_ids, String[] l_ids, String[] cl_ids, String[] me_ids, String[] t_ids, String[] ap_ids) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		ISMdbInterfaceRemove.removeAccessPorts(conn, ap_ids);
		ISMdbInterfaceRemove.removeTransmissionPaths(conn, t_ids);
		ISMdbInterfaceRemove.removeKISs(conn, ks_ids);
	}


	static void saveReportTemplates(final Connection conn, AccessIdentity_Transferable accessIdentity, ReportTemplate_Transferable[] rts) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		for (int i = 0; i < rts.length; i++)
			/**
			 * @todo A lame effort to implement error handling...
			 */
			try {
				(new ReportTemplate(conn, rts[i].id)).update(conn, rts[i]);
			} catch (Exception e) {
				e.printStackTrace();
				new ReportTemplate(conn, rts[i]);
			}
	}

	static void getStatedReportTemplates(final Connection conn, AccessIdentity_Transferable accessIdentity, String[] ids, ReportTemplateSeq_TransferableHolder reportTemplates) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		Collection c = new LinkedList();
		for (int i = 0; i < ids.length; i++)
			c.add((new ReportTemplate(conn, ids[i])).getTransferable());
		reportTemplates.value = (ReportTemplate_Transferable[]) (c.toArray(new ReportTemplate_Transferable[c.size()]));
	}

	static void removeReportTemplates(final Connection conn, AccessIdentity_Transferable accessIdentity, String[] reportTemplate_ids) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		for (int i = 0; i < reportTemplate_ids.length; i++)
			(new ReportTemplate(conn, reportTemplate_ids[i])).delete(conn);
	}

   	static void saveSchemeOptimizeInfo(final Connection conn, AccessIdentity_Transferable accessIdentity, SchemeOptimizeInfo_Transferable soi) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		new SchemeOptimizeInfo(conn, soi);
	}

	static SchemeOptimizeInfo_Transferable[] getSchemeOptimizeInfo(final Connection conn, AccessIdentity_Transferable accessIdentity) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		return SchemeOptimizeInfo.getSOIs(conn);
	}

	static void removeSchemeOptimizeInfo(final Connection conn, AccessIdentity_Transferable accessIdentity, String[] soi_ids) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		for (int i = 0; i < soi_ids.length; i++)
			(new SchemeOptimizeInfo(conn, soi_ids[i])).delete(conn);
	}

	static void saveSchemeMonitoringSolutions(final Connection conn, AccessIdentity_Transferable accessIdentity, SchemeMonitoringSolution_Transferable sol) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		new SchemeMonitoringSolution(conn, sol);
	}

	static SchemeMonitoringSolution_Transferable[] getSchemeMonitoringSolutions(final Connection conn, AccessIdentity_Transferable accessIdentity) throws SQLException, AMFICOMRemoteException {
		AMFICOMdbGeneral.checkUserPrivileges(conn, accessIdentity);
		return SchemeMonitoringSolution.getSMSs(conn);
	}

	#sql private static final iterator IdIterator(
		String id);

	#sql public static final iterator ResourceIdIterator(
		String id, Timestamp modified);

	#sql public static final iterator ResultDescriptorIterator(
		String id, Timestamp elementary_start_time);
}
