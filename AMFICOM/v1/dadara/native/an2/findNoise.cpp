/*
 * findNoise.cpp
 */

/*
 * findNoise3s()
 *
 * Определение общего уровня шума рефлектограммы, используя
 * модель "уровень шума не зависит от сигнала".
 * TODO: Численный множитель для результирующего уровня расчитан плохо.
 *
 * Предполагается рефлектометрическая дБ-шкала.
 * При анализе учитывается:
 * - возможность пред-сглаживания по 8 точкам (NetTest)
 * - пред-округление до 0.001 дБ
 * - наличие событий на р/г (отбрасываем локально-монотонные участки)
 *
 * На входе - рефлектограмма (ргдБ).
 * на выходе - уровень шума (дБ) по уровню 3 сигма
 */

#include <math.h>
#include <assert.h>
#include <stdlib.h>
#include "findNoise.h"

#include "../common/median.h"
#include "../common/prf.h"

#include <stdio.h>

// Для отбрасывания участков, где точность определяется 0.001дБ-представлением
const double prec0 = 0.001 * 1.5;

// начальный уровень шума по отношению к макс. уровню сигнала, дБ
const double MAX_VALUE_TO_INITIAL_DB_NOISE = -10; // -5..-10..-15

// оценка ширины сглаживания белого шума NetTest'ом
const int NETTESTWIDTH = 16;

static int dfcmp(const void *a, const void *b)
{
	const double *x = (const double *)a;
	const double *y = (const double *)b;
	return *x <= *y ? *x < *y ? -1 : 0 : 1;
}

static double log2add(double v)
{
	return pow(10, v / 5);
}
static double add2log(double v)
{
	return 5.0 * log10(v);
}

double findNoise3s(double *data, int size)
{
	if (size <= 0)
		return 0;

	int i;
	double *out = new double[size];
	assert(out);

	const int width = 8; // XXX: NetTest specific - ширина, на которой исчезают корреляции

	int k;
	for (i = 0, k = 0; i < size - width * 2; i++)
	{
		double a = data[i];
		double b = data[i + width];
		double c = data[i + width * 2];

		// уменьшаем вес участков режима счета единичных импульсов
		if (a == c) continue;

		// отбрасываем начало р/г, где шум меньше чем шум 0.001дБ квантования
		if (fabs(a - b) < prec0 || fabs(b - c) < prec0)
			continue;

		// отбрасываем монтонные участки - чтобы исключить события
		// note: это завышает оценку ошибки через 2b-a-c
		if (((a < b) ^ (b < c)) == 0)
			continue;

		// переходим к единицам интенсивности
		a = log2add(a);
		b = log2add(b);
		c = log2add(c);

		// используем отклонение от линейности как оценку шума
		double dif = fabs(2 * b - a - c);

		out[k++] = dif;
	}

	const int s2 = k;

	//fprintf(stderr, "size %d s2 %d (%.2f%%)\n", size, s2, s2 * 100.0 / size);

	// строим интегральную гистограмму
	qsort(out, s2, sizeof(double), dfcmp);

	//for (i = 0; i < s2; i++)
	//	printf("%g %g\n", i * xmax / s2, add2log(out[i]));

	// определяем уровень 3 сигма
	double nlev = add2log(out[s2 / 2] * 1.3);

	delete[] out;

	return nlev;
}

static double dy2dB(double y0, double dy)
{
	return y0 + dy + 5.0 * log10(1.0 - pow(10.0, -dy / 5.0));
}

static double dB2dy(double y0, double dB)
{
	double ret = 5.0 * log10(1.0 + pow(10.0, (dB - y0) / 5.0));
	if (ret > 20.0) // XXX
		ret = 20.0;
	return ret;
}

/*
 * findNoiseArray()
 * определение уровня шума в зависимости от координаты
 * с учетом возможности уменьшения уровня шума на
 * р/г
 * вых. значение - в отн. дБ, по ур. ~1(?) сигма
 * len2 - интересующий пользователя интервал шума, д б <= size (д включать м.з.)
 */
/*
void findNoiseArray(double *data, double *outNoise, int size, int len2)
{
	//prf_b("findNoiseArray: enter");

	const int width = NETTESTWIDTH;
	// mlen должно получиться четным
	const int mlen = width * 10;
	// -1 здесь для выравнивания x-коорд.
	const int nsam = mlen - 2 * width - 1;
	const int mofs = mlen / 2 - 1;
	double gist[nsam];

	if (len2 <= 0)
		return;
	assert(len2 <= size);

	assert(size > mlen); // XXX

	double *temp = new double[size]; // здесь временно будет сглаженная р/г
	assert(temp);
	double *out = new double[size]; // здесь - шум
	assert(out);

	//prf_b("findNoiseArray: #1");

	const int step = 4; // коэф-т загрубления - 4 точки - для ускорения расчета
	int i;
	for (i = 0; i < size - mlen && i < len2 - mofs; i += step)
	{
		int j;
		// определяем начальный уровень шума
		for (j = 0; j < nsam; j ++)
		{
			double v0 = data[i + j];
			double v1 = data[i + j + width];
			double v2 = data[i + j + width * 2];
			gist[j] = fabs(v2 + v0 - v1 - v1);
		}
		double dv = destroyAndGetMedian(gist, nsam, nsam / 2) + 0.001; // XXX: 0.001

		// определяем среднее значение кривой
		for (j = 0; j < nsam; j++)
			gist[j] = data[i + j + width];
		double y0 = destroyAndGetMedian(gist, nsam, nsam / 2);
		temp[i + mofs] = y0;

		//int io = i + mofs;
		//fprintf(stdout, "%d %g %g\n", io, dv, dy2dB(ya[io], dv));
		out[i + mofs] = dy2dB(y0, dv);
	}
	//prf_b("findNoiseArray: #2");
	if (step > 1)
		for (i = 0; i < size - mlen && i < len2 - mofs; i++)
	{
		temp[i + mofs] = temp[i/step*step + mofs];
		out[i + mofs] = out[i/step*step + mofs];
	}
	//prf_b("findNoiseArray: #3");

    // расширяем до краев массива - влево
	for (i = 0; i < mofs; i++)
	{
		out[i] = out[mofs];
		temp[i] = temp[mofs];
	}
	// и - если надо - вправо
	for (i = size - mlen + mofs; i < size && i < len2; i++)
	{
		out[i] = out[size - mlen + mofs - 1];
		temp[i] = temp[size - mlen + mofs - 1];
	}

    // делаем поправку на начало рефлектограммы
    {
		// ищем абс. макс. усредненной р/г
        double vMax = temp[0];
        for (i = 0; i < len2; i++)
        {
        	if (vMax < temp[i])
            	vMax = temp[i];
        }
        // поправляем начальный уровень шума
        if (out[0] > vMax + MAX_VALUE_TO_INITIAL_DB_NOISE)
        	out[0] = vMax + MAX_VALUE_TO_INITIAL_DB_NOISE;
    }

	// строим кривую кумулятивного минимума
	for (i = 1; i < len2; i++)
	{
		if (out[i] > out[i - 1])
			out[i] = out[i - 1];
	}

	// формируем выходной массив
	for (i = 0; i < len2; i++)
	{
		out[i] = dB2dy(temp[i], out[i]);
		//fprintf(stdout,"%d %g\n", i, out[i]);
	}

	//prf_b("findNoiseArray: done");

    // сохраняем в пользовательский массив
	for (i = 0; i < len2; i++)
		outNoise[i] = out[i];

	delete[] temp;
	delete[] out;

	//prf_b("findNoiseArray: exiting");
}
/*/
// более корректное поведение при определении начального уровня шума?
void findNoiseArray(double *data, double *outNoise, int size, int len2)
{
	if (len2 <= 0)
		return;

	//prf_b("findNoiseArray: enter");

	const int width = NETTESTWIDTH;
	// mlen должно получиться четным
	const int mlen = width * 10;
	// -1 здесь для выравнивания x-коорд.
	const int nsam = mlen - 2 * width - 1;
	const int mofs = mlen / 2 - 1;
	double gist[nsam];

	assert(len2 <= size);

	assert(size > mlen); // XXX

	double *temp = new double[size]; // здесь временно будет исх. р/г в лин. масшт.
	assert(temp);
	double *out = new double[size]; // здесь - шум
	assert(out);

	double levelPrec0 = log2add(prec0) - 1; // XXX

	//prf_b("findNoiseArray: log2add");

	int i;
	// приводим к линейному масштабу
	for (i = 0; i < size && i < len2 + mlen - mofs; i++)
		temp[i] = log2add(data[i]);

	//prf_b("findNoiseArray: first estimation");

	// первая оценка уровня шума
	const int step = 4; // коэф-т загрубления - 4 точки - для ускорения расчета
	for (i = 0; i < size - mlen && i < len2 - mofs; i += step)
	{
		int j;
		// определяем начальный уровень шума
		for (j = 0; j < nsam; j ++)
		{
			double v0 = temp[i + j];
			double v1 = temp[i + j + width];
			double v2 = temp[i + j + width * 2];
			gist[j] = fabs(v2 + v0 - v1 - v1) + levelPrec0 * v1; // XXX
		}
		double dv = destroyAndGetMedian(gist, nsam, nsam / 2);
		out[i + mofs] = add2log(dv);
	}
	//prf_b("findNoiseArray: expand & process");
	if (step > 1)
		for (i = 0; i < size - mlen && i < len2 - mofs; i++)
		out[i + mofs] = out[i/step*step + mofs];

    // расширяем до краев массива - влево
	for (i = 0; i < mofs; i++)
	{
		out[i] = out[mofs];
	}
	// и - если надо - вправо
	for (i = size - mlen + mofs; i < size && i < len2; i++)
	{
		out[i] = out[size - mlen + mofs - 1];
	}

    // делаем поправку на начало рефлектограммы
    {
		// ищем абс. макс. усредненной р/г
        double vMax = data[0];
        for (i = 0; i < len2; i++)
        {
        	if (vMax < data[i])
            	vMax = data[i];
        }
        // поправляем начальный уровень шума
        if (out[0] > vMax + MAX_VALUE_TO_INITIAL_DB_NOISE)
        	out[0] = vMax + MAX_VALUE_TO_INITIAL_DB_NOISE;
    }

	// строим кривую кумулятивного минимума
	for (i = 1; i < len2; i++)
	{
		if (out[i] > out[i - 1])
			out[i] = out[i - 1];
	}

	//prf_b("findNoiseArray: dB2dy");
	// формируем выходной массив
	for (i = 0; i < len2; i++)
		outNoise[i] = dB2dy(data[i], out[i]);

	//prf_b("findNoiseArray: done");

	delete[] temp;
	delete[] out;
}
//*/