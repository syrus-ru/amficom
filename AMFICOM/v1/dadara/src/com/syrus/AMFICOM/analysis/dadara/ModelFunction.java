package com.syrus.AMFICOM.analysis.dadara;

import static java.util.logging.Level.FINEST;
import static java.util.logging.Level.INFO;

import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;

import com.syrus.AMFICOM.analysis.CoreAnalysisManager;
import com.syrus.io.SignatureMismatchException;
import com.syrus.util.Log;

/**
 * <p>Represents r/g modelling functions with native implementation.</p>
 *
 * <p>Hides the implementation of f(x).
 * provides access to f(x) values, fitting procedure, RMS calculation,
 * Threshold function build procedure.
 * 
 * Does not cares for begin and end of <i>Amficom</i> events, otherwise than
 * to hint BreakL fitter about recommended stop points.
 *
 * Does not remember the original r/g itself.</p>
 *
 * <p>Input X for the model function is integer.
 * The physical X-scale is not concerned.</p>
 *
 * <p>Output Y = f(X), its units are rgdB derived from Y=5.0*log_10(I) rule.</p>
 *
 * <p>The modelling function type can change when fit() will be called.</p>
 *
 * @version $Revision: 1.36 $, $Date: 2005/11/10 13:16:37 $
 * @author $Author: saa $
 * @author saa
 * @module dadara
 */

public class ModelFunction {
	private static final short SIGNATURE_MF_SHORT = 11360;

	private int shapeID; // тип кривой (внутренний идентификатор native-кода)
	private double[] pars; // параметры кривой

	static {
		CoreAnalysisManager.loadDLL();
	}

	private native double nF(double x);
	private native double[] nFArray(double x0, double step, int length);
	private native void nChangeByACXL(double dA, double dC, double dX, double dL); // преобразование к своему ACXL-порогу
	private native void nChangeByThresh(ThreshDX[] threshDX, ThreshDY[] threshDY, int key); // изменение порогом Thresh

	// определение, какой threshDX-порог отвечает за указанную позицию x
	// Применяется к исходной м.ф., устроен аналогично nChangeByThresh,
	// но:
	// 1. дополнительно получает x,
	// 2. не изменяет сам объект mf,
	// 3. возвращает результат поиска:
	// -1: порог не найден;
	// >=0: индекс найденного порога в массиве threshDX
	private native int nFindResponsibleThreshDXDYID(ThreshDX[] threshDX, ThreshDY[] threshDY, int key, int x, int xThType);
	private native int[] nFindResponsibleThreshDXArray(ThreshDX[] threshDX, ThreshDY[] threshDY, int key, int xMin, int xMax);
	private native double nRMS(double y[], int begin, int end); // end is included

	// Механизм native-преобразования в поток.
	// Поток будет состоять из:
	// (1) int shapeID
	// (2) boolean usingNativeEncoding
	// (3) int len - длина массива байт
	// (4) byte[len] - массив данных, передаваемый из/в native-код
	// Для его использования надо сначала проверить, допустим он или нет.
	private static native boolean nIsNativeStreamingPossible(int shapeID); // проверить допустимость native-преобразования
	private native byte[] nParsToByteArray(); // сохраняет pars в byteArray (если операция недопустима, вернет null)
	private native boolean nParsFromByteArray(byte[] bar); // восстанавливает pars из byteArray. В случае нехватки/избытка данных или ошибки, возвращает true.

	private static final int FITMODE_VARY_ALL = 1; // фитируем кривую, варьируем все параметры
	private static final int FITMODE_VARY_LIN = 2; // фитируем кривую, варьируя только линейные параметры
	private static final int FITMODE_SET_LINEAR = 3; // заменяем прямой
	private static final int FITMODE_SET_BREAKL = 4; // заменяем ломаной
	//private static final int FITMODE_SET_SMOOTH = 5; // заменяем сглаживающей кривой -- пока не реализовано
	
	public static final int LINK_FIXLEFT = 0x1; // зафиксировать левую точку
	
	/**
	 * @deprecated use only for debugging
	 * @return Internal data: shape ID
	 */
	@Deprecated
	public int snoopShapeID()
	{
		return this.shapeID;
	}

	/**
	 * @deprecated Use only for debugging
	 * @return Internal data: parameters array
	 */
	@Deprecated
	public double[] snoopPars()
	{
		return this.pars;
	}

	/**
	 * Процедура фитировки.
	 * @param y кривая, к которой фитируемся. Индекс в массиве
	 * 	совпадает с X-координатой для модельной функции и варьируется
	 *  от begin до end. Полное число фитируемых точек = begin - end + 1.
	 * @param begin начальная точка (включительно)
	 * @param end конечная точка (включительно)
	 * @param fitMode режим фитировки. Задается константами FITMODE_*
	 *  Для режимов FITMODE_VARY_* используется текущий тип кривой,
	 *  и в качестве начального приближения - текущее состояние объекта.
	 *  Для режимов FITMODE_SET_* предыдущее состояние не используется,
	 *  т.е. фактически создается новая модельная функция.
	 * @param linkFlags флаги сшивки со смежными событиями.
	 *  На данный момент поддерживается только флаг LINK_FIXLEFT,
	 *  и только для фитировки ломаной.
	 * @param linkData0 Данные для сшивки по LINK_FIXLEFT.
	 *  (поскольку это всего одно число, оно пока реализовано
	 *  в виде одного числа double).
	 */
	private native void nFit1(double y[], int begin, int end, int fitMode,
			int linkFlags, double linkData0);

	/**
	 * Процедура фитировки. Описание остальных параметров см. в nFit1)
	 * @param errorR начальная отн. ошибка (+- дБ)
	 * @param errorA начальная абс. ошибка (дБ, ~ уровню шума по 3 сигма)
	 * @param maxPoints макс. число точек
	 */
	private native void nFit2(double y[], int begin, int end, int fitMode,
			int linkFlags, double linkData0,
			double errorR, double errorA, int maxPoints);

	/**
	 * Процедура фитировки. Описание остальных параметров см. в nFit1)
	 * @param error желаемая точность фитировки вдоль кривой
	 * @param xStops точки, в которых рекомендуется сделать изломы (для ломаной)
	 */
	private native void nFit4(double y[], int begin, int end, int fitMode,
			int linkFlags, double linkData0,
			double[] error, int[] xStops);

	/**
	 * Получить значение заданного параметра (по его имени)
	 * @param name имя параметра (поддерживаются только ASCII-имена)
	 * @param default_value значение по умолчанию на случай, если
	 *  параметр не определен.
	 * @return значение параметра
	 */
	private native double nGetAttr(String name, double default_value);

	/**
	 * Самая примитивная инициализация - как линейной функции y = 0 * x + 0
	 */
	private native void nInitAsLinear();

	/**
	 * Инициализация функции как прямой по двум точкам.
	 * @param x1 x-координата 1-й точки
	 * @param y1 y-коодрината 1-й точки
	 * @param x2 x-координата 2-й точки
	 * @param y2 y-координата 2-й точки
	 */
	private native void nSetAsLinear(
			int x1, double y1, int x2, double y2);

	/**
	 * Конструктор.
	 * Предназначен для создания объекта в производящих методах,
	 * операторе copy() и в native-коде.
	 *
	 */
	private ModelFunction() {
		this.shapeID = 0;
		this.pars = null;
	}

	/**
	 * Создает модельную функцию линейного типа (ax+b).
	 * Может быть использован как производящий метод.
	 * 
	 * @return модельная функция линейного типа ax+b, a=0, b=0 
	 */
	public static ModelFunction createLinear()
	{
		ModelFunction ret = new ModelFunction();
		ret.nInitAsLinear();
		return ret;
	}

	/**
	 * Создает модельную функцию линейного типа (ax+b), фитируя по RMS.
	 * Предполагается значения X от нуля до y.length-1
	 * @return модельная функция линейного типа ax+b, a=0, b=0 
	 */
	public static ModelFunction createLinearFrom0(double[]y)
	{
		ModelFunction ret = new ModelFunction();
		ret.nFit1(y, 0, y.length - 1, FITMODE_SET_LINEAR, 0, 0);
		return ret;
	}

	public void setAsLinear(
			int x1, double y1, int x2, double y2)
	{
		nSetAsLinear(x1, y1, x2, y2);
	}

	/**
	 * @return The width of the event.
	 * Gives zero for linears; transition region width for welds;
	 * front-to-edge distance for connectors.
	 * 
	 * @deprecated Undefined for currently used curves!
	 */
	@Deprecated
	public double getWidth0() {
		return nGetAttr("width", 0);
	}

	/**
	 * @return the height of the event front.
	 * @deprecated Undefined for currently used curves!
	 */
	@Deprecated
	public double getFrontHeight0() {
		return nGetAttr("fHeight", 0);
	}

	/**
	 * @return the y-step of the WELD(SPLICE) event; usually it is negative.
	 */
	public double getWeldStep0() {
		Log.debugMessage("weldStep = " + nGetAttr("weldStep", 0), INFO); // FIXIT
		return nGetAttr("weldStep", 0);
	}
	
	public double getEstimatedNoiseSuppressionLength()
	{
		return nGetAttr("noiseSuppressionLength", 1.0);
	}
	
	public boolean allowsLeftLinking()
	{
		return nGetAttr("canLeftLink", 0.0) != 0.0;
	}

	/**
	 * Shifts the curve to left as f_new(x) = f_old(x+dx).
	 * @param dx X shift distance
	 */
	public void shiftX(double dx) {
		//nShiftX(dx);
		nChangeByACXL(0, -dx, 0, 0);
	}

	/**
	 * Shifts the curve down as f_new(x) = f_old(x) - dy.
	 * @param dy Y shift distance
	 */
	public void shiftY(double dy) {
		//nShiftY(dy);
		nChangeByACXL(-dy, 0, 0, 0);
	}

	/**
	 * makes a deep copy (equal to clone) of this
	 * @return a copy
	 */
	public ModelFunction copy() {
		ModelFunction that = new ModelFunction();
		that.shapeID = this.shapeID;
		if (this.pars != null) {
			int len = this.pars.length;
			that.pars = new double[len];
			int i;
			for (i = 0; i < this.pars.length; i++)
				that.pars[i] = this.pars[i];
		}
		return that;
	}

	/**
	 * Calculates f(x) at one point
	 *
	 * @param x is arg of f(x)
	 * @return value of f(x)
	 */
	public double fun(double x) {
		return nF(x);
	}

	/**
	 * Fills the array with the values of f(x).
	 *
	 * @param x0      initial x (i.e. begin)
	 * @param step    x step (typically 1.0)
	 * @param length  number of points to evaluate (i.e. end + begin - 1)
	 * @return        the array, i-th element being equal f(x0 + step * i)
	 */
	public double[] funFillArray(double x0, double step, int length) {
		return nFArray(x0, step, length);

		// эквивалентная (но медленная) реализация:
		//double ret[] = new double[length];
		//for (int i = 0; i < length; i++)
		//  ret[i] = nF(x0 + step * i);
		//return ret;
	}

	/**
	 * Вычисляет среднеквадратичное отклонение между моделью и р/г
	 *
	 * @param y      рефлектограмма
	 * @param begin  начальный индекс
	 * @param end    конечный индекс включительно
	 * @return       среднеквадратичное отклонение
	 */
	public double calcRMS(double y[], int begin, int end) {
		return nRMS(y, begin, end);
	}

	/**
	 * Performs fitting
	 *
	 * @param y      real r/g data array
	 * @param begin  starting fitting array index
	 * @param end    ending fitting array index (length is end - begin + 1)
	 * @param linkFlags флажки для связывания с соседними событиями (пока только LINK_FIXLEFT)
	 * @param linkData0 данные для флажка LINK_FIXLEFT
	 */
	public void fit(double y[], int begin, int end, int linkFlags, double linkData0)
	{
		Log.debugMessage("fit-3: linkFlags " + linkFlags, FINEST);
		nFit1(y, begin, end, FITMODE_VARY_ALL, linkFlags, linkData0);
	}

	/**
	 * Performs fitting
	 *
	 * @param y      real r/g data array
	 * @param begin  starting fitting array index
	 * @param end    ending fitting array index (length is end - begin + 1)
	 * @param linkFlags флажки для связывания с соседними событиями (пока только LINK_FIXLEFT)
	 * @param linkData0 данные для флажка LINK_FIXLEFT
	 * @param errorR [test] undocumented
	 * @param errorA [test] undocumented
	 * @param maxPoints [test] undocumented
	 */
	public void fit(double y[], int begin, int end,
			int linkFlags, double linkData0,
			double errorR, double errorA, int maxPoints)
	{
		Log.debugMessage("fit-2: linkFlags " + linkFlags, FINEST);
		nFit2(y, begin, end, FITMODE_VARY_ALL,
			linkFlags, linkData0,
			errorR, errorA, maxPoints);
	}

	/**
	 * Фитирует участок заданный кривой кривой ломаной.
	 * Может использовать "подсказку" о границах событий, чтобы
	 * лучше расставить узлы создаваемой ломаной.
	 * @param y фитируемая кривая
	 * @param begin начальная точка (включительно) фитируемой кривой
	 * @param end конечная точка (включительно) фитируемой кривой
	 * @param noise точность фитировки (уровень шума) XXX: вроде как по 3 сигма 
	 * @param re набор событий, подсказывающий, где стоит поставить узлы
	 *  ломаной (используются точки начал событий), may be null
	 * @return фитированная ломаная в виде {@link ModelFunction}
	 */
	public static ModelFunction createFitedAsBreakL(double[] y,
			int begin, int end,
			double[] noise,
			SimpleReflectogramEvent[] re)
	{
		int[] stops = re != null ? new int[re.length] : null;
		if (re != null) {
			for (int i = 0; i < re.length; i++)
				stops[i] = re[i].getBegin();
		}
		ModelFunction mf = createLinear();
		mf.nFit4(y, begin, end, FITMODE_SET_BREAKL, 0, 0,
			noise, stops);
		return mf;
	}

	/**
	 * Performs linear fitting
	 *
	 * @param y      real r/g data array
	 * @param begin  starting fitting array index
	 * @param end    ending fitting array index (length is end - begin + 1)
	 * @param linkFlags флажки для связывания с соседними событиями (пока только LINK_FIXLEFT)
	 * @param linkData0 данные для флажка LINK_FIXLEFT
	 */
	public void fitLinearOnly(double y[], int begin, int end, int linkFlags, double linkData0)
	{
		Log.debugMessage("fit-1(Lin): linkFlags " + linkFlags, FINEST);
		nFit1(y, begin, end, FITMODE_VARY_LIN, linkFlags, linkData0);
	}

	/**
	 * Смещает профиль кривой, преобразуя его в АМФИКОМовский ACXL-порог.
	 * Может
	 * 
	 * @param ACXL  массив из четырех double порогов:
	 * ACXL[0]: A - сдвиг вверх,
	 * ACXL[1]: C - сдвиг вправо,
	 * ACXL[2]: X - изменение полуширины относительно центра,
	 * ACXL[3]: L - изменение амплитуры (размаха), относительно базового уроня.
	 */
	public void changeByACXLThreshold(double[] ACXL) {
		nChangeByACXL(ACXL[0], ACXL[1], ACXL[2], ACXL[3]);
	}

	public void changeByThresh(ThreshDX[] threshDX, ThreshDY[] threshDY, int key)
	{
		nChangeByThresh(threshDX, threshDY, key);
	}

	// no javadoc yet; see comment of nFindResponsibleThreshDXDYID
	public int findResponsibleThreshDXID(ThreshDX[] threshDX, ThreshDY[] threshDY, int key, int x)
	{
		return nFindResponsibleThreshDXDYID(threshDX, threshDY, key, x, 1);
	}
	public int findResponsibleThreshDYID(ThreshDX[] threshDX, ThreshDY[] threshDY, int key, int x)
	{
		return nFindResponsibleThreshDXDYID(threshDX, threshDY, key, x, 2);
	}

	// xMax *must* be >= xMin
	public int[] findResponsibleThreshDXArray(ThreshDX[] threshDX, ThreshDY[] threshDY, int key, int xMin, int xMax)
	{
		return nFindResponsibleThreshDXArray(threshDX, threshDY, key, xMin, xMax);
	}

	public void writeToDOS(DataOutputStream dos) throws IOException {
		dos.writeShort(SIGNATURE_MF_SHORT);
		dos.writeInt(this.shapeID);
		boolean useNativeStreaming = nIsNativeStreamingPossible(this.shapeID);
		dos.writeBoolean(useNativeStreaming);
		if (useNativeStreaming) {
			// native-преобразование
			byte[] bar = nParsToByteArray();
			dos.writeInt(bar.length);
			dos.write(bar);
		} else {
			// Java-преобразование
			dos.writeInt(this.pars.length);
			for (int i = 0; i < this.pars.length; i++)
				dos.writeDouble(this.pars[i]);
		}
	}

	public byte[] toByteArray()
	{
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		DataOutputStream dos = new DataOutputStream(baos);
		try
		{
			writeToDOS(dos);
			dos.close();
			return baos.toByteArray();
		} catch (IOException e)
		{
			throw new InternalError("Unexpected exception" + e.toString());
		}
	}

	public static ModelFunction createFromDIS(DataInputStream dis)
	throws IOException, SignatureMismatchException {
		ModelFunction mf = new ModelFunction();
		mf.readFromDIS(dis);
		return mf;
	}

	private void readFromDIS(DataInputStream dis)
	throws IOException, SignatureMismatchException {
		if (dis.readShort() != SIGNATURE_MF_SHORT) {
			throw new SignatureMismatchException();
		}
		this.shapeID = dis.readInt();
		boolean useNativeStreaming = dis.readBoolean();
		if (useNativeStreaming) {
			if (! nIsNativeStreamingPossible(this.shapeID))
				throw new InternalError("native streaming not supported for " + this.shapeID); // XXX: maybe a SignatureMismatchException would be better
			// native-преобразование
			int len = dis.readInt();
			byte[] bar = new byte[len];
			if (dis.read(bar) != bar.length)
				throw new SignatureMismatchException("Unexpected EOF");
			nParsFromByteArray(bar);
		} else {
			// Java-преобразование
			int npars = dis.readInt();
			this.pars = new double[npars];
			for (int i = 0; i < npars; i++)
				this.pars[i] = dis.readDouble();
		}
	}

	@Override
	public int hashCode() {
		int result = 17;
		result = 37 * result + shapeID;
		for (int i = 0; i < pars.length; i++) {
			long bits = Double.doubleToLongBits(pars[i]);
			result = 37 * result + (int)(bits ^ (bits >>>32));
		}
		return result;
	}

	// XXX: currently does return string presentation of
	// shapeID that is not available otherwise. This is bad, see EJ #9
	@Override
	public String toString() {
		return "MF(" + shapeID + ":" + pars.length + ":" + hashCode() + ")";
	}
}

