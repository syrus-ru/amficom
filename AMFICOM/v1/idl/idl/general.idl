/*-
 * $Id: general.idl,v 1.101 2005/07/26 17:23:28 arseniy Exp $
 *
 * Copyright ¿ 2004 Syrus Systems.
 * Dept. of Science & Technology.
 * Project: AMFICOM.
 */

#ifndef GENERAL_IDL
#define GENERAL_IDL

#include <streams.idl>

#include "dummy.idl"

#ifndef MY_COMPILER_IS_NOT_BRAINDEAD
module com {
module syrus {
module AMFICOM {
#else // MY_COMPILER_IS_NOT_BRAINDEAD
#pragma prefix "AMFICOM.syrus.com"
#endif // MY_COMPILER_IS_NOT_BRAINDEAD

module security {
	module corba {
		typedef wstring<128> WString128;

//////////////////// SecurityKey ///////////////////
		struct IdlSessionKey {
			WString128 sessionCode;
		};

	};
};

module general {
	module corba {


//////////////////// Useful definitions ///////////////////

		typedef string<32> String32;
		typedef wstring<32> WString32;
		typedef wstring<64> WString64;
		typedef sequence<WString64> WString64Seq;
		typedef wstring<128> WString128;
		typedef wstring<256> WString256;

		enum IdlDataType {
			DATA_TYPE_INTEGER,
			DATA_TYPE_DOUBLE,
			DATA_TYPE_STRING,
			DATA_TYPE_DATE,
			DATA_TYPE_LONG,
			DATA_TYPE_RAW,
			DATA_TYPE_BOOLEAN
		};


//////////////////// Exceptions ///////////////////

		exception AMFICOMRemoteException {
			enum IdlErrorCode {
				ERROR_LOGIN_NOT_FOUND,
				ERROR_ILLEGAL_DATA,
				ERROR_ILLEGAL_OBJECT_ENTITY,
				ERROR_SAVE,
				ERROR_NOT_FOUND,
				ERROR_RETRIEVE,
				ERROR_UPDATE,
				ERROR_DELETE,
				ERROR_VERSION_COLLISION,
				ERROR_ILLEGAL_LOGIN,
				ERROR_ILLEGAL_PASSWORD,
				ERROR_NO_DOMAINS_AVAILABLE,
				ERROR_NOT_LOGGED_IN,
				ERROR_ALREADY_LOGGED,
				ERROR_ACCESS_VALIDATION,
				ERROR_UNKNOWN
			} errorCode;
			enum IdlCompletionStatus {
				COMPLETED_YES,
				COMPLETED_NO,
				COMPLETED_PARTIALLY
			} completionStatus;
			wstring message;
		};

		exception IdlCreateObjectException {
			wstring detailMessage;
		};
	/*
		exception RemoteVersionCollisionException {
			long long desiredVersion;
			long long actualVersion;
			wstring message;
		};
	*/


//////////////////// Identifier ///////////////////

		struct IdlIdentifier {
			long long identifierCode;
		};

		typedef sequence<IdlIdentifier> IdlIdentifierSeq;


//////////////////// StorableObject ///////////////////

		valuetype IdlStorableObject {
			public IdlIdentifier id;
			public long long created;
			public long long modified;
			public IdlIdentifier creatorId;
			public IdlIdentifier modifierId;
			public long long version;

			general::StorableObject getNative() raises (IdlCreateObjectException);

			factory init(in IdlIdentifier id,
					in long long created,
					in long long modified,
					in IdlIdentifier creatorId,
					in IdlIdentifier modifierId,
					in long long version);
		};

		typedef sequence<IdlStorableObject> IdlStorableObjectSeq;


///////////////////////////// Condition ////////////////////////

		union IdlStorableObjectCondition switch (enum IdlStorableObjectConditionSort {
				EQUIVALENT,
				LINKED_IDS,
				TYPICAL,
				COMPOUND}) {
			case EQUIVALENT:
				struct IdlEquivalentCondition {
					short entityCode;
				} equivalentCondition;
			case LINKED_IDS:
				struct IdlLinkedIdsCondition {
					short entityCode;
					short linkedEntityCode;
					IdlIdentifierSeq linkedIds;
				} linkedIdsCondition;
			case TYPICAL:
				struct IdlTypicalCondition {
					short entityCode;
					WString256 key;
					WString256 value;
					WString256 otherValue;
					enum TypicalSort {
						TYPE_NUMBER_INT,
						TYPE_NUMBER_LONG,
						TYPE_NUMBER_DOUBLE,
						TYPE_STRING,
						TYPE_DATE,
						TYPE_BOOLEAN
					} sort;
					enum OperationSort {
						OPERATION_EQUALS,
						OPERATION_GREAT,
						OPERATION_LESS,
						OPERATION_GREAT_EQUALS,
						OPERATION_LESS_EQUALS,
						OPERATION_IN_RANGE,
						OPERATION_SUBSTRING,
						OPERATION_REGEXP,
						OPERATION_CI_REGEXP
					} operation;
				} typicalCondition;
			case COMPOUND:
				struct IdlCompoundCondition {
					enum CompoundConditionSort {
						AND,
						OR} sort;
#ifdef NO_STRUCT_RECURSION
					::CORBA::AnySeq innerConditions;
#else // NO_STRUCT_RECURSION
					sequence<IdlStorableObjectCondition> innerConditions;
#endif // NO_STRUCT_RECURSION
				} compoundCondition;
		};


///////////////////////// Common server interfaces //////////////////////////

		/**
		* superinterface for all verifiable references
		*/
		abstract interface Verifiable {
			void verify(in octet i);
		};

		/**
		* superinterface for identifier generators
		*/
		abstract interface IdentifierGeneratorServer {
			IdlIdentifier getGeneratedIdentifier(in unsigned short entity) raises (AMFICOMRemoteException);
			IdlIdentifierSeq getGeneratedIdentifierRange(in unsigned short entity, in unsigned long size) raises (AMFICOMRemoteException);
		};

		/**
		* pair (object id, version)
		*/
		struct IdVersion {
			IdlIdentifier id;
			long long version;
		};
		typedef sequence<IdVersion> IdVersionSeq;

		/**
		* common interface for all servers
		*/
		abstract interface CommonServer :
				Verifiable,
				IdentifierGeneratorServer {
#pragma version CommonServer 3.0

			IdlStorableObjectSeq transmitStorableObjects(in IdlIdentifierSeq ids,
					in security::corba::IdlSessionKey sessionKey)
					raises (AMFICOMRemoteException);

			IdlStorableObjectSeq transmitStorableObjectsButIdsByCondition(in IdlIdentifierSeq ids,
					in IdlStorableObjectCondition condition,
					in security::corba::IdlSessionKey sessionKey)
					raises (AMFICOMRemoteException);

			IdVersionSeq transmitRemoteVersions(in IdlIdentifierSeq ids,
					in security::corba::IdlSessionKey sessionKey)
					raises (AMFICOMRemoteException);

			void receiveStorableObjects(in IdlStorableObjectSeq storableObjects,
					in security::corba::IdlSessionKey sessionKey)
					raises (AMFICOMRemoteException);

			IdlIdentifierSeq transmitOldVersionIds(in IdVersionSeq idVersions,
					in security::corba::IdlSessionKey sessionKey)
					raises (AMFICOMRemoteException);

			void delete(in IdlIdentifierSeq ids,
					in security::corba::IdlSessionKey sessionKey)
					raises (AMFICOMRemoteException);
		};


////////////////////// ParameterType //////////////////////

		valuetype IdlParameterType : IdlStorableObject {
			public WString32 codename;
			public WString256 description;

			public WString128 name;
			public IdlDataType dataType;

			factory init(in IdlIdentifier id,
					in long long created,
					in long long modified,
					in IdlIdentifier creatorId,
					in IdlIdentifier modifierId,
					in long long version,
					in WString32 codename,
					in WString256 description,
					in WString128 name,
					in IdlDataType dataType);
		};

		typedef sequence<IdlParameterType> IdlParameterTypeSeq;


//////////////////// CharacteristicType ///////////////////

		valuetype IdlCharacteristicType : IdlStorableObject {
			enum CharacteristicTypeSort {
				CHARACTERISTICTYPESORT_OPTICAL,
				CHARACTERISTICTYPESORT_ELECTRICAL,
				CHARACTERISTICTYPESORT_OPERATIONAL,
				CHARACTERISTICTYPESORT_INTERFACE,
				CHARACTERISTICTYPESORT_VISUAL
			};

			public WString32 codename;
			public WString256 description;
			public WString128 name;
			public IdlDataType dataType;
			public CharacteristicTypeSort sort;

			factory init(in IdlIdentifier id,
					in long long created,
					in long long modified,
					in IdlIdentifier creatorId,
					in IdlIdentifier modifierId,
					in long long version,
					in WString32 codename,
					in WString256 description,
					in WString128 name,
					in IdlDataType dataType,
					in CharacteristicTypeSort sort);
		};

		typedef sequence<IdlCharacteristicType> IdlCharacteristicTypeSeq;


////////////////////// Characteristic /////////////////////

		valuetype IdlCharacteristic : IdlStorableObject {
			public IdlIdentifier _typeId;
			public WString128 name;
			public WString256 description;
			public WString256 value;
			public IdlIdentifier characterizableId;
			public boolean editable;
			public boolean visible;

			factory init(in IdlIdentifier id,
					in long long created,
					in long long modified,
					in IdlIdentifier creatorId,
					in IdlIdentifier modifierId,
					in long long version,
					in IdlIdentifier _typeId,
					in WString128 name,
					in WString256 description,
					in WString256 value,
					in IdlIdentifier characterizableId,
					in boolean editable,
					in boolean visible);
		};

		typedef sequence<IdlCharacteristic> IdlCharacteristicSeq;

	};
};

#ifndef MY_COMPILER_IS_NOT_BRAINDEAD
};
};
};
#endif // MY_COMPILER_IS_NOT_BRAINDEAD

#endif // GENERAL_IDL
