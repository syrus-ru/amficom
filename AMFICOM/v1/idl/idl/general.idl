/*-
 * $Id: general.idl,v 1.97 2005/07/13 15:59:05 arseniy Exp $
 *
 * Copyright ¿ 2004 Syrus Systems.
 * Dept. of Science & Technology.
 * Project: AMFICOM.
 */

#ifndef GENERAL_IDL
#define GENERAL_IDL

#include <streams.idl>

#include "dummy.idl"

#ifndef MY_COMPILER_IS_NOT_BRAINDEAD
module com {
module syrus {
module AMFICOM {
#else // MY_COMPILER_IS_NOT_BRAINDEAD
#pragma prefix "AMFICOM.syrus.com"
#endif // MY_COMPILER_IS_NOT_BRAINDEAD

module security {
	module corba {
		typedef wstring<128> WString128;

//////////////////// SecurityKey ///////////////////
		typedef struct IdlSessionKey {
			WString128 sessionCode;
		} SessionKey;
	};
};

module general {
	module corba {

		typedef string<32> String32;
		typedef wstring<32> WString32;
		typedef wstring<64> WString64;
		typedef sequence<WString64> WString64Seq;
		typedef wstring<128> WString128;
		typedef wstring<256> WString256;

		typedef struct IdlIdentifier {
			long long identifierCode;
		} Identifier;

		typedef sequence<Identifier> IdentifierSeq;

		exception IdlCreateObjectException {
			wstring detailMessage;
		};

		valuetype IdlStorableObject {
			public Identifier id;
			public long long created;
			public long long modified;
			public Identifier creatorId;
			public Identifier modifierId;
			public long long version;

			general::StorableObject getNative() raises (IdlCreateObjectException);

#ifndef NO_DEFAULT_FACTORIES
			factory defaultInit();
#endif // NO_DEFAULT_FACTORIES
			factory init(in Identifier id,
					in long long created,
					in long long modified,
					in Identifier creatorId,
					in Identifier modifierId,
					in long long version);
		};

		typedef IdlStorableObject StorableObject;
		typedef sequence<StorableObject> StorableObjectSeq;

		enum IdlDataType {
			DATA_TYPE_INTEGER,
			DATA_TYPE_DOUBLE,
			DATA_TYPE_STRING,
			DATA_TYPE_DATE,
			DATA_TYPE_LONG,
			DATA_TYPE_RAW,
			DATA_TYPE_BOOLEAN
		};

		exception AMFICOMRemoteException {
			enum ErrorCode {
				ERROR_LOGIN_NOT_FOUND,
				ERROR_ILLEGAL_DATA,
				ERROR_ILLEGAL_OBJECT_ENTITY,
				ERROR_SAVE,
				ERROR_NOT_FOUND,
				ERROR_RETRIEVE,
				ERROR_UPDATE,
				ERROR_DELETE,
				ERROR_VERSION_COLLISION,
				ERROR_ILLEGAL_LOGIN,
				ERROR_ILLEGAL_PASSWORD,
				ERROR_NO_DOMAINS_AVAILABLE,
				ERROR_NOT_LOGGED_IN,
				ERROR_ALREADY_LOGGED,
				ERROR_ACCESS_VALIDATION,
				ERROR_UNKNOWN
#ifdef STRICT				
			} error_code;
#else // STRICT
			} errorCode;
#endif // STRICT
			enum CompletionStatus {
				COMPLETED_YES,
				COMPLETED_NO,
				COMPLETED_PARTIALLY
#ifdef STRICT				
			} completion_status;
#else // STRICT
			} completionStatus;
#endif // STRICT
			wstring message;
		};
	/*
		exception RemoteVersionCollisionException {
			long long desiredVersion;
			long long actualVersion;
			wstring message;
		};
	*/

////////////////////// ParameterType //////////////////////

#ifdef NO_ALIASES
		valuetype IdlParameterType: IdlStorableObject {
#else // NO_ALIASES
		valuetype IdlParameterType: StorableObject {
#endif // NO_ALIASES
			public WString32 codename;
			public WString256 description;

			public WString128 name;
#ifdef STRICT
			public IdlDataType data_type;
#else // STRICT
			public IdlDataType dataType;
#endif // STRICT

			public IdentifierSeq characteristicIds;

#ifndef NO_DEFAULT_FACTORIES
			factory defaultInit();
#endif // NO_DEFAULT_FACTORIES
			factory init(in Identifier id,
					in long long created,
					in long long modified,
					in Identifier creatorId,
					in Identifier modifierId,
					in long long version,
					in WString32 codename,
					in WString256 description,
					in WString128 name,
					in IdlDataType dataType,
					in IdentifierSeq characteristicIds);
		};

		typedef IdlParameterType ParameterType;
		typedef sequence<ParameterType> ParameterTypeSeq;

//////////////////// CharacteristicType ///////////////////

#ifdef NO_ALIASES
		valuetype IdlCharacteristicType: IdlStorableObject {
#else // NO_ALIASES
		valuetype IdlCharacteristicType: StorableObject {
#endif // NO_ALIASES
			enum CharacteristicTypeSort {
				CHARACTERISTICTYPESORT_OPTICAL,
				CHARACTERISTICTYPESORT_ELECTRICAL,
				CHARACTERISTICTYPESORT_OPERATIONAL,
				CHARACTERISTICTYPESORT_INTERFACE,
				CHARACTERISTICTYPESORT_VISUAL
			};

			public WString32 codename;
			public WString256 description;
			public WString128 name;
#ifdef STRICT
			public IdlDataType data_type;
#else // STRICT
			public IdlDataType dataType;
#endif // STRICT
			public CharacteristicTypeSort sort;

#ifndef NO_DEFAULT_FACTORIES
			factory defaultInit();
#endif // NO_DEFAULT_FACTORIES
			factory init(in Identifier id,
					in long long created,
					in long long modified,
					in Identifier creatorId,
					in Identifier modifierId,
					in long long version,
					in WString32 codename,
					in WString256 description,
					in WString128 name,
					in IdlDataType dataType,
					in CharacteristicTypeSort sort);
		};

		typedef IdlCharacteristicType CharacteristicType;
		typedef sequence<CharacteristicType> CharacteristicTypeSeq;

////////////////////// Characteristic /////////////////////
#ifdef NO_ALIASES
		valuetype IdlCharacteristic: IdlStorableObject {
#else // NO_ALIASES
		valuetype IdlCharacteristic: StorableObject {
#endif // NO_ALIASES
			public Identifier _typeId;
			public WString128 name;
			public WString256 description;
			public WString256 value;
			public Identifier characterizableId;
			public boolean editable;
			public boolean visible;

#ifndef NO_DEFAULT_FACTORIES
			factory defaultInit();
#endif // NO_DEFAULT_FACTORIES
			factory init(in Identifier id,
					in long long created,
					in long long modified,
					in Identifier creatorId,
					in Identifier modifierId,
					in long long version,
					in Identifier _typeId,
					in WString128 name,
					in WString256 description,
					in WString256 value,
					in Identifier characterizableId,
					in boolean editable,
					in boolean visible);
		};

		typedef IdlCharacteristic Characteristic;
		typedef sequence<Characteristic> CharacteristicSeq;

///////////////////////// Verifiable //////////////////////////
		abstract interface Verifiable {
			void verify(in octet i);
		};

////////////////////// IdentifierGeneratorServer ///////////////

		abstract interface IdentifierGeneratorServer {
			Identifier getGeneratedIdentifier(in unsigned short entity) raises (AMFICOMRemoteException);
			IdentifierSeq getGeneratedIdentifierRange(in unsigned short entity, in unsigned long size) raises (AMFICOMRemoteException);
		};

/////////////////////////// CommonServer //////////////////////

		abstract interface CommonServer:
				Verifiable,
				IdentifierGeneratorServer {
#pragma version CommonServer 2.0
			void delete(in IdentifierSeq ids,
					in security::corba::SessionKey sessionKey)
					raises (AMFICOMRemoteException);

			IdentifierSeq transmitRefreshedStorableObjects(
					in StorableObjectSeq storableObjects,
					in security::corba::SessionKey sessionKey)
					raises (AMFICOMRemoteException);
		};

///////////////////////////// Condition ////////////////////////

		typedef union IdlStorableObjectCondition switch(enum StorableObjectConditionSort {
				LINKED_IDS,
				COMPOUND,
				TYPICAL,
				EQUIVALENT}) {
			case LINKED_IDS:
				struct IdlLinkedIdsCondition {
					short entityCode;
					short linkedEntityCode;
					IdentifierSeq linkedIds;
				} linkedIdsCondition;
			case COMPOUND:
				struct IdlCompoundCondition {
					enum CompoundConditionSort {
						AND,
						OR} sort;
#ifdef NO_STRUCT_RECURSION
					::CORBA::AnySeq innerConditions;
#else // NO_STRUCT_RECURSION
					sequence<IdlStorableObjectCondition> innerConditions;
#endif // NO_STRUCT_RECURSION
				} compoundCondition;
			case TYPICAL:
				struct IdlTypicalCondition {
					short entityCode;
					WString256 key;
					WString256 value;
					WString256 otherValue;
					enum TypicalSort {
						TYPE_NUMBER_INT,
						TYPE_NUMBER_LONG,
						TYPE_NUMBER_DOUBLE,
						TYPE_STRING,
						TYPE_DATE
					} type;
					enum OperationSort {
						OPERATION_EQUALS,
						OPERATION_GREAT,
						OPERATION_LESS,
						OPERATION_GREAT_EQUALS,
						OPERATION_LESS_EQUALS,
						OPERATION_IN_RANGE,
						OPERATION_SUBSTRING,
						OPERATION_REGEXP,
						OPERATION_CI_REGEXP
					} operation;
				} typicalCondition;
			case EQUIVALENT:
				struct IdlEquivalentCondition {
					short entityCode;
				} equivalentCondition;
		} StorableObjectCondition;
	};
};

#ifndef MY_COMPILER_IS_NOT_BRAINDEAD
};
};
};
#endif // MY_COMPILER_IS_NOT_BRAINDEAD

#endif // GENERAL_IDL
